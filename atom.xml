<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Young&#39;s Land</title>
  
  <subtitle>记录学习和日常</subtitle>
  <link href="https://ykxzyp0517.cn/atom.xml" rel="self"/>
  
  <link href="https://ykxzyp0517.cn/"/>
  <updated>2023-03-16T02:50:14.548Z</updated>
  <id>https://ykxzyp0517.cn/</id>
  
  <author>
    <name>KaiXuan Young</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Feign远程调用丢失请求信息\上下文</title>
    <link href="https://ykxzyp0517.cn/2023/03/16/Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF/"/>
    <id>https://ykxzyp0517.cn/2023/03/16/Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF/</id>
    <published>2023-03-16T02:10:15.000Z</published>
    <updated>2023-03-16T02:50:14.548Z</updated>
    
    <content type="html"><![CDATA[<p>Feign远程调用服务时会遇到俩问题，第一个问题是，在微服务项目中，我们做了单点登录，在项目使用feign远程调用另一个模块的远程服务时，发现提示无权限调用。第二个问题是异步调用时，老请求线程不共享问题，导致业务获取不到老请求报空指针异常。<span id="more"></span> </p><h1 id="Feign远程调用丢失请求头"><a href="#Feign远程调用丢失请求头" class="headerlink" title="Feign远程调用丢失请求头"></a>Feign远程调用丢失请求头</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在远程调用的方法上打个断点</span></span><br><span class="line">List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.进入方法内部 ReflectiveFeign.class</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//判断调用是不是equal方法</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//判断是不是调用hashCode</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断是不是调用toString 都不是就执行  ((MethodHandler)this.dispatch.get(method)).invoke(args);</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;toString&quot;</span>.equals(method.getName()) ? <span class="built_in">this</span>.toString() : ((MethodHandler)<span class="built_in">this</span>.dispatch.get(method)).invoke(args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">otherHandler</span> <span class="operator">=</span> args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.equals(otherHandler);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. ((MethodHandler)this.dispatch.get(method)).invoke(args); </span></span><br><span class="line"><span class="comment">//点击进入invoke 方法  SynchronousMethodHandler.class</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">//就是在这 构建了一个新的RequestTemplate ，而浏览器带给我们的请求头都会丢失</span></span><br><span class="line">        <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="built_in">this</span>.buildTemplateFromArgs.create(argv);</span><br><span class="line">        <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在这即将执行该方法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.executeAndDecode(template);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RetryableException var8) &#123;</span><br><span class="line">                <span class="type">RetryableException</span> <span class="variable">e</span> <span class="operator">=</span> var8;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    retryer.continueOrPropagate(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RetryableException var7) &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> var7.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.propagationPolicy == ExceptionPropagationPolicy.UNWRAP &amp;&amp; cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> cause;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> var7;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.logLevel != Level.NONE) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.logger.logRetry(<span class="built_in">this</span>.metadata.configKey(), <span class="built_in">this</span>.logLevel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们找到了feign远程调用请求头丢失的原因： </p><p><img data-src="/images/pasted-689.png" alt="upload successful"><br>继续深入executeAndDecode方法查看原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    Object <span class="title function_">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//这里 它会对我们的请求进行一些包装 </span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="built_in">this</span>.targetRequest(template);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logLevel != Level.NONE) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.logRequest(<span class="built_in">this</span>.metadata.configKey(), <span class="built_in">this</span>.logLevel, request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = <span class="built_in">this</span>.client.execute(request, <span class="built_in">this</span>.options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logLevel != Level.NONE) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.logIOException(<span class="built_in">this</span>.metadata.configKey(), <span class="built_in">this</span>.logLevel, var15, <span class="built_in">this</span>.elapsedTime(start));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> FeignException.errorExecuting(request, var15);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面我们查看一下targetRequest方法</span></span><br><span class="line">Request <span class="title function_">targetRequest</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line"><span class="comment">//拿到对应的所有请求拦截器的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.requestInterceptors.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有的请求拦截器</span></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            <span class="type">RequestInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (RequestInterceptor)var2.next();</span><br><span class="line">            <span class="comment">//这里是每个请求拦截器 依次对该方法进行包装</span></span><br><span class="line">            interceptor.apply(template);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.target.apply(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我们发现它是一个接口 所以可以重写一下这个方法 对我们的请求做一些包装 借鉴一下别的实现方法  </p></blockquote><pre><code class="java">public interface RequestInterceptor &#123;    void apply(RequestTemplate var1);&#125;public class BasicAuthRequestInterceptor implements RequestInterceptor &#123;  public void apply(RequestTemplate template) &#123;        template.header(&quot;Authorization&quot;, new String[]&#123;this.headerValue&#125;);    &#125;&#125;</code></pre><p>于是我写了一个feign拦截器，这里面注入了一个<code>RequestInterceptor</code>的对象，它是一个接口，我重写了它的<code>apply</code>方法，在里面拿到老请求中的请求头信息，放到这个新的请求模板里，我这里更新的是<code>cookie</code>。  </p><pre><code>  @Configuration  public class MallFeignConfig &#123;      @Bean      public RequestInterceptor requestInterceptor()&#123;          return new RequestInterceptor() &#123;              @Override              public void apply(RequestTemplate requestTemplate) &#123;                  ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();                  HttpServletRequest request = attributes.getRequest();                  String Cookie = request.getHeader(&quot;Cookie&quot;);                  requestTemplate.header(&quot;Cookie&quot; , Cookie);              &#125;          &#125;;      &#125;  &#125;</code></pre><h1 id="Feign请求丢失上下文问题"><a href="#Feign请求丢失上下文问题" class="headerlink" title="Feign请求丢失上下文问题"></a>Feign请求丢失上下文问题</h1><p>在一个请求的执行过程中，如果有一个新的异步请求出来执行别的任务，那么在该新的请求中是拿不到老的请求的上下文环境的。</p><p><img data-src="/images/pasted-690.png" alt="upload successful">    </p><pre><code>  @Configuration  public class MallFeignConfig &#123;      @Bean      public RequestInterceptor requestInterceptor()&#123;          return new RequestInterceptor() &#123;              @Override              public void apply(RequestTemplate requestTemplate) &#123;                  ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();                  HttpServletRequest request = attributes.getRequest();                  String Cookie = request.getHeader(&quot;Cookie&quot;);                  requestTemplate.header(&quot;Cookie&quot; , Cookie);              &#125;          &#125;;      &#125;  &#125;</code></pre><blockquote><p>总是产生attribut的空指针异常，<code>RequestContextHolder.getRequestAttributes()</code>是通过threadlocal获取上下文。  不同线程，不发读取上下文。  </p></blockquote><pre><code>  @Override      public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException &#123;          OrderConfirmVo orderConfirmVo = new OrderConfirmVo();          MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();          CompletableFuture&lt;Void&gt; addressFuture = CompletableFuture.runAsync(() -&gt; &#123;              //1.远程查询所有的收货地址列表              List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());              orderConfirmVo.setAddress(address);          &#125;, executor);          CompletableFuture&lt;Void&gt; cartFuture = CompletableFuture.runAsync(() -&gt; &#123;              //2.远程查询所有的购物项              List&lt;OrderItemVo&gt; orderItemVos = cartFeignService.cartItems();              orderConfirmVo.setItems(orderItemVos);          &#125;, executor);          CompletableFuture.allOf(addressFuture , cartFuture).get();          //3.查询用户积分          orderConfirmVo.setIntegration(memberRespVo.getIntegration());          return orderConfirmVo;      &#125;</code></pre><blockquote><p>在主线程中获取上下文数据    </p></blockquote><pre><code>  RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();  </code></pre><blockquote><p>在每个线程中共享之前的请求数据  </p></blockquote><pre><code>  RequestContextHolder.setRequestAttributes(requestAttributes);     </code></pre><p>总体编码如下：  </p><pre><code>  @Override      public OrderConfirmVo confirmOrder() throws ExecutionException, InterruptedException &#123;          OrderConfirmVo orderConfirmVo = new OrderConfirmVo();          MemberRespVo memberRespVo = LoginUserInterceptor.loginUser.get();          RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();          CompletableFuture&lt;Void&gt; addressFuture = CompletableFuture.runAsync(() -&gt; &#123;              RequestContextHolder.setRequestAttributes(requestAttributes);              //1.远程查询所有的收货地址列表              List&lt;MemberAddressVo&gt; address = memberFeignService.getAddress(memberRespVo.getId());              orderConfirmVo.setAddress(address);          &#125;, executor);          CompletableFuture&lt;Void&gt; cartFuture = CompletableFuture.runAsync(() -&gt; &#123;              RequestContextHolder.setRequestAttributes(requestAttributes);              //2.远程查询所有的购物项              List&lt;OrderItemVo&gt; orderItemVos = cartFeignService.cartItems();              orderConfirmVo.setItems(orderItemVos);          &#125;, executor);          CompletableFuture.allOf(addressFuture , cartFuture).get();          //3.查询用户积分          orderConfirmVo.setIntegration(memberRespVo.getIntegration());          return orderConfirmVo;      &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Feign远程调用服务时会遇到俩问题，第一个问题是，在微服务项目中，我们做了单点登录，在项目使用feign远程调用另一个模块的远程服务时，发现提示无权限调用。第二个问题是异步调用时，老请求线程不共享问题，导致业务获取不到老请求报空指针异常。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringCloudAlibaba-Nacos(服务注册和配置中心)、Sentinel（实现熔断和限流）、Seata(处理分布式事务)</title>
    <link href="https://ykxzyp0517.cn/2022/11/16/SpringCloudAlibaba/"/>
    <id>https://ykxzyp0517.cn/2022/11/16/SpringCloudAlibaba/</id>
    <published>2022-11-16T05:12:12.000Z</published>
    <updated>2022-11-23T05:39:02.370Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。<span id="more"></span><br>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>诞生：2018.10.31，Spring Cloud Alibaba 正式入驻了Spring Cloud官方孵化器，并在Maven 中央库发布了第一个版本。<br><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/README-zh.md</a>  </p><pre><code>&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;</code></pre><blockquote><p>Spring Cloud Alibaba学习资料获取</p></blockquote><p>官网</p><p><a href="https://spring.io/projects/spring-cloud-alibaba#overview">https://spring.io/projects/spring-cloud-alibaba#overview</a><br>英文</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a><br><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a></p><p>中文</p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>Nacos 是一个易于使用的动态服务发现、配置和服务管理平台，用于构建云原生应用程序。</p><p>借助Spring Cloud Alibaba Nacos Discovery，您可以快速接入基于Spring Cloud编程模型的Nacos服务注册功能。</p><p>Nacos就是注册中心＋配置中心的组合 -&gt; Nacos &#x3D; Eureka+Config+Bus</p><p><a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a><br><a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a>  </p><p>bin目录下执行命令 sh startup.sh -m standalone  </p><p><img data-src="/images/pasted-347.png" alt="upload successful">  </p><p>账号密码 nacos nacos</p><p><img data-src="/images/pasted-348.png" alt="upload successful">  </p><h1 id="Nacos作为服务中心"><a href="#Nacos作为服务中心" class="headerlink" title="Nacos作为服务中心"></a>Nacos作为服务中心</h1><h2 id="Provider9001、9002"><a href="#Provider9001、9002" class="headerlink" title="Provider9001、9002"></a>Provider9001、9002</h2><p>pom</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;        </code></pre><p>yml</p><pre><code>server:  port: 9001spring:  application:    name: cloudalibaba-provider-9001  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848management:  endpoints:    web:      exposure:        include: *</code></pre><p>主启动类 </p><pre><code>@SpringBootApplication@EnableDiscoveryClientpublic class NacosProvider9001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(NacosProvider9001.class , args);    &#125;&#125;</code></pre><p>简单编写一个业务类  </p><pre><code>@RestControllerpublic class PaymentController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(&quot;/payment/nacos/&#123;id&#125;&quot;)    public String getPayment(@PathVariable(&quot;id&quot;)Integer id)&#123;        return &quot;nacos regitry , serverPort:&quot; + serverPort + &quot;\tid : &quot; + id;    &#125;&#125;</code></pre><p>同时搭建一个服务端口9002的服务  </p><p><img data-src="/images/pasted-349.png" alt="upload successful"><br>用来测试负载均衡  </p><blockquote><p>为什么nacos自带负载均衡？  </p></blockquote><p><img data-src="/images/pasted-350.png" alt="upload successful">  </p><h2 id="Consumer83"><a href="#Consumer83" class="headerlink" title="Consumer83"></a>Consumer83</h2><p>POM相同不再赘述</p><p>YMl </p><pre><code>server:  port: 83spring:  application:    name: nacos-order-consumer  cloud:    nacos:      discovery:        server-addr: localhost:8848#消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）service-url:  nacos-user-service: http://cloudalibaba-provider</code></pre><p>主启动类</p><pre><code>@SpringBootApplication@EnableDiscoveryClientpublic class NacosConsumer83 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(NacosConsumer83.class , args);    &#125;&#125;</code></pre><p>业务类  </p><pre><code>@RestControllerpublic class OrderNacosController &#123;    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)    private String serverUrl;    @Resource    private RestTemplate restTemplate;    @GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)    public String paymentIndo(@PathVariable(&quot;id&quot;) Long id)&#123;        return restTemplate.getForObject(serverUrl+ &quot;/payment/nacos/&quot;+id , String.class);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-351.png" alt="upload successful">  </p><h1 id="Nacos服务注册中心对比提升"><a href="#Nacos服务注册中心对比提升" class="headerlink" title="Nacos服务注册中心对比提升"></a>Nacos服务注册中心对比提升</h1><p>Nacos全景图</p><p><img data-src="/images/pasted-352.png" alt="upload successful">  </p><h2 id="Nacos和CAP"><a href="#Nacos和CAP" class="headerlink" title="Nacos和CAP"></a>Nacos和CAP</h2><p>Nacos与其他注册中心特性对比  </p><p><img data-src="/images/pasted-353.png" alt="upload successful">  </p><blockquote><p>Nacos支持AP和CP模式的切换  </p></blockquote><p>C是所有节点在同一时间看到的数据是一致的;而A的定义是所有的请求都会收到响应。  </p><blockquote><p>何时选择使用何种模式?</p></blockquote><p>—般来说，如果不需要<code>存储服务</code>级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的<code>可能性</code>而<code>减弱了一致性</code>，因此AP模式下只支持<code>注册临时实例</code>。</p><p>如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持<code>注册持久化实例</code>，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><p>切换命令：<br>curl -X PUT ‘$NACOS_SERVER:8848&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;operator&#x2F;switches?entry&#x3D;serverMode&amp;value&#x3D;CP</p><h1 id="Nacos作为服务配置中心"><a href="#Nacos作为服务配置中心" class="headerlink" title="Nacos作为服务配置中心"></a>Nacos作为服务配置中心</h1><p>pom</p><pre><code>&lt;dependencies&gt;        &lt;!--nacos-config--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--nacos-discovery--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--web + actuator--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--一般基础配置--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>yml -bootstrap</p><pre><code>server:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: localhost:8848  # Nacos服务注册中心地址      config:        server-addr: localhost:8848 # Nacos作为服务配置中心地址        file-extension: yaml # 指定yaml格式的配置</code></pre><p>yml -application</p><pre><code>spring:  profiles:    active: dev # 表示开发环境</code></pre><p><img data-src="/images/pasted-355.png" alt="upload successful">  </p><p>在Nacos配置中心中建立yml  </p><p><img data-src="/images/pasted-356.png" alt="upload successful">  </p><p>成功访问到了相应的配置文件信息  </p><p><img data-src="/images/pasted-357.png" alt="upload successful">  </p><p>使用<code>@RefreshScope</code>注解后，支持动态刷新  </p><p><img data-src="/images/pasted-358.png" alt="upload successful">  </p><h1 id="Nacos之命名空间、分组和DataID三者关系"><a href="#Nacos之命名空间、分组和DataID三者关系" class="headerlink" title="Nacos之命名空间、分组和DataID三者关系"></a>Nacos之命名空间、分组和DataID三者关系</h1><blockquote><p>问题 - 多环境多项目管理  </p></blockquote><blockquote><p>问题1:</p></blockquote><p>实际开发中，通常一个系统会准备</p><p>dev开发环境<br>test测试环境<br>prod生产环境。<br>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?</p><blockquote><p>问题2:</p></blockquote><p>一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?</p><p><img data-src="/images/pasted-359.png" alt="upload successful">  </p><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p><img data-src="/images/pasted-361.png" alt="upload successful">  </p><ul><li>默认情况：Namespace&#x3D;public，Group&#x3D;DEFAULT_GROUP，默认Cluster是DEFAULT</li></ul><ul><li><p>Nacos默认的Namespace是public，Namespace主要用来实现隔离。  </p></li><li><p>比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。</p></li><li><p>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</p></li><li><p>Service就是微服务:一个Service可以包含多个Cluster (集群)</p></li><li><p>Nacos默认   Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。</p></li></ul><p>比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ) ，给广州机房的Service微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。</p><ul><li>最后是Instance，就是微服务的实例。</li></ul><h2 id="DataId配置"><a href="#DataId配置" class="headerlink" title="DataId配置"></a>DataId配置</h2><p><img data-src="/images/pasted-362.png" alt="upload successful"><br>在nacos配置中心中新建一个yaml，为测试环境实例  </p><p><img data-src="/images/pasted-363.png" alt="upload successful"><br>修改application.yml文件内容，切换到测试环境，与DataID匹配后  </p><p><img data-src="/images/pasted-364.png" alt="upload successful"><br>配置文件直接刷新  </p><p><img data-src="/images/pasted-365.png" alt="upload successful">  </p><h2 id="Group配置"><a href="#Group配置" class="headerlink" title="Group配置"></a>Group配置</h2><p>此时不同的Group有相同的配置文件  </p><p><img data-src="/images/pasted-367.png" alt="upload successful"></p><p>此时添加GROUP的配置内容<br><img data-src="/images/pasted-368.png" alt="upload successful">  </p><p><img data-src="/images/pasted-369.png" alt="upload successful"> </p><p>读取成功  </p><p><img data-src="/images/pasted-370.png" alt="upload successful">  </p><h2 id="NameSpace配置"><a href="#NameSpace配置" class="headerlink" title="NameSpace配置"></a>NameSpace配置</h2><p><img data-src="/images/pasted-371.png" alt="upload successful"><br>原始的命名空间只有public  </p><p><img data-src="/images/pasted-372.png" alt="upload successful"><br>新建两个命名空间  </p><p><img data-src="/images/pasted-373.png" alt="upload successful"><br>此时配置管理列表头部新增两个命名空间  </p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在DEV中创建不同分组的不同配置文件<br><img data-src="/images/pasted-374.png" alt="upload successful">    </p><p>yml–bootstrap.yml  </p><pre><code>server:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: localhost:8848  # Nacos服务注册中心地址      config:        server-addr: localhost:8848 # Nacos作为服务配置中心地址        file-extension: yaml # 指定yaml格式的配置        group: DEV_GROUP        namespace: 96ba7452-bdaf-4b89-a1e5-b62fb08e2fc5        </code></pre><p>yml–application.yml  </p><pre><code>spring:  profiles:    active: test # 表示开发环境    </code></pre><p>此时成功读取到相应的配置文件  </p><p><img data-src="/images/pasted-375.png" alt="upload successful">  </p><h1 id="Nacos集群和持久化配置（Important）"><a href="#Nacos集群和持久化配置（Important）" class="headerlink" title="Nacos集群和持久化配置（Important）"></a>Nacos集群和持久化配置（Important）</h1><h2 id="集群部署架构图"><a href="#集群部署架构图" class="headerlink" title="集群部署架构图"></a>集群部署架构图</h2><p><img data-src="/images/pasted-376.png" alt="upload successful">  </p><p>实际架构  </p><p><img data-src="/images/pasted-377.png" alt="upload successful">  </p><p>默认Nacos使用<code>嵌入式</code>数据库<code>derby</code>实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在<code>一致性</code>问题的。为了解决这个问题，Nacos采用了<code>集中式存储</code>的方式来支持集群化部署，目前<code>只支持MySQL</code>的存储。</p><p>Nacos支持三种部署模式</p><ul><li>单机模式-用于测试和单机试用。</li><li>集群模式-用于生产环境，确保高可用。</li><li>多集群模式-用于多数据中心场景。</li></ul><h2 id="Nacos持久化切换配置"><a href="#Nacos持久化切换配置" class="headerlink" title="Nacos持久化切换配置"></a>Nacos持久化切换配置</h2><p>Nacos默认自带的是嵌入式数据库derby，nacos的pom.xml中可以看出。</p><p>derby到mysql切换配置步骤：</p><ul><li>nacos-server-1.1.4\nacos\conf录下找到nacos-mysql.sql文件，执行脚本。</li><li>nacos-server-1.1.4\nacos\conf目录下找到application.properties，添加以下配置（按需修改对应值）。</li></ul><h2 id="Linux版本nacos"><a href="#Linux版本nacos" class="headerlink" title="Linux版本nacos"></a>Linux版本nacos</h2><p>将压缩包上传后，运行startup.sh。注意java_home的配置。  </p><p><img data-src="/images/pasted-378.png" alt="upload successful">  </p><p><img data-src="/images/pasted-379.png" alt="upload successful"><br>修改Nacos的启动脚本，设置不同的脚本  </p><h2 id="Mysql数据库配置"><a href="#Mysql数据库配置" class="headerlink" title="Mysql数据库配置"></a>Mysql数据库配置</h2><p>可以通过navicat等工具远程执行sql文件。&#x2F;nacos&#x2F;conf&#x2F; nacos-mysql.sql<br>配置文件数据库为  </p><p><img data-src="/images/pasted-380.png" alt="upload successful">  </p><h2 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h2><p>备份application.properties  </p><pre><code> cp application.properties application.properties.bk</code></pre><p><img data-src="/images/pasted-381.png" alt="upload successful"><br>在application.properties中进行如下配置  </p><p><img data-src="/images/pasted-382.png" alt="upload successful">  </p><h2 id="cluster-conf配置"><a href="#cluster-conf配置" class="headerlink" title="cluster.conf配置"></a>cluster.conf配置</h2><p>通过hostname -i查看ip后配置端口<br><img data-src="/images/pasted-383.png" alt="upload successful">  </p><h2 id="startup-sh编辑"><a href="#startup-sh编辑" class="headerlink" title="startup.sh编辑"></a>startup.sh编辑</h2><p>&#x2F;mynacos&#x2F;nacos&#x2F;bin目录下有startup.sh  </p><p><img data-src="/images/pasted-384.png" alt="upload successful"><br>平时单机版的启动，都是.&#x2F;startup.sh即可</p><p>但是，集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。<br>命令: .&#x2F;startup.sh -p 3333表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。</p><p>修改内容</p><p><img data-src="/images/pasted-385.png" alt="upload successful">  </p><p><img data-src="/images/pasted-386.png" alt="upload successful">  </p><p><img data-src="/images/pasted-387.png" alt="upload successful">  </p><h2 id="NGINX配置"><a href="#NGINX配置" class="headerlink" title="NGINX配置"></a>NGINX配置</h2><p><img data-src="/images/pasted-388.png" alt="upload successful"><br>监听端口1111，转发到集群cluster  </p><h2 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h2><ul><li><p>启动3个nacos注册中心</p><ul><li><p>startup.sh - p 3333</p></li><li><p>startup.sh - p 4444</p></li><li><p>startup.sh - p 5555</p></li></ul></li><li><p>查看nacos进程启动数ps -ef | grep nacos | grep -v grep | wc -l  </p></li><li><p>启动nginx</p><ul><li>.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</li></ul></li><li><p>查看nginx进程ps - ef| grep nginx</p></li><li><p>测试通过nginx，访问nacos - <a href="http://192.168.200.160:1111/nacos/#/login">http://192.168.200.160:1111/nacos/#/login</a></p></li></ul><p><img data-src="/images/pasted-389.png" alt="upload successful"><br>新建后，可在linux服务器的mysql新插入一条记录  </p><p><img data-src="/images/pasted-390.png" alt="upload successful"><br>让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件<br><img data-src="/images/pasted-391.png" alt="upload successful"><br>成功注册<br><img data-src="/images/pasted-392.png" alt="upload successful">  </p><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a>  </p><p><img data-src="/images/pasted-393.png" alt="upload successful"><br>服务使用中的各种问题：</p><ul><li>服务雪崩</li><li>服务降级</li><li>服务熔断</li><li>服务限流</li></ul><p>Sentinel 分为两个部分：</p><ul><li>核心库（Java 客户端）不依赖任何框架&#x2F;库，能够运行于所有 Java 运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>安装步骤：</p><ul><li>下载</li></ul><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a><br>下载到本地sentinel-dashboard-1.7.0.jar<br>运行命令</p><ul><li><p>前提<br>Java 8 环境<br>8080端口不能被占用</p></li><li><p>命令 <code>java -jar sentinel-dashboard-1.7.0.jar</code><br>访问Sentinel管理界面</p></li><li><p>localhost:8080<br>登录账号密码均为sentinel</p></li></ul><p><img data-src="/images/pasted-394.png" alt="upload successful">  </p><h2 id="Sentinel初始化监控"><a href="#Sentinel初始化监控" class="headerlink" title="Sentinel初始化监控"></a>Sentinel初始化监控</h2><p>新建工程cloudalibaba-sentinel-service8401<br>pom</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--SpringCloud ailibaba nacos --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--SpringCloud ailibaba sentinel --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--openfeign--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- SpringBoot整合Web组件+actuator --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--日常通用jar包配置--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;4.6.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>yml</p><pre><code>server:  port: 8401spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        #配置sentinel dashboard的地址        dashboard: localhost:8080        port: 8719management:  endpoints:    web:      exposure:        include: &#39;*&#39;</code></pre><p>controller</p><pre><code>@RestControllerpublic class FlowLimitController &#123;    @GetMapping(&quot;/testA&quot;)    public String testA()&#123;        return &quot;-----testA&quot;;    &#125;    @GetMapping(&quot;/testB&quot;)    public String testB()&#123;        return &quot;-----testB&quot;;    &#125;&#125;</code></pre><p>住启动类  </p><pre><code>@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApp8401.class , args);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-395.png" alt="upload successful"><br>发现空空的，因为sentinel采用懒加载机制，需要一次访问进行激活才行。  </p><p><img data-src="/images/pasted-396.png" alt="upload successful">  </p><h2 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h2><p><img data-src="/images/pasted-397.png" alt="upload successful"><br>进一步解释说明：</p><ul><li>资源名：唯一名称，默认请求路径。</li><li>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。</li><li>阈值类型&#x2F;单机阈值：<ul><li>QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。</li><li>线程数：当调用该API的线程数达到阈值的时候，进行限流。</li></ul></li><li>是否集群：不需要集群。</li><li>流控模式：<ul><li>直接：API达到限流条件时，直接限流。</li><li>关联：当关联的资源达到阈值时，就限流自己。</li><li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。</li></ul></li><li>流控效果：<ul><li>快速失败：直接失败，抛异常。</li><li>Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值&#x2F;codeFactor，经过预热时长，才达到设置的QPS阈值。</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。</li></ul></li></ul><h3 id="阈值类型"><a href="#阈值类型" class="headerlink" title="阈值类型"></a>阈值类型</h3><blockquote><p>新建QPS为1 ， 其中资源名默认为请求路径  </p></blockquote><p><img data-src="/images/pasted-398.png" alt="upload successful"><br>多次访问后直接返回错误<br><img data-src="/images/pasted-399.png" alt="upload successful">  </p><blockquote><p>思考</p></blockquote><p>直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?  </p><blockquote><p>线程数为1<br>线程数：当调用该API的线程数达到阈值的时候，进行限流。</p></blockquote><h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><p>关联是什么？</p><ul><li><p>当自己关联的资源达到阈值时，就限流自己</p></li><li><p>当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）</p></li></ul><p><img data-src="/images/pasted-400.png" alt="upload successful">  </p><p>使用postman压力测试&#x2F;testB,20个线程3s的频率去测试</p><p><img data-src="/images/pasted-401.png" alt="upload successful"><br>此时再去访问关联的&#x2F;testA，直接挂了  </p><p><img data-src="/images/pasted-402.png" alt="upload successful">  </p><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><p><img data-src="/images/pasted-404.png" alt="upload successful">  </p><blockquote><p>Warm Up</p></blockquote><p>Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档，具体的例子可以参见 WarmUpFlowDemo。</p><p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p><p><img data-src="/images/pasted-405.png" alt="upload successful">  </p><p>下图的意思是，阈值的QPS为10，但是一开始不必要一下子为10，冷因子默认为3，一开始的QPS为10&#x2F;3，但是经过warmup的时间后，需要达到10  </p><blockquote><p>默认coldFactor为3，即请求QPS 从 threshold &#x2F; 3开始，经预热时长逐渐升至设定的QPS阈值。</p></blockquote><p><img data-src="/images/pasted-406.png" alt="upload successful">  </p><blockquote><p>排队等待  </p></blockquote><p>匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。 </p><p><img data-src="/images/pasted-407.png" alt="upload successful">  </p><h2 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7</a></p><p><img data-src="/images/pasted-408.png" alt="upload successful">  </p><ul><li><p>RT（平均响应时间，秒级）</p><ul><li>平均响应时间 超出阈值 且 在时间窗口内通过的请求&gt;&#x3D;5，两个条件同时满足后触发降级。</li></ul></li></ul><p>窗口期过后关闭断路器。RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt&#x3D;XXXX才能生效）。</p><ul><li><p>异常比列（秒级）</p><ul><li>QPS &gt;&#x3D; 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。</li></ul></li><li><p>异常数(分钟级)</p><ul><li>异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级</li></ul></li></ul><blockquote><p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p></blockquote><blockquote><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。</p></blockquote><blockquote><p>Sentinei的断路器是没有类似Hystrix半开状态的。(Sentinei 1.8.0 已有半开状态)</p></blockquote><blockquote><p>半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。</p></blockquote><h3 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h3><p>平均响应时间(DEGRADE_GRADE_RT)：当1s内持续进入5个请求，对应时刻的平均响应时间（秒级）均超过阈值（ count，以ms为单位），那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断(抛出DegradeException )。注意Sentinel 默认统计的RT上限是4900 ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt&#x3D;xxx来配置。</p><p><img data-src="/images/pasted-409.png" alt="upload successful">  </p><pre><code>@GetMapping(&quot;/testD&quot;)    public String testD() &#123;        try &#123;            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return  &quot;---testD&quot;;    &#125;</code></pre><p><img data-src="/images/pasted-410.png" alt="upload successful"><br>使用Jmemter压测 </p><p><img data-src="/images/pasted-411.png" alt="upload successful"><br>按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。</p><h3 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h3><p><img data-src="/images/pasted-413.png" alt="upload successful"><br>异常比例(DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;&#x3D; 5，并且每秒异常总数占通过量的比值超过阈值（ DegradeRule中的 count）之后，资源进入降级状态，即在接下的时间窗口( DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0, 1.0]，代表0% -100%。</p><blockquote><p>注意，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：</p></blockquote><p>异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p><p>controller</p><pre><code> @GetMapping(&quot;/testD&quot;)    public String testD() &#123;        int i = 10/0;        return  &quot;---testD&quot;;    &#125;    </code></pre><p><img data-src="/images/pasted-412.png" alt="upload successful"><br>按照上述配置，单独访问一次，必然来一次报错一次(int age &#x3D; 10&#x2F;0)，调一次错一次。</p><p>开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了。  </p><h3 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h3><p>异常数( DEGRADE_GRADF_EXCEPTION_COUNT )：当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s，则结束熔断状态后马上可能再进入熔断状态。  </p><blockquote><p>注意，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：  </p></blockquote><p>异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p><p>controller</p><pre><code> @GetMapping(&quot;/testD&quot;)    public String testD() &#123;        int i = 10/0;        return  &quot;---testD&quot;;    &#125;</code></pre><p><img data-src="/images/pasted-414.png" alt="upload successful">  </p><h2 id="热点Key"><a href="#热点Key" class="headerlink" title="热点Key"></a>热点Key</h2><p><a href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html?spm=sentinel-github.wiki.0.0.0">https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html?spm=sentinel-github.wiki.0.0.0</a><br><img data-src="/images/pasted-415.png" alt="upload successful">  </p><p>兜底方法，分为系统默认和客户自定义，两种</p><p>之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting)</p><p>我们能不能自定？类似hystrix，某个方法出问题了，就找对应的兜底降级方法?</p><blockquote><p>结论 - 从HystrixCommand到@SentinelResource  </p></blockquote><p>在Controller中方法，其中SentinelResource就是配置fallBack的注解。</p><pre><code>@GetMapping(&quot;/testHotKey&quot;)    @SentinelResource(value = &quot;testHotKey&quot; , blockHandler = &quot;deal_testHotKey&quot;)    public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1 ,                             @RequestParam(value = &quot;p2&quot; , required = false)  String p2)&#123;        return &quot;-------testHotKey&quot;;    &#125;    public String deal_testHotKey(String p1 , String p2 , BlockException exception)&#123;        return &quot;-------deal_testHotKey&quot;;    &#125;</code></pre><p>编写相应热点key的QPS，超过阈值后跳转到fallback方法</p><p><img data-src="/images/pasted-416.png" alt="upload successful">  </p><h3 id="参数例外项"><a href="#参数例外项" class="headerlink" title="参数例外项"></a>参数例外项</h3><p><img data-src="/images/pasted-417.png" alt="upload successful"><br>我们期望p1参数当它是某个特殊值的时候，它的限流和平时不一样  </p><p><img data-src="/images/pasted-418.png" alt="upload successful"><br>上图配置表示针对参数0，当其值为5的时候，QPS可以容忍到200  </p><p><img data-src="/images/pasted-419.png" alt="upload successful"><br>此时重复访问后也不会跳转到<code>blockHandler</code>方法 </p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在controller中添加运行时异常  </p><pre><code>@GetMapping(&quot;/testHotKey&quot;)    @SentinelResource(value = &quot;testHotKey&quot; , blockHandler = &quot;deal_testHotKey&quot;)    public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1 ,                             @RequestParam(value = &quot;p2&quot; , required = false)  String p2)&#123;        int i = 10 / 0;        return &quot;-------testHotKey&quot;;    &#125;</code></pre><p>发现并不会跳转到<code>blockHandler</code>方法，因为<code>@SentinelResource</code>只负责<code>Sentinel配置平台</code>的配置错误，不会管理运行时异常。</p><h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性<br><a href="https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a>  </p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的模式：  </p><p>Load 自适应（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores X 2.5。<br>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。<br>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。<br>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。<br>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。  </p><h2 id="SentinelResource配置"><a href="#SentinelResource配置" class="headerlink" title="SentinelResource配置"></a>SentinelResource配置</h2><p>pom 引入自定义pom  </p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;com.ykx.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        </code></pre><p><img data-src="/images/pasted-421.png" alt="upload successful">  </p><p>Controller  </p><pre><code>@RestControllerpublic class RateLimitController &#123;    @GetMapping(&quot;/byResource&quot;)    @SentinelResource(value = &quot;byResource&quot; , blockHandler = &quot;handleException&quot;)    public CommonResult byResource()&#123;        return new CommonResult(200 , &quot;按资源名称限流测试0&quot;,new Payment(2020L ,&quot;serial001&quot;));    &#125;    public CommonResult handleException(BlockException exception)&#123;        return new CommonResult(444 , exception.getClass().getCanonicalName() + &quot;\t服务不可用&quot;);    &#125;&#125;</code></pre><p>结果表明，超过流控配置后 ， 要是有blockHandler的配置，那么就是用配置的。<br>如果没有配置就是用系统默认的，其中，通过资源名和SentinelResource的value都可以配置。  </p><h3 id="解决兜底方案的问题（膨胀、耦合）"><a href="#解决兜底方案的问题（膨胀、耦合）" class="headerlink" title="解决兜底方案的问题（膨胀、耦合）"></a>解决兜底方案的问题（膨胀、耦合）</h3><p>编写自定义限流方法  </p><pre><code>public class CustomerBlockHandler &#123;    public static CommonResult handlerException(BlockException exception)&#123;        return new CommonResult(444 , exception.getClass().getCanonicalName() + &quot;\t1号服务不可用&quot;);    &#125;    public static CommonResult handlerException2(BlockException exception)&#123;        return new CommonResult(445 , exception.getClass().getCanonicalName() + &quot;\t2号服务不可用&quot;);    &#125;&#125;</code></pre><p>配置@SentinelResource的限流规则  </p><pre><code>@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)    @SentinelResource(value = &quot;rateLimit/customerBlockHandler&quot;,            blockHandlerClass = CustomerBlockHandler.class,            blockHandler = &quot;handlerException2&quot;)    public CommonResult byUrl()&#123;        return new CommonResult(200 , &quot;按资源名称限流测试0&quot;,new Payment(2020L ,&quot;serial001&quot;));    &#125;    </code></pre><p>这里按照SentinelResource配置添加流控规则</p><p><img data-src="/images/pasted-422.png" alt="upload successful">    </p><p>成功调用2号流控方法<br><img data-src="/images/pasted-423.png" alt="upload successful">  </p><p>@SentinelResource 注解<br>注意：注解方式埋点不支持 private 方法。</p><p>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：</p><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81#sentinelresource-%E6%B3%A8%E8%A7%A3">https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81#sentinelresource-%E6%B3%A8%E8%A7%A3</a>  </p><h2 id="服务熔断功能"><a href="#服务熔断功能" class="headerlink" title="服务熔断功能"></a>服务熔断功能</h2><p>@fallback作为java异常的降级方法<br>@blockhandler未做sentinel配置异常的降级方法<br>两个都配置的情况下，使用blockHandler配置的方法<br>@exceptionToIgnore   </p><p><img data-src="/images/pasted-424.png" alt="upload successful"><br>忽略异常  </p><p>见官网，so easy  </p><h2 id="Sentinel服务持久化"><a href="#Sentinel服务持久化" class="headerlink" title="Sentinel服务持久化"></a>Sentinel服务持久化</h2><blockquote><p>每次重启微服务后，所有的规则都会消失，如何进行配置规则的持久化？   </p></blockquote><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。    </p><p>pom  </p><pre><code>&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>xml</p><pre><code>spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        #配置sentinel dashboard的地址        dashboard: localhost:8080        port: 8719      datasource:        ds1:          nacos:            server-addr: localhost:8848            dataId: cloudalibaba-sentinel-service            groupId: DEFAULT_GROUP            data-type: json            rule-type: flow            </code></pre><p> 在nacos中编写流控规则</p><p><img data-src="/images/pasted-426.png" alt="upload successful"><br>resource：资源名称；<br>limitApp：来源应用；<br>grade：阈值类型，0表示线程数, 1表示QPS；<br>count：单机阈值；<br>strategy：流控模式，0表示直接，1表示关联，2表示链路；<br>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；<br>clusterMode：是否集群。</p><h1 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h1><p>分布式前  </p><ul><li>单机单库没这个问题</li><li>从1:1 -&gt; 1:N -&gt; N:N<br>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证， 但是<code>全局的数据一致性</code>问题没法保证。</li></ul><p><img data-src="/images/pasted-427.png" alt="upload successful">  </p><blockquote><p>一句话：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。  </p></blockquote><p>**Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。  **</p><p><a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a>  </p><p>分布式事务处理过程的一ID+三组件模型：  </p><ul><li>Transaction ID XID 全局唯一的事务ID<br>三组件概念  </li><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。  </li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。   </li><li>RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img data-src="/images/pasted-428.png" alt="upload successful">  </p><h2 id="Seata安装"><a href="#Seata安装" class="headerlink" title="Seata安装"></a>Seata安装</h2><p><a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a>  </p><p>先备份原始file.conf文件  </p><p>主要修改:自定义事务组名称+事务日志存储模式为db +数据库连接信息  </p><p>file.conf<br>-Service模块  </p><p><img data-src="/images/pasted-429.png" alt="upload successful"><br>-store模块  </p><p><img data-src="/images/pasted-430.png" alt="upload successful">  </p><p><img data-src="/images/pasted-431.png" alt="upload successful">  </p><p>运行db_store.sql  </p><p><img data-src="/images/pasted-432.png" alt="upload successful">  </p><p><img data-src="/images/pasted-433.png" alt="upload successful"><br>修改registry.conf 修改出厂默认的注册方式为<code>nacos</code>  </p><p><img data-src="/images/pasted-434.png" alt="upload successful"><br>在java8环境下运行seataserver.sh  </p><p><img data-src="/images/pasted-437.png" alt="upload successful">  </p><h2 id="Seata业务数据库准备"><a href="#Seata业务数据库准备" class="headerlink" title="Seata业务数据库准备"></a>Seata业务数据库准备</h2><p><img data-src="/images/pasted-438.png" alt="upload successful">    </p><p>sql</p><pre><code>CREATE DATABASE seata_order;CREATE DATABASE seata_storage;CREATE DATABASE seata_account;</code></pre><p>每个数据库下创建对应的表</p><p>按照上述3库分别建对应的回滚日志表  \seata-server-0.9.0\seata\conf目录下的db_ undo_ log.sql  </p><h2 id="seata-order-service2001"><a href="#seata-order-service2001" class="headerlink" title="seata-order-service2001"></a>seata-order-service2001</h2><p>pom  </p><pre><code>&lt;dependencies&gt;        &lt;!--nacos--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--seata--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;                    &lt;groupId&gt;io.seata&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;            &lt;version&gt;0.9.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--feign--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--web-actuator--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mysql-druid--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.37&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>application.yml  </p><pre><code>server:  port: 2001spring:  application:    name: seata-order-service  cloud:    alibaba:      seata:        #自定义事务组名称需要与seata-server中file.conf中配置的事务组ID对应        #vgroup_mapping.my_test_tx_group = &quot;my_group&quot;        tx-service-group: my_group    nacos:      discovery:        server-addr: localhost:8848  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/seata_order?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC    username: root    password: 10086feign:  hystrix:    enabled: falselogging:  level:    io:      seata: infomybatis:  mapperLocations: classpath:mapper/*.xml  </code></pre><p>file.conf   </p><p>程序中依赖的是 seata-all，对应于 *.conf 文件，所以需要在resource新建.conf文件，高版本的支持yml、properties配置。这里仅仅是seata-order-service2001模块的file.conf（配置2001的分布式事务），seata软件那里配置的是总控file.conf。  </p><p><img data-src="/images/pasted-439.png" alt="upload successful">  </p><p>几个配置文件对应关系  </p><p><img data-src="/images/pasted-440.png" alt="upload successful"><br>registry.conf  </p><p><img data-src="/images/pasted-441.png" alt="upload successful">    </p><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domain 就是entity（pojo，bean），对应数据库的表，不同公司习惯不一样。<br>新建Order类与CommonResult类  </p><pre><code>package com.atguigu.cloudalibaba.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.math.BigDecimal;@Data@AllArgsConstructor@NoArgsConstructorpublic class Order &#123;    private Long id;    private Long userId;    private Long productId;    private Integer count;    private BigDecimal money;    /**     * 订单状态：0：创建中；1：已完结     */    private Integer status;&#125;</code></pre><h3 id="Dao接口及实现-SQL映射文件"><a href="#Dao接口及实现-SQL映射文件" class="headerlink" title="Dao接口及实现(SQL映射文件)"></a>Dao接口及实现(SQL映射文件)</h3><p> dao中至少要有两个方法，一个是创建订单，一个是修改订单状态  </p><pre><code> package com.atguigu.cloudalibaba.dao;import com.atguigu.cloudalibaba.domain.Order;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;@Mapperpublic interface OrderDao &#123;    /**     * 创建订单     */    void create(Order order);    /**     * 修改订单状态，从0改为1     */    void update(@Param(&quot;userId&quot;) Long userId, @Param(&quot;status&quot;) Integer status);&#125;</code></pre><p>OrderMapper.xml  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.atguigu.cloudalibaba.dao.OrderDao&quot;&gt;    &lt;!--定义一个结果集和实体类的映射表--&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.cloudalibaba.domain.Order&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;BIGINT&quot;/&gt;        &lt;result column=&quot;product_id&quot; property=&quot;productId&quot; jdbcType=&quot;BIGINT&quot;/&gt;        &lt;result column=&quot;count&quot; property=&quot;count&quot; jdbcType=&quot;INTEGER&quot;/&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot; jdbcType=&quot;DECIMAL&quot;/&gt;        &lt;result column=&quot;status&quot; property=&quot;status&quot; jdbcType=&quot;INTEGER&quot;/&gt;    &lt;/resultMap&gt;    &lt;insert id=&quot;create&quot;&gt;        INSERT INTO `t_order` (`id`, `user_id`, `product_id`, `count`, `money`, `status`)        VALUES (NULL, #&#123;userId&#125;, #&#123;productId&#125;, #&#123;count&#125;, #&#123;money&#125;, 0);    &lt;/insert&gt;    &lt;update id=&quot;update&quot;&gt;        UPDATE `t_order`        SET status = 1        WHERE user_id = #&#123;userId&#125; AND status = #&#123;status&#125;;    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>AccountService  </p><pre><code>package com.atguigu.cloudalibaba.service;import com.atguigu.cloudalibaba.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import java.math.BigDecimal;//通过OpenFeign远程调用账号微服务@FeignClient(value = &quot;seata-account-service&quot;)public interface AccountService &#123;    //扣减账户余额，需要传入用户ID跟扣除的金额    //@RequestMapping(value = &quot;/account/decrease&quot;, method = RequestMethod.POST, produces = &quot;application/json; charset=UTF-8&quot;)    @PostMapping(&quot;/account/decrease&quot;)    CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);&#125;</code></pre><p>StorageService  </p><pre><code>package com.atguigu.cloudalibaba.service;import com.atguigu.cloudalibaba.domain.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;//通过OpenFeign远程调用库存的微服务@FeignClient(value = &quot;seata-storage-service&quot;)public interface StorageService &#123;    //扣减库存，比如买了5个1号商品：对1号商品库存减5    @PostMapping(value = &quot;/storage/decrease&quot;)    CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);&#125;</code></pre><p>OrderService  </p><pre><code>package com.atguigu.cloudalibaba.service;import com.atguigu.cloudalibaba.domain.Order;public interface OrderService &#123;    // 创建订单    void create(Order order);&#125;</code></pre><p>OrderServiceIMpl  </p><pre><code>package com.atguigu.cloudalibaba.service.Impl;import com.atguigu.cloudalibaba.dao.OrderDao;import com.atguigu.cloudalibaba.domain.Order;import com.atguigu.cloudalibaba.service.AccountService;import com.atguigu.cloudalibaba.service.OrderService;import com.atguigu.cloudalibaba.service.StorageService;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service@Slf4jpublic class OrderServiceImpl implements OrderService &#123;    @Resource    private OrderDao orderDao;    @Resource    private StorageService storageService;    @Resource    private AccountService accountService;    /**     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态     * 简单说：     * 下订单-&gt;减库存-&gt;减余额-&gt;改状态     */    @Override    public void create(Order order) &#123;        log.info(&quot;-------&gt;下单开始&quot;);        //本应用创建订单        orderDao.create(order);        //远程调用库存服务扣减库存        log.info(&quot;-------&gt;订单微服务调用库存微服务，扣减库存开始&quot;);        storageService.decrease(order.getProductId(),order.getCount());        log.info(&quot;-------&gt;订单微服务调用库存微服务，扣减库存结束&quot;);        //远程调用账户服务扣减余额        log.info(&quot;-------&gt;订单微服务调用账户微服务，扣减余额开始&quot;);        accountService.decrease(order.getUserId(),order.getMoney());        log.info(&quot;-------&gt;订单微服务调用账户微服务，减余额结束&quot;);        //修改订单状态为已完成        log.info(&quot;-------&gt;order-service中修改订单状态开始&quot;);        // 这里的话是不是应该是orderId？        orderDao.update(order.getUserId(),0);        log.info(&quot;-------&gt;order-service中修改订单状态结束&quot;);        log.info(&quot;-------&gt;下单结束&quot;);    &#125;&#125;</code></pre><p> controller  </p><pre><code>import com.atguigu.cloudalibaba.domain.CommonResult;import com.atguigu.cloudalibaba.domain.Order;import com.atguigu.cloudalibaba.service.OrderService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class OrderController &#123;    @Autowired    private OrderService orderService;    //创建订单    @GetMapping(value = &quot;/order/create&quot;)    public CommonResult create(Order order) &#123;        orderService.create(order);        return new CommonResult(200, &quot;订单创建成功!&quot;);    &#125;&#125;</code></pre><p> DataSourceProxyConfig  </p><p> DataSouce的包是sql下的，DataSourceProxy是seata下的，不要搞错了。  </p><p><img data-src="/images/pasted-442.png" alt="upload successful">  </p><pre><code>package com.atguigu.cloudalibaba.config;import com.alibaba.druid.pool.DruidDataSource;import io.seata.rm.datasource.DataSourceProxy;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.transaction.SpringManagedTransactionFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;//使用Seata对数据源进行代理@Configurationpublic class DataSourceProxyConfig &#123;    @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)    private String mapperLocations;    @Bean    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    public DataSource druidDataSource()&#123;        return new DruidDataSource();    &#125;    @Bean//    @Primary    //DataSourceProxy方法上标注@Primary就可以了，这样就自动用的代理的DataSource(DS的子类)，    // 而不是Druid的, 否则就需要自己构造sqlSessionFactory    public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123;        return new DataSourceProxy(dataSource);    &#125;    @Bean    public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123;        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());        return sqlSessionFactoryBean.getObject();    &#125;&#125;</code></pre><h2 id="GlobalTransactional"><a href="#GlobalTransactional" class="headerlink" title="@GlobalTransactional"></a>@GlobalTransactional</h2><p><img data-src="/images/pasted-443.png" alt="upload successful">   </p><h3 id="测试超时异常：不加-GlobalTransactional"><a href="#测试超时异常：不加-GlobalTransactional" class="headerlink" title="测试超时异常：不加@GlobalTransactional"></a>测试超时异常：不加@GlobalTransactional</h3><p><img data-src="/images/pasted-444.png" alt="upload successful"><br>数据库情况  </p><p><img data-src="/images/pasted-445.png" alt="upload successful">  </p><p>当库存和账户金额扣减后，订单状态并没有设置为已经完成，没有从零改为1；而且由于feign的重试机制，账户余额还有可能被多次扣减。  </p><h3 id="测试超时异常：加-GlobalTransactional"><a href="#测试超时异常：加-GlobalTransactional" class="headerlink" title="测试超时异常：加@GlobalTransactional"></a>测试超时异常：加@GlobalTransactional</h3><p>OrderServiceImpl添加@GlobalTransactional注解，注意改注解只能用在方法上！  </p><pre><code>package com.atguigu.cloudalibaba.service.Impl;import com.atguigu.cloudalibaba.dao.OrderDao;import com.atguigu.cloudalibaba.domain.Order;import com.atguigu.cloudalibaba.service.AccountService;import com.atguigu.cloudalibaba.service.OrderService;import com.atguigu.cloudalibaba.service.StorageService;import io.seata.spring.annotation.GlobalTransactional;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service@Slf4jpublic class OrderServiceImpl implements OrderService &#123;    @Resource    private OrderDao orderDao;    @Resource    private StorageService storageService;    @Resource    private AccountService accountService;    /**     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态     * 简单说：     * 下订单-&gt;减库存-&gt;减余额-&gt;改状态     */    @Override    //全局事务，发生异常进行回滚    @GlobalTransactional(name = &quot;lsp-create-order&quot;, rollbackFor = Exception.class)    public void create(Order order) &#123;        log.info(&quot;-------&gt;下单开始&quot;);        //本应用创建订单        orderDao.create(order);        //远程调用库存服务扣减库存        log.info(&quot;-------&gt;订单微服务调用库存微服务，扣减库存开始&quot;);        storageService.decrease(order.getProductId(),order.getCount());        log.info(&quot;-------&gt;订单微服务调用库存微服务，扣减库存结束&quot;);        //远程调用账户服务扣减余额        log.info(&quot;-------&gt;订单微服务调用账户微服务，扣减余额开始&quot;);        accountService.decrease(order.getUserId(),order.getMoney());        log.info(&quot;-------&gt;订单微服务调用账户微服务，减余额结束&quot;);        //修改订单状态为已完成        log.info(&quot;-------&gt;order-service中修改订单状态开始&quot;);        // 这里的话是不是应该是orderId？        orderDao.update(order.getUserId(),0);        log.info(&quot;-------&gt;order-service中修改订单状态结束&quot;);        log.info(&quot;-------&gt;下单结束&quot;);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-446.png" alt="upload successful"><br>● name：给定全局事务实例的名称，随便取，唯一即可<br>● rollbackFor：当发生什么样的异常时，进行回滚<br>● noRollbackFor：发生什么样的异常不进行回滚。    </p><h2 id="Seata之原理简介"><a href="#Seata之原理简介" class="headerlink" title="Seata之原理简介"></a>Seata之原理简介</h2><p><img data-src="/images/pasted-447.png" alt="upload successful">  </p><ul><li>TC：seata服务器； （我们电脑上启动的seata ）</li><li>TM：事物的发起者，业务的入口。 哪个微服务使用了@GlobalTransactional哪个就是TM</li><li>RM：事务的参与者，一个数据库就是一个RM。</li></ul><p>分布式事务的执行流程：</p><ol><li>TM 开启分布式事务（TM 向 TC 注册全局事务记录）；  </li><li>按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）；  </li><li>TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交&#x2F;回滚分布式事务）；  </li><li>TC 汇总事务信息，决定分布式事务是提交还是回滚；  </li><li>TC 通知所有 RM 提交&#x2F;回滚 资源，事务二阶段结束。</li></ol><h3 id="AT模式（默认）如何做到对业务的无侵入"><a href="#AT模式（默认）如何做到对业务的无侵入" class="headerlink" title="AT模式（默认）如何做到对业务的无侵入"></a>AT模式（默认）如何做到对业务的无侵入</h3><p>Seata有四大模式：AT（默认）、TCC、SAGA、XA。（阿里云上的AT叫做GTS，收费）<br>AT模式<br>AT模式两阶段提交协议的演变：<br>● 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。<br>● 二阶段：<br>  ○ 提交异步化，非常快速地完成。<br>  ○ 回滚通过一阶段的回滚日志进行反向补偿（前面insert，后面回滚时就delete）。  </p><p>每个数据库除了自身存储数据的表以外，都会有一个事务回滚表：undo_log<br>Seata库中存在：branch_table\global_table\lock_table\distributed_lock(高版本才有)这样一些表</p><h3 id="一阶段加载"><a href="#一阶段加载" class="headerlink" title="一阶段加载"></a>一阶段加载</h3><p>在一阶段，Seata 会拦截“业务 SQL”，<br>1  解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”（前置镜像）<br>2  执行“业务 SQL”更新业务数据，在业务数据更新之后，<br>3  其保存成“after image”，最后生成行锁。<br>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。  </p><p><img data-src="/images/pasted-448.png" alt="upload successful">  </p><h3 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h3><p>因为“业务 SQL”在一阶段已经提交至数据库，二阶段如果顺利提交的话，那么Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。  </p><p><img data-src="/images/pasted-449.png" alt="upload successful">  </p><h3 id="二阶段回滚"><a href="#二阶段回滚" class="headerlink" title="二阶段回滚"></a>二阶段回滚</h3><p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。<br>回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”。如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。  </p><p><img data-src="/images/pasted-450.png" alt="upload successful">  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务分布式架构-Gateway服务网关、Config分布式配置中心、Bus消息总线、stream消息驱动</title>
    <link href="https://ykxzyp0517.cn/2022/11/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    <id>https://ykxzyp0517.cn/2022/11/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</id>
    <published>2022-11-07T05:14:03.000Z</published>
    <updated>2022-11-16T05:06:14.922Z</updated>
    
    <content type="html"><![CDATA[<p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。<span id="more"></span><br>SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。</p><p>SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty.<br>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如:安全，监控&#x2F;指标，和限流。</p><h1 id="微服务架构中网关的位置"><a href="#微服务架构中网关的位置" class="headerlink" title="微服务架构中网关的位置"></a>微服务架构中网关的位置</h1><p><img data-src="/images/pasted-267.png" alt="upload successful">  </p><h1 id="GateWay非阻塞异步模型"><a href="#GateWay非阻塞异步模型" class="headerlink" title="GateWay非阻塞异步模型"></a>GateWay非阻塞异步模型</h1><blockquote><p>有Zuull了怎么又出来Gateway？我们为什么选择Gateway?</p></blockquote><ul><li><p>netflix不太靠谱，zuul2.0一直跳票，迟迟不发布。</p><ul><li>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。</li><li>Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的Zuul 2.x，但Spring Cloud貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何?</li></ul></li></ul><p>多方面综合考虑Gateway是很理想的网关选择。</p><blockquote><p>SpringCloud Gateway具有如下特性  </p></blockquote><ul><li>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</li><li>动态路由：能够匹配任何请求属性；</li><li>可以对路由指定Predicate (断言)和Filter(过滤器)；</li><li>集成Hystrix的断路器功能；</li><li>集成Spring Cloud 服务发现功能；</li><li>易于编写的Predicate (断言)和Filter (过滤器)；</li><li>请求限流功能；</li><li>支持路径重写。</li></ul><h2 id="Zuul1-x模型"><a href="#Zuul1-x模型" class="headerlink" title="Zuul1.x模型"></a>Zuul1.x模型</h2><p>Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Serviet IO处理模型。</p><p>Servlet的生命周期？servlet由servlet container进行生命周期管理。</p><p>container启动时构造servlet对象并调用servlet init()进行初始化；<br>container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service)；<br>container关闭时调用servlet destory()销毁servlet。</p><p><img data-src="/images/pasted-268.png" alt="upload successful">  </p><blockquote><p>上述模式的缺点：</p></blockquote><p>Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发(如抽风用Jmeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。</p><p>所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)并由该servlet阻塞式处理处理。所以SpringCloud Zuul无法摆脱servlet模型的弊端。</p><h2 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h2><h3 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h3><ul><li>Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；</li><li>Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；</li><li>Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被<code>路由</code>前或者之后对请求进行修改。</li></ul><p><img data-src="/images/pasted-269.png" alt="upload successful"><br>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。</p><p>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”）执行业务逻辑。</p><p>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p><p>核心逻辑：路由转发 + 执行过滤器链。</p><h2 id="搭建Gateway"><a href="#搭建Gateway" class="headerlink" title="搭建Gateway"></a>搭建Gateway</h2><p>pom</p><pre><code>&lt;dependencies&gt;        &lt;!--gateway--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--eureka-client--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.ykx.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--一般基础配置类--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p> yml</p><pre><code> server:  port: 9257spring:  application:    name: cloud-gatewayeureka:  instance:    hostname: cloud-gateway-service  client:    register-with-eureka: true    fetch-registry: true    defaultZone: http://eureka7001.com:7001/erueka</code></pre><h3 id="gateway在配置文件yml配置"><a href="#gateway在配置文件yml配置" class="headerlink" title="gateway在配置文件yml配置"></a>gateway在配置文件yml配置</h3><pre><code>spring:  application:    name: cloud-gateway  #############################新增网关配置###########################  cloud:    gateway:      routes:        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名          uri: http://localhost:8001          #匹配后提供服务的路由地址          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址          predicates:            - Path=/payment/get/**         # 断言，路径相匹配的进行路由        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名          uri: http://localhost:8001          #匹配后提供服务的路由地址          #uri: lb://cloud-payment-service #匹配后提供服务的路由地址          predicates:            - Path=/payment/cs/**         # 断言，路径相匹配的进行路由####################################################################</code></pre><p><img data-src="/images/pasted-270.png" alt="upload successful">  </p><h3 id="代码中注入RouteLocator的Bean"><a href="#代码中注入RouteLocator的Bean" class="headerlink" title="代码中注入RouteLocator的Bean"></a>代码中注入RouteLocator的Bean</h3><p>需求：通过9527访问外网的国内新闻</p><pre><code>@Configurationpublic class GateWayConfig&#123;    @Bean    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)    &#123;        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();        routes.route(&quot;path_route_atguigu&quot;,                r -&gt; r.path(&quot;/guonei&quot;)                        .uri(&quot;http://news.baidu.com/guonei&quot;)).build();        return routes.build();    &#125;&#125;</code></pre><h2 id="GateWay配置动态路由"><a href="#GateWay配置动态路由" class="headerlink" title="GateWay配置动态路由"></a>GateWay配置动态路由</h2><p>配置yml<br>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。</p><p>lb:&#x2F;&#x2F;serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri。</p><pre><code>spring:  application:    name: cloud-gateway  #############################新增网关配置###########################  cloud:    gateway:      discovery:        locator:          enabled: true # 开启注册中心动态创建路由的功能，利用微服务名进行路由      routes:        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001          #匹配后提供服务的路由地址          uri: lb://cloud-payment-service #动态路由匹配后提供服务的路由地址          predicates:            - Path=/payment/get/**         # 断言，路径相匹配的进行路由        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001          #匹配后提供服务的路由地址          uri: lb://cloud-payment-service #动态路由匹配后提供服务的路由地址          predicates:            - Path=/payment/cs         # 断言，路径相匹配的进行路由####################################################################</code></pre><h2 id="Route-Predicate-断言"><a href="#Route-Predicate-断言" class="headerlink" title="Route Predicate 断言"></a>Route Predicate 断言</h2><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。</p><p>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合。</p><p>Spring Cloud Gateway创建Route 对象时，使用RoutePredicateFactory 创建 Predicate对象，Predicate 对象可以赋值给Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。<br>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。</p><blockquote><p>常用的Route Predicate Factory</p></blockquote><ul><li><p>The After Route Predicate Factory</p></li><li><p>The Before Route Predicate Factory</p></li><li><p>The Between Route Predicate Factory</p></li><li><p>The Cookie Route Predicate Factory</p></li><li><p>The Header Route Predicate Factory</p></li><li><p>The Host Route Predicate Factory</p></li><li><p>The Method Route Predicate Factory</p></li><li><p>The Path Route Predicate Factory</p></li><li><p>The Query Route Predicate Factory</p></li><li><p>The RemoteAddr Route Predicate Factory</p></li><li><p>The weight Route Predicate Factory</p><p>  spring:<br>cloud:<br>  gateway:<br>    routes:<br>    - id: after_route<br>      uri: <a href="https://example.org/">https://example.org</a><br>      predicates:<br>      # 这个时间后才能起效<br>      - After&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]</p></li></ul><p>配置cookie访问</p><pre><code>spring:  cloud:    gateway:      routes:      - id: cookie_route        uri: lb://cloud-service-proveder        predicates:        - Path=/payment/get/**        - Cookie=username,zzyy</code></pre><p><img data-src="/images/pasted-271.png" alt="upload successful">  </p><h2 id="GateWay的Filter"><a href="#GateWay的Filter" class="headerlink" title="GateWay的Filter"></a>GateWay的Filter</h2><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。  </p><p>Spring Cloud Gateway的Filter:</p><ul><li><p>生命周期：</p></li><li><p>pre</p></li><li><p>post</p></li><li><p>种类（具体看官方文档）：</p></li><li><p>GatewayFilter - 有31种</p></li><li><p>GlobalFilter - 有10种</p></li></ul><p>自定义过滤器。只要实现<code>GlobalFilter</code>,<code>Ordered</code>两个接口</p><pre><code>import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.Date;@Component@Slf4jpublic class MyLogGateWayFilter implements GlobalFilter,Ordered&#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)    &#123;        log.info(&quot;***********come in MyLogGateWayFilter:  &quot;+new Date());        String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);        if(uname == null)        &#123;            log.info(&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;);            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);            return exchange.getResponse().setComplete();        &#125;        return chain.filter(exchange);    &#125;    @Override    public int getOrder()    &#123;        return 0;    &#125;&#125;</code></pre><h1 id="Config配置中心"><a href="#Config配置中心" class="headerlink" title="Config配置中心"></a>Config配置中心</h1><p>分布式系统面临的配置问题</p><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p><p>SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……</p><p><img data-src="/images/pasted-281.png" alt="upload successful"><br>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。  </p><blockquote><p>怎么玩</p></blockquote><ul><li><p>SpringCloud Config分为服务端和客户端两部分。</p></li><li><p>服务端也称为分布式配置中心，它是一个独立的<code>微服务应用</code>，用来连接配置服务器并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口。</p></li><li><p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</p></li></ul><blockquote><p>能干嘛</p></blockquote><ul><li>集中管理配置文件</li><li>不同环境不同配置，动态化的配置更新，分环境部署比如dev&#x2F;test&#x2F;prod&#x2F;beta&#x2F;release</li><li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li><li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li><li>将配置信息以REST接口的形式暴露 - post&#x2F;crul访问刷新即可…</li></ul><h2 id="configServer配置"><a href="#configServer配置" class="headerlink" title="configServer配置"></a>configServer配置</h2><p>首先在github上创建三个测试用的yml文件</p><p><img data-src="/images/pasted-273.png" alt="upload successful"><br>pom</p><pre><code>&lt;dependencies&gt;        &lt;!--添加消息总线RabbitMQ支持--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>yml </p><pre><code>server:  port:    3344spring:  application:    name: cloud-config-center  cloud:    config:      server:        git:          uri: https://github.com/KaiXuan-Y/springcloud-config.git          search-paths:            - springcloud-config #          搜索目录      label: maineureka:  client:    service-url:       defaultZone: http://localhost:7001/eureka</code></pre><p>主配置类</p><pre><code>@SpringBootApplication@EnableConfigServerpublic class MainAppConfigCenter3344 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainAppConfigCenter3344.class , args);    &#125;&#125;</code></pre><p>能够成功获取配置内容<br><img data-src="/images/pasted-274.png" alt="upload successful"></p><h3 id="配置读取规则"><a href="#配置读取规则" class="headerlink" title="配置读取规则"></a>配置读取规则</h3><p>配置读取规则  </p><blockquote><p>&#x2F;{label}&#x2F;{application}-{profile}.yml（推荐）  </p></blockquote><p><img data-src="/images/pasted-275.png" alt="upload successful">  </p><h2 id="configClient配置"><a href="#configClient配置" class="headerlink" title="configClient配置"></a>configClient配置</h2><p>新建cloud-config-client-3355</p><p>POM</p><pre><code>&lt;dependencies&gt;        &lt;!--添加消息总线RabbitMQ支持--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><blockquote><p>bootstrap.yml</p></blockquote><p>applicaiton.yml是用户级的资源配置项</p><p>bootstrap.yml是系统级的，优先级更加高</p><p>Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的<code>父上下文</code>。</p><p>初始化的时候，BootstrapContext负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。</p><p>Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。</p><p>要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。</p><pre><code>server:  port: 3355spring:  application:    name: config-client  cloud:    config:      label: main      name: config      profile: dev      uri: http://localhost:3344  # http://localhost:3344/main/config-test.ymleureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka</code></pre><p>controller</p><pre><code>@RestControllerpublic class ConfigClientController &#123;    @Value(&quot;$&#123;config.info&#125;&quot;)    private String configInfo;    @GetMapping(&quot;/configInfo&quot;)    public String getConfigInfo()&#123;        return configInfo;    &#125;&#125;</code></pre><p>测试</p><p><img data-src="/images/pasted-276.png" alt="upload successful">  </p><h2 id="Config动态刷新"><a href="#Config动态刷新" class="headerlink" title="Config动态刷新"></a>Config动态刷新</h2><p>我们修改github上的版本号后发现，3344配置中心是能够获取到最新的版本的。但是3355客户端立刻响应无法获得最新的版本号。</p><p><img data-src="/images/pasted-277.png" alt="upload successful">  </p><p><img data-src="/images/pasted-278.png" alt="upload successful"><br>为了避免每次修改配置都需要重启客户端3355，从3344也就是github拉去最新的配置 进行如下配置  </p><ul><li><p>pom引入actuator,提供监控</p><pre><code>  &lt;dependency&gt;              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;              &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;          &lt;/dependency&gt;</code></pre></li><li><p>暴露监控端点</p><p>  management:<br>endpoints:<br>  web:<br>    exposure:<br>      include: “*”      </p></li><li><p>@RefreshScope业务类Controller修改</p><p>  @RestController<br>  @RefreshScope<br>  public class ConfigClientController {<br>  @Value(“${config.info}”)<br>  private String configInfo;<br><br>  @GetMapping(“&#x2F;configInfo”)<br>  public String getConfigInfo(){<br>      return configInfo;<br><br>  }<br>  }</p></li><li><p>此时3355还不能直接获取到最新的配置，需要运维人员发送POST请求激活3355</p></li></ul><p><img data-src="/images/pasted-279.png" alt="upload successful"><br>激活后就能成功获取最新的配置</p><p><img data-src="/images/pasted-280.png" alt="upload successful"></p><h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h1><p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。Spring Clud Bus目前支持RabbitMQ和Kafka。</p><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。<br><img data-src="/images/pasted-324.png" alt="upload successful"><br>什么是总线  </p><p>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。  </p><p>基本原理  </p><p>ConfigClient实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p><h2 id="Bus动态刷新全局广播的设计思想和选型"><a href="#Bus动态刷新全局广播的设计思想和选型" class="headerlink" title="Bus动态刷新全局广播的设计思想和选型"></a>Bus动态刷新全局广播的设计思想和选型</h2><p>必须先具备良好的RabbitMQ环境先</p><p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366  </p><p>pom</p><pre><code>&lt;dependencies&gt;        &lt;!--添加消息总线RabbitMQ支持--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>yml  </p><pre><code>server:  port: 3366spring:  application:    name: config-client  cloud:    #Config客户端配置    config:      label: master #分支名称      name: config #配置文件名称      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml      uri: http://localhost:3344 #配置中心地址  #rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口  rabbitmq:    host: 192.168.200.160    port: 5672    username: admin    password: 123#服务注册到eureka地址eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka# 暴露监控端点management:  endpoints:    web:      exposure:        include: &quot;*&quot;</code></pre><p>住启动类</p><pre><code>    @SpringBootApplication@EnableEurekaClientpublic class ConfigClient3366 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigClient3366.class , args);    &#125;&#125;</code></pre><p>controller</p><pre><code> */@RestController@RefreshScopepublic class ConfigClientController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @Value(&quot;$&#123;config.info&#125;&quot;)    private String configInfo;    @GetMapping(&quot;/configInfo&quot;)    public String configInfo()    &#123;        return &quot;serverPort: &quot;+serverPort+&quot;\t\n\n configInfo: &quot;+configInfo;    &#125;&#125;</code></pre><h3 id="两种设计思想"><a href="#两种设计思想" class="headerlink" title="两种设计思想"></a>两种设计思想</h3><p><img data-src="/images/pasted-325.png" alt="upload successful"><br>利用消息总线触发一个客户端&#x2F;bus&#x2F;refresh,而刷新所有客户端的配置  </p><p><img data-src="/images/pasted-326.png" alt="upload successful"><br>利用消息总线触发一个服务端ConfigServer的&#x2F;bus&#x2F;refresh端点，而刷新所有客户端的配置  </p><blockquote><p>图二的架构显然更加适合，图—不适合的原因如下：</p></blockquote><ul><li><p>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</p></li><li><p>破坏了微服务各节点的对等性。</p></li><li><p>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</p></li></ul><h3 id="给3344-3355-3366添加消息总线的支持"><a href="#给3344-3355-3366添加消息总线的支持" class="headerlink" title="给3344,3355,3366添加消息总线的支持"></a>给3344,3355,3366添加消息总线的支持</h3><p>三个都是相同的，赋予rabbitmq的支持<br>pom</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>yml </p><pre><code>  rabbitmq:    host: 192.168.200.160    port: 5672    username: admin    password: 123</code></pre><p>其中需要注意的，因为采用技术的选型是通过server进行广播通知，所以3344的yml需要额外的配置，暴露’bus-refresh’  </p><pre><code>management:  endpoints: #暴露bus刷新配置的端点    web:      exposure:        include: &#39;bus-refresh&#39;</code></pre><p>此时3344得到版本号为5</p><p><img data-src="/images/pasted-327.png" alt="upload successful">  </p><p>3355,3366得到的版本号是5</p><p><img data-src="/images/pasted-328.png" alt="upload successful">  </p><p>此时，发送curl请求给3344进行全局广播  </p><p><img data-src="/images/pasted-329.png" alt="upload successful"><br>此时，3344，3355,3366不需要重启都可以生效配置中心更新  </p><p><img data-src="/images/pasted-330.png" alt="upload successful"><br>我们去rabbitmq的服务管理可以看到，生成了一个名为springCloudBus的topic交换机  </p><p><img data-src="/images/pasted-331.png" alt="upload successful">  </p><h2 id="Bus动态刷新定点通知"><a href="#Bus动态刷新定点通知" class="headerlink" title="Bus动态刷新定点通知"></a>Bus动态刷新定点通知</h2><p>简单一句话 - 指定具体某一个实例生效而不是全部  </p><p>公式：<a href="http://localhost:3344/actuator/bus-refresh/%7Bdestination%7D">http://localhost:3344/actuator/bus-refresh/{destination}</a></p><p>&#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例</p><p><img data-src="/images/pasted-332.png" alt="upload successful">  </p><p><img data-src="/images/pasted-333.png" alt="upload successful"><br>此时3355是7  </p><p><img data-src="/images/pasted-334.png" alt="upload successful"><br>3366是6，没有更新</p><h1 id="Stream消息驱动"><a href="#Stream消息驱动" class="headerlink" title="Stream消息驱动"></a>Stream消息驱动</h1><blockquote><p>什么是Spring Cloud Stream？</p></blockquote><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。</p><p>应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。</p><p>通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p><blockquote><p>为什么使用Stream?  </p></blockquote><p><img data-src="/images/pasted-335.png" alt="upload successful"><br>比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区。<br>这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候Spring Cloud Stream给我们提供了—种解耦合的方式。</p><blockquote><p>Stream凭什么可以统一底层差异？</p></blockquote><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。  </p><p><strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。</strong>  </p><p><img data-src="/images/pasted-336.png" alt="upload successful">  </p><h2 id="Stream编码常用注解简介"><a href="#Stream编码常用注解简介" class="headerlink" title="Stream编码常用注解简介"></a>Stream编码常用注解简介</h2><p><img data-src="/images/pasted-337.png" alt="upload successful">  </p><p><img data-src="/images/pasted-338.png" alt="upload successful">  </p><ul><li><p>Binder - 很方便的连接中间件，屏蔽差异。</p></li><li><p>Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。</p></li><li><p>Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</p></li></ul><blockquote><p>编码API和常用注解  </p></blockquote><p><img data-src="/images/pasted-339.png" alt="upload successful">  </p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>pom</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--基础配置--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    </code></pre><p> yml</p><pre><code>     server:  port: 8801spring:  application:    name: cloud-stream-provider  cloud:      stream:        binders: # 在此处配置要绑定的rabbitmq的服务信息；          defaultRabbit: # 表示定义的名称，用于于binding整合            type: rabbit # 消息组件类型            environment: # 设置rabbitmq的相关的环境配置              spring:                rabbitmq:                  host: localhost                  port: 5672                  username: guest                  password: guest        bindings: # 服务的整合处理          output: # 这个名字是一个通道的名称            destination: studyExchange # 表示要使用的Exchange名称定义            content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”            binder: defaultRabbit # 设置要绑定的消息服务的具体设置eureka:  client: # 客户端进行Eureka注册的配置    service-url:      defaultZone: http://localhost:7001/eureka  instance:    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）    instance-id: send-8801.com  # 在信息列表时显示主机名称    prefer-ip-address: true     # 访问的路径变为IP地址</code></pre><p>service</p><pre><code>@EnableBinding(Source.class)  //定义消息生产者的发送管道public class IMessageProviderImpl implements IMessageProvider &#123;    @Resource    private MessageChannel output;    @Override    public String send() &#123;        String serial = UUID.randomUUID().toString();        output.send(MessageBuilder.withPayload(serial).build());        System.out.println(&quot;*****serial:&quot; + serial);        return serial;    &#125;&#125;</code></pre><p>controller</p><pre><code>@RestControllerpublic class SendMessageController &#123;    @Resource    private IMessageProvider messageProvider;    @GetMapping(&quot;/sendMessage&quot;)    public String sendMessage()&#123;        return messageProvider.send();    &#125;&#125;</code></pre><p>此时RabbitMQ中生成交换机<br><img data-src="/images/pasted-340.png" alt="upload successful">  </p><p><img data-src="/images/pasted-341.png" alt="upload successful">  </p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><pre><code>ymlserver:  port: 8001spring:  application:    name: cloud-stream-provider  rabbitmq:    port: 5672    host: 192.168.200.160    username: admin    password: 123  cloud:    stream:      binders:        defaultRabbit:          type: rabbit      bindings:        - output:          destination: studyExchange          content-type: application/json          binder: defaultRabbiteureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka  instance:    lease-renewal-interval-in-seconds: 2    lease-expiration-duration-in-seconds: 5    instance-id: send-8001.com    prefer-ip-address: true    </code></pre><p>controller</p><pre><code>@Component@EnableBinding(Sink.class)public class ReceiveMessageStreamController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @StreamListener(Sink.INPUT)    public void input(Message&lt;String&gt; message)&#123;        System.out.println(&quot;消费者1号，---&gt;接受到消息：&quot;+message.getPayload()+&quot;\t port:&quot;+serverPort);    &#125;&#125;</code></pre><h2 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h2><p>RabbitMQ</p><ul><li>服务注册 - 8801</li><li>消息生产 - 8801</li><li>消息消费 - 8802</li><li>消息消费 - 8802</li></ul><p><strong>消费</strong></p><ul><li><a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></li><li>目前是8802&#x2F;8803同时都收到了，存在重复消费问题</li><li>如何解决：分组和持久化属性group（重要）</li></ul><p><strong>生产实际案例</strong></p><p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决。  </p><p><img data-src="/images/pasted-342.png" alt="upload successful">  </p><p>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的(重复消费)。  </p><blockquote><p>默认分组group是不同的，组流水号是不一样的，被认为不同组，可以重复消费   </p></blockquote><p><strong>原理</strong><br>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。不同的组是可以重复消费的，同一个组内会发生竞争关系，只有其中一个可以消费。</p><h3 id="8802-x2F-8803都变成不同组，group两个不同"><a href="#8802-x2F-8803都变成不同组，group两个不同" class="headerlink" title="8802&#x2F;8803都变成不同组，group两个不同"></a>8802&#x2F;8803都变成不同组，group两个不同</h3><p>group: A_Group、B_Group</p><p><img data-src="/images/pasted-343.png" alt="upload successful">  </p><h2 id="Stream之消息持久化"><a href="#Stream之消息持久化" class="headerlink" title="Stream之消息持久化"></a>Stream之消息持久化</h2><p>通过上述，解决了重复消费问题，再看看持久化。</p><p>停止8802&#x2F;8803并去除掉8802的分组group: A_Group，8803的分组group: A_Group没有去掉。</p><p>8801先发送4条消息到RabbitMq。</p><p>先启动8802，无分组属性配置，后台没有打出来消息。</p><h1 id="Sleuth之zipkin搭建安装"><a href="#Sleuth之zipkin搭建安装" class="headerlink" title="Sleuth之zipkin搭建安装"></a>Sleuth之zipkin搭建安装</h1><p>新版本下载地址：<a href="https://repo1.maven.org/maven2/io/zipkin/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/zipkin-server/</a></p><pre><code>运行jar包 java -jar zipkin-server-2.12.9-exec.jar</code></pre><p> 运行控制台</p><p><a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p><p>完整的调用链路</p><p>表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来  </p><p><img data-src="/images/pasted-344.png" alt="upload successful"><br>—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。  </p><p><img data-src="/images/pasted-345.png" alt="upload successful"><br>整个链路的依赖关系如下：  </p><p><img data-src="/images/pasted-346.png" alt="upload successful">  </p><h1 id="Sleuth链路监控展现"><a href="#Sleuth链路监控展现" class="headerlink" title="Sleuth链路监控展现"></a>Sleuth链路监控展现</h1><pre><code>&lt;!--包含了sleuth+zipkin--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>YML  </p><pre><code>spring:  application:    name: cloud-payment-service  zipkin: #&lt;-------------------------------------关键       base-url: http://localhost:9411  sleuth: #&lt;-------------------------------------关键    sampler:    #采样率值介于 0 到 1 之间，1 则表示全部采集    probability: 1  datasource:    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包    url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false    username: root    password: 123456</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务分布式架构-服务降级熔断限流</title>
    <link href="https://ykxzyp0517.cn/2022/11/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>https://ykxzyp0517.cn/2022/11/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/</id>
    <published>2022-11-03T06:52:04.000Z</published>
    <updated>2022-11-07T05:03:19.670Z</updated>
    
    <content type="html"><![CDATA[<p>学习服务降级之前首先要考虑的是分布式系统面临的问题，复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。因此需要考虑服务降级<span id="more"></span>  </p><h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystrix是一个用于处理分布式系统的<code>延迟和容错</code>的开源库，在分布式系统里，许多依赖不可避免的会<code>调用失败</code>，比如超时、异常等，Hystrix能够保证在一个<code>依赖出问题</code>的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。<br>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>服务降级</li><li>服务熔断</li><li>接近实时的监控<br><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></li></ul><h2 id="Hystrix的服务降级熔断限流概念"><a href="#Hystrix的服务降级熔断限流概念" class="headerlink" title="Hystrix的服务降级熔断限流概念"></a>Hystrix的服务降级熔断限流概念</h2><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback</p><blockquote><p>哪些情况会出发降级</p></blockquote><ul><li>程序运行导常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池&#x2F;信号量打满也会导致服务降级</li></ul><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</p><blockquote><p>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</p></blockquote><h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><blockquote><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。</p></blockquote><h2 id="业务模拟（服务降级）"><a href="#业务模拟（服务降级）" class="headerlink" title="业务模拟（服务降级）"></a>业务模拟（服务降级）</h2><pre><code>@RestController@Slf4jpublic class PaymentController &#123;    @Resource    private PaymentService paymentService;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;)Integer id)&#123;        String res = paymentService.paymentInfo_Ok(id);        log.info(&quot;******result: &quot; + res);        return res;    &#125;    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id)&#123;        String res = paymentService.paymentInfo_TimeOut(id);        log.info(&quot;******result: &quot; + res);        return res;    &#125;&#125;</code></pre><p>其中，<code>paymentInfo_TimeOut</code>业务模拟一个需要长时间处理的复杂业务。  </p><h3 id="高并发模拟"><a href="#高并发模拟" class="headerlink" title="高并发模拟"></a>高并发模拟</h3><p>开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p><p>1.测试计划中右键添加-》线程-》线程组（线程组202102，线程数：200，线程数：100，其他参数默认）</p><p>2.刚刚新建线程组202102，右键它-》添加-》取样器-》Http请求-》基本 输入<a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></p><p>3.点击绿色三角形图标启动。</p><p>看演示结果：拖慢，原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</p><p>Jmeter压测结论</p><p>上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。</p><p><img data-src="/images/pasted-258.png" alt="upload successful"><br>此时发现产生连坐效应， <code>paymentInfo_OK</code>这个不该等待的业务都被压慢了。因为<code>paymentInfo_TimeOut</code>和<code>paymentInfo_OK</code>为一个微服务资源。导致资源过多的倾斜给<code>paymentInfo_TimeOut</code>，造成<code>paymentInfo_Ok</code>没有多余的线程来处理。<br>如果此时80消费者来访问，消费者只能<code>干等</code>,最终被压死  </p><blockquote><p>消费者80类编写</p></blockquote><pre><code>@Service@FeignClient(value = &quot;http://CLOUD-HYXTRIX-PAYMENT-SERVICE&quot;)public interface PaymentHystrixService &#123;    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;)Integer id);    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id);&#125;</code></pre><p>Controller类</p><pre><code>@RestController@Slf4jpublic class PaymentHystrixController &#123;    @Resource    private PaymentHystrixService paymentHystrixService;    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;)Integer id)&#123;        return paymentHystrixService.paymentInfo_Ok(id);    &#125;    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id)&#123;        return paymentHystrixService.paymentInfo_TimeOut(id);    &#125;&#125;</code></pre><p>此时压8001后，消费者80访问ok都会很慢<br>原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。正因为有上述故障或不佳表现才有我们的降级&#x2F;容错&#x2F;限流等技术诞生  </p><h3 id="降级容错解决的维度要求"><a href="#降级容错解决的维度要求" class="headerlink" title="降级容错解决的维度要求"></a>降级容错解决的维度要求</h3><p>超时导致服务器变慢(转圈) - 超时不再等待</p><p>出错(宕机或程序运行出错) - 出错要有兜底</p><p>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。<br>对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。<br>对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。</p><h3 id="Hystrix之服务降级支付侧fallback"><a href="#Hystrix之服务降级支付侧fallback" class="headerlink" title="Hystrix之服务降级支付侧fallback"></a>Hystrix之服务降级支付侧fallback</h3><p>降级配置 - @HystrixCommand<br>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。<br>—旦调用服务方法失败并抛出了错误信息，或者超时后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法  </p><pre><code>//服务降级    @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)    &#125;)    public String paymentInfo_TimeOut(Integer id)&#123;//        try &#123;//            TimeUnit.SECONDS.sleep(5);//        &#125; catch (InterruptedException e) &#123;//            e.printStackTrace();//        &#125;        int age = 10/0;        return &quot;线程池：&quot;+Thread.currentThread().getName() + &quot;paymentInfo_Timeout,id:&quot;+id +  &quot;  耗时5秒钟&quot;;    &#125;    public String paymentInfo_TimeOutHandler(Integer id)&#123;        return &quot;线程池：&quot;+Thread.currentThread().getName() + &quot;系统繁忙或者运行报错，请稍后再试,id:&quot;+id + &quot;：--0.0&quot;;    &#125;</code></pre><p>主系统类激活  </p><pre><code>@SpringBootApplication@EnableEurekaClient@EnableCircuitBreakerpublic class PaymentHystrixMain8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentHystrixMain8001.class , args);    &#125;&#125;</code></pre><h3 id="Hystrix之服务降级订单侧fallback"><a href="#Hystrix之服务降级订单侧fallback" class="headerlink" title="Hystrix之服务降级订单侧fallback"></a>Hystrix之服务降级订单侧fallback</h3><p>80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护</p><p>题外话，切记 - 我们自己配置过的热部署方式对java代码的改动明显</p><p>但对@HystrixCommand内属性的修改建议重启微服务  </p><p>yml  </p><pre><code>feign:  hystrix:    enabled: true</code></pre><p>主启动类  </p><pre><code>@SpringBootApplication@EnableFeignClients@EnableHystrixpublic class OrderHystrixMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderHystrixMain80.class , args);    &#125;&#125;</code></pre><p>业务类</p><pre><code>@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)    &#125;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id)&#123;        return paymentHystrixService.paymentInfo_TimeOut(id);    &#125;    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;)Integer id)&#123;        return &quot;我是消费者80，对方服务器繁忙&quot;;    &#125;</code></pre><h3 id="Hystrix之全局服务降级DefaultProperties"><a href="#Hystrix之全局服务降级DefaultProperties" class="headerlink" title="Hystrix之全局服务降级DefaultProperties"></a>Hystrix之全局服务降级DefaultProperties</h3><p>将通用的和独享的服务降级方法分开,避免代码膨胀的问题    </p><pre><code>@RestController@Slf4j@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)public class PaymentHystrixController &#123;    @Resource    private PaymentHystrixService paymentHystrixService;    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;)Integer id)&#123;        return paymentHystrixService.paymentInfo_Ok(id);    &#125;    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)//    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;//            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)//    &#125;)    @HystrixCommand    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id)&#123;        return paymentHystrixService.paymentInfo_TimeOut(id);    &#125;    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;)Integer id)&#123;        return &quot;我是消费者80，对方服务器繁忙&quot;;    &#125;    public String payment_Global_FallbackMethod()&#123;        return &quot;Global异常处理信息，请稍后重试&quot;;    &#125;&#125;</code></pre><ul><li>首先在Controller上添加<code>@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</code>添加全局的降级方法  </li><li>编写全局的fallback方法  </li><li>在默认使用的方法上添加<code>@HystrixCommand</code>注解，如果添加了<code>fallbackMethod</code>属性，那么就用指定的</li></ul><h3 id="Hystrix之通配服务降级FeignFallback"><a href="#Hystrix之通配服务降级FeignFallback" class="headerlink" title="Hystrix之通配服务降级FeignFallback"></a>Hystrix之通配服务降级FeignFallback</h3><p>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</p><p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的<code>实现类</code>即可实现解耦  </p><p>PaymentFallbackService类实现PaymentHystrixService接口 </p><pre><code>@Componentpublic class PaymentFallbackService implements PaymentHystrixService&#123;    @Override    public String paymentInfo_Ok(Integer id) &#123;        return &quot;-----PaymentFallbackService fall back_info_Ok&quot;;    &#125;    @Override    public String paymentInfo_TimeOut(Integer id) &#123;        return &quot;-----PaymentFallbackService fall back_info_Timeout&quot;;    &#125;&#125;</code></pre><p>YML  </p><pre><code>...feign:  hystrix:    enabled: true  </code></pre><p>PaymentHystrixService接口</p><pre><code>@Service@FeignClient(value = &quot;http://CLOUD-HYXTRIX-PAYMENT-SERVICE&quot;,fallback = PaymentFallbackService.class)public interface PaymentHystrixService &#123;    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_Ok(@PathVariable(&quot;id&quot;)Integer id);    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;)Integer id);&#125;</code></pre><p>单个eureka先启动7001</p><p>PaymentHystrixMain8001启动</p><p>正常访问测试 - <a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></p><p>故意关闭微服务8001</p><p>客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在<code>服务端不可用</code>时也会获得提示信息而不会挂起耗死服务器。</p><h2 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h2><h3 id="Hystrix之服务熔断理论"><a href="#Hystrix之服务熔断理论" class="headerlink" title="Hystrix之服务熔断理论"></a>Hystrix之服务熔断理论</h3><p>断路器，相当于保险丝。</p><h3 id="熔断机制概述"><a href="#熔断机制概述" class="headerlink" title="熔断机制概述"></a>熔断机制概述</h3><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p><p><img data-src="/images/pasted-259.png" alt="upload successful">  </p><h3 id="熔断机制实例"><a href="#熔断机制实例" class="headerlink" title="熔断机制实例"></a>熔断机制实例</h3><pre><code>//服务熔断    @HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;            @HystrixProperty(name=&quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),//是否开启断路器            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),//请求次数            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),//时间窗口期            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;) //失败率达到多少后跳闸    &#125;)    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;)Integer id)&#123;        if (id &lt; 0)&#123;            throw new RuntimeException(&quot;***id不能为负数&quot;);        &#125;        String serialNUmber = IdUtil.simpleUUID();        return Thread.currentThread().getName() + &quot;\t&quot; + &quot;调用成功&quot;+serialNUmber;    &#125;    public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;)Integer id)&#123;        return &quot;id 不能为负数,请稍后再试&quot;;    &#125;        </code></pre><p>The precise way that the circuit opening and closing occurs is as follows:</p><p>Assuming the volume across a circuit meets a certain threshold : <code>HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()</code><br>And assuming that the error percentage, as defined above exceeds the error percentage defined in :<br><code>HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()</code><br>Then the circuit-breaker transitions from CLOSED to OPEN.  </p><p>While it is open, it short-circuits all requests made against that circuit-breaker.  </p><p>After some amount of time (<code>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</code>), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.</p><p>具体配置类的属性可以看<code>HystrixCommandProperties</code>这个类的属性  </p><p>Controller类</p><pre><code>//服务熔断    @GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id)&#123;        String res = paymentService.paymentCircuitBreaker(id);        log.info(&quot;*****result&quot;+res);        return res;    &#125;</code></pre><p><img data-src="/images/pasted-260.png" alt="upload successful"><br>首先模拟10s内多次错误，触发断路器，引起服务熔断 </p><p><img data-src="/images/pasted-261.png" alt="upload successful"><br>断路器触发后，所有的服务一律服务降级处理  </p><p><img data-src="/images/pasted-262.png" alt="upload successful"><br>过段时间后就会恢复服务，类似于断路器从半开的状态。  </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>熔断类型有三种  </p><ul><li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。</li><li>熔断关闭：熔断关闭不会对服务进行熔断。</li><li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。</li></ul><p>涉及到断路器的三个重要参数：</p><ul><li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li><li>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。</li><li>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li></ul><p>到达以下阀值，断路器将会开启：</p><ul><li>当满足一定的阀值的时候（默认10秒内超过20个请求次数)</li><li>当失败率达到一定的时候（默认10秒内超过50%的请求失败)</li><li>当开启的时候，所有请求都不会进行转发</li></ul><p>一段时间之后（默认是5秒)，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。</p><p>断路器打开之后</p><ul><li><p>1：再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p></li><li><p>2：原来的主逻辑要如何恢复呢？</p></li></ul><p>对于这一问题，hystrix也为我们实现了自动恢复功能。</p><p>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><h1 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix-Dashboard"></a>Hystrix-Dashboard</h1><p>pom依赖  </p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>所有Provider微服务提供类(8001&#x2F;8002&#x2F;8003)都需要监控依赖配置</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>localhost:9001&#x2F;hystrix</p><p><img data-src="/images/pasted-263.png" alt="upload successful">  </p><p>修改cloud-provider-hystrix-payment8001</p><p>注意：新版本Hystrix需要在主启动类PaymentHystrixMain8001中指定监控路径</p><pre><code>@SpringBootApplication@EnableEurekaClient@EnableCircuitBreakerpublic class PaymentHystrixMain8001&#123;    public static void main(String[] args) &#123;            SpringApplication.run(PaymentHystrixMain8001.class, args);    &#125;    /**     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;，     *只要在自己的项目里配置上下面的servlet就可以了     *否则，Unable to connect to Command Metric Stream 404     */    @Bean    public ServletRegistrationBean getServlet() &#123;        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(1);        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);        return registrationBean;    &#125;&#125;</code></pre><p>监控localhost8001&#x2F;payment&#x2F;circuit&#x2F;1</p><p><img data-src="/images/pasted-264.png" alt="upload successful"><br>此时断路器为绿色的，一直没有打开  </p><p>多次访问localhost8001&#x2F;payment&#x2F;circuit&#x2F;-1</p><p><img data-src="/images/pasted-265.png" alt="upload successful"><br>断路器开启</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习服务降级之前首先要考虑的是分布式系统面临的问题，复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。因此需要考虑服务降级</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CAS+自旋锁的理解</title>
    <link href="https://ykxzyp0517.cn/2022/11/02/CAS-%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://ykxzyp0517.cn/2022/11/02/CAS-%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2022-11-02T06:46:25.000Z</published>
    <updated>2022-11-02T13:33:54.712Z</updated>
    
    <content type="html"><![CDATA[<p>CAS+自旋锁在什么地方用到呢？比方说会在Eureka的Ribbon负载均衡算法中采用，如果采用轮询的负载均衡方法，那么获取下一个服务器ServerIndex的方法就是通过CAS和自旋锁的方式实现的。同时对AtomicInteger为什么使用CAS而不采用synchronized来解决多线程环境下的安全问题进行彻底的了解<span id="more"></span></p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h2><p>比较和交换，是一条CPU的并发原语<br>CAS并发原语体现在JAVA语言中的Unsafe类中的各个方法。调用CAS方法后，JVM会帮我们实现出CAS汇编指令。它实现了原子操作。原语的执行必须是连续的，在执行过程中不允许被中断。因此不会造成所谓的数据不一致性  </p><pre><code>public void addPlusPlus()&#123;        number ++;    &#125; AtomicInteger atomicInteger = new AtomicInteger();  public void addMyAtomic()&#123;      atomicInteger.getAndIncrement(); &#125;</code></pre><p>上面的方式显然在多线程的情况下，number++的方式会丢失值,但是使用<code>synchronized</code>又太过厚重。如何解决这个问题？那个就可以采用<code>getAndIncrement()</code>方法,那么你对CAS就需要有很深刻的了解，你需要彻底了解为什么用CAS而不用<code>synchronized</code>    </p><p>下面是CAS的源代码，parameter1代表希望的值，parameter2表示修改的目标值</p><pre><code>    /**     * Atomically sets the value to the given updated value     * if the current value &#123;@code ==&#125; the expected value.     *     * @param expect the expected value     * @param update the new value     * @return &#123;@code true&#125; if successful. False return indicates that     * the actual value was not equal to the expected value.     */    public final boolean compareAndSet(int expect, int update) &#123;        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    &#125;</code></pre><p>我又编写了一个测试类加深理解  </p><pre><code>public class CASDemo &#123;    public static void main(String[] args) &#123;        AtomicInteger atomicInteger = new AtomicInteger(5);        System.out.println(atomicInteger.compareAndSet(5, 2019)  + &quot;current data: &quot;+atomicInteger);        /**         * 假设此时又有一个进程进入想要进行修改         */        System.out.println(atomicInteger.compareAndSet(5,1024) + &quot;current data: &quot;+atomicInteger);    &#125;&#125;  </code></pre><p><img data-src="/images/pasted-245.png" alt="upload successful">    </p><blockquote><p>如果得到的系统的实际值和期望值相同，将内容进行修改。如果和期望值不同，就不进行修改。    </p></blockquote><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><pre><code>/**     * Atomically increments by one the current value.     *     * @return the previous value     */    public final int getAndIncrement() &#123;        return unsafe.getAndAddInt(this, valueOffset, 1);    &#125;</code></pre><blockquote><p>this和valueOffset的含义是什么？  </p></blockquote><ul><li><p>this代表当前对象</p></li><li><p>valueOffset：内存偏移量  </p><p>  public final int getAndAddInt(Object var1, long var2, int var4) {<br>      int var5;<br>      do {<br>          var5 &#x3D; this.getIntVolatile(var1, var2);<br>      } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br>      return var5;<br>  }</p></li></ul><p>观察这个方法的来源，发现他竟然是unsafe类的方法，那么我们继续下推  </p><pre><code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);  </code></pre><p>我们看到这个方法用native修饰<br>private static final long serialVersionUID &#x3D; 6214790243416807050L;</p><pre><code>    // setup to use Unsafe.compareAndSwapInt for updates    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static &#123;        try &#123;            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;    &#125;    private volatile int value;  </code></pre><p>可以看到value用volatile修饰，每次的修改每个线程都可见  </p><p><img data-src="/images/pasted-246.png" alt="upload successful"><br>同时我们可以看到<code>AtomicInterger</code>使用了unsafe类。这是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地<code>native</code>方法访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。其内部的操作可以像C的指针一样直接操作内存。<br>变量valueOffest表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的  </p><ul><li><p>（1）<br><img data-src="/images/pasted-247.png" alt="upload successful">  </p></li><li><p>（2）<br><img data-src="/images/pasted-248.png" alt="upload successful">  </p></li><li><p>（3）首先获取Offset地址的值赋值给var5,随后判断当前对象这个地址的值是不是5，如果比较成功返回true，取反后跳出循环，return var5;如果真实值和期望着不一致，比较失败重新获取var5的值。</p></li></ul><p><img data-src="/images/pasted-249.png" alt="upload successful">  </p><p><img data-src="/images/pasted-250.png" alt="upload successful"><br>为何CAS能够保持原语操作的原子性？</p><p><img data-src="/images/pasted-251.png" alt="upload successful">  </p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><ul><li>1.循环时间长，开销大：底层使用do{}while()如果一直比较失败，会一直自旋。如过CAS一直不成功，CPU开销很大  </li><li>2.只能保证一个共享变量的原子操作  </li><li>3.会引出ABA问题</li></ul><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><p>CAS算法实现了一个重要前提需要取出内存中<code>某时刻</code>的数据并在<code>当下时刻</code>进行比较并且替换，那么在这个时间差类会导致数据的变换。<br>比如说一个线程one从内存位置V中取出A,这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成B，然后线程two又将V位置的数据变成A，这时线程one进行CAS操作时发现内存中仍然是A，然后线程one操作成功。<br><strong>但是这个时间差内的过程会产生很多的问题</strong>  </p><h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><pre><code>public class CASDemo &#123;    public static void main(String[] args) &#123;        AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;();        User z3 = new User(&quot;z3&quot;, 22);        User li4 = new User(&quot;li4&quot;, 25);        atomicReference.set(z3);        System.out.println(atomicReference.compareAndSet(z3, li4) + &quot;\t&quot; + atomicReference.get().userName);        System.out.println(atomicReference.compareAndSet(z3, li4) + &quot;\t&quot; + atomicReference.get().userName);    &#125;&#125;@Data@AllArgsConstructor@NoArgsConstructorclass User&#123;    String userName;    int age;&#125;  </code></pre><h2 id="时间戳的原子引用AtomicStampedReference"><a href="#时间戳的原子引用AtomicStampedReference" class="headerlink" title="时间戳的原子引用AtomicStampedReference"></a>时间戳的原子引用AtomicStampedReference</h2><p>解决ABA问题：新增一种机制，那就是修改版本号（类似于时间戳 ）    </p><pre><code>public class CASDemo &#123;    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;\t第1次版本号&quot; + stamp);            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicStampedReference.compareAndSet(100 , 101 , atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;\t第2次版本号&quot; + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(101 , 100 , atomicStampedReference.getStamp() , atomicStampedReference.getStamp() + 1);            System.out.println(Thread.currentThread().getName() + &quot;\t第3次版本号&quot; + atomicStampedReference.getStamp());        &#125;,&quot;t1&quot;).start();        new Thread(() -&gt; &#123;            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + &quot;\t第一次版本号&quot; + stamp);            try &#123;                TimeUnit.SECONDS.sleep(3);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            boolean result = atomicStampedReference.compareAndSet(100, 2022, stamp, stamp + 1);            System.out.println(&quot;是否修改成 &quot; + result + &quot;\t 当前版本号&quot; + atomicStampedReference.getStamp());        &#125;,&quot;t2&quot;).start();    &#125;&#125;</code></pre><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>是指尝试获取锁的线程不会立即<code>阻塞</code>，而是采用循环的方式去尝试获取锁，这样的好处是减少线程的上下文切换的消耗，缺点是循环会消耗CPU<br><img data-src="/images/pasted-249.png" alt="upload successful"><br>上图是CAS的代码，如果while中每次比较都失败取反后一直未true，while一直无法跳出来。  </p><pre><code>public class SpinLockDemo &#123;    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public static void main(String[] args) &#123;        SpinLockDemo spinLockDemo = new SpinLockDemo();        new Thread(() -&gt; &#123;            spinLockDemo.myLock();            try &#123;                TimeUnit.SECONDS.sleep(5);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            spinLockDemo.myUnLock();        &#125;,&quot;AA&quot;).start();        try &#123;            TimeUnit.SECONDS.sleep(1);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        new Thread(() -&gt; &#123;            spinLockDemo.myLock();            spinLockDemo.myUnLock();        &#125;,&quot;BB&quot;).start();    &#125;    public void myLock()&#123;        Thread thread = Thread.currentThread();        System.out.println(Thread.currentThread().getName() + &quot;\t come in &quot;);        while (!atomicReference.compareAndSet(null , thread))&#123;        &#125;    &#125;    public void myUnLock()&#123;        Thread thread = Thread.currentThread();        atomicReference.compareAndSet(thread , null);        System.out.println(Thread.currentThread().getName() + &quot; \t invoked myUnlock()&quot;);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CAS+自旋锁在什么地方用到呢？比方说会在Eureka的Ribbon负载均衡算法中采用，如果采用轮询的负载均衡方法，那么获取下一个服务器ServerIndex的方法就是通过CAS和自旋锁的方式实现的。同时对AtomicInteger为什么使用CAS而不采用synchronized来解决多线程环境下的安全问题进行彻底的了解</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务分布式架构-Ribbon、OpenFeign服务调用</title>
    <link href="https://ykxzyp0517.cn/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"/>
    <id>https://ykxzyp0517.cn/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/</id>
    <published>2022-11-02T02:33:06.000Z</published>
    <updated>2022-11-03T06:44:14.097Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。</p><p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。</p><p>简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法<span id="more"></span></p><h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><h2 id="LB负载均衡-Load-Balance-是什么"><a href="#LB负载均衡-Load-Balance-是什么" class="headerlink" title="LB负载均衡(Load Balance)是什么"></a>LB负载均衡(Load Balance)是什么</h2><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。</p><p>常见的负载均衡有软件Nginx，LVS，硬件F5等。</p><h2 id="Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别"><a href="#Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别" class="headerlink" title="Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别"></a>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</h2><p>Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p><ul><li>集中式LB</li></ul><p>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx)，由该设施负责把访问请求通过某种策略转发至服务的提供方;</p><ul><li>进程内LB</li></ul><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p><p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><blockquote><p>一句话</p></blockquote><blockquote><p>负载均衡 + RestTemplate调用  </p></blockquote><h2 id="Ribbon的负载均衡和Rest调用"><a href="#Ribbon的负载均衡和Rest调用" class="headerlink" title="Ribbon的负载均衡和Rest调用"></a>Ribbon的负载均衡和Rest调用</h2><p>Ribbon其实就是一个<code>软负载均衡</code>的<code>客户端组件</code>，它可以和其他所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。  </p><p><img data-src="/images/pasted-240.png" alt="upload successful">  </p><p>Ribbon在工作时分成两步：</p><ul><li><p>第一步先选择EurekaServer ,它优先选择在同一个区域内负载较少的server。</p></li><li><p>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</p></li></ul><p>无需额外引入依赖</p><p><img data-src="/images/pasted-241.png" alt="upload successful"></p><pre><code>这是因为spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用。</code></pre><h3 id="RestTemplete使用说明"><a href="#RestTemplete使用说明" class="headerlink" title="RestTemplete使用说明"></a>RestTemplete使用说明</h3><p><strong>getForObject() &#x2F; getForEntity() - GET请求方法</strong></p><ul><li><p>getForObject()：返回对象为响应体中数据转化成的对象，基本上可以理解为Json。</p></li><li><p>getForEntity()：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。</p></li></ul><blockquote><p>getForEntity()  </p></blockquote><pre><code>@GetMapping(&quot;/consumer/payment/getForEntity/&#123;id&#125;&quot;)    public Comparable&lt;Payment&gt; getPayment2(@PathVariable(&quot;id&quot;)Long id)&#123;        ResponseEntity&lt;CommonResult&gt; entity = restTemplate.getForEntity(PAYMENT_URL + &quot;/payment/get&quot; + id, CommonResult.class);        if (entity.getStatusCode().is2xxSuccessful())&#123;            return (Comparable&lt;Payment&gt;) entity.getBody();        &#125;else &#123;            return (Comparable&lt;Payment&gt;) new CommonResult&lt;Object&gt;(444,&quot;操作失败&quot;);        &#125;    &#125;</code></pre><p><img data-src="/images/pasted-242.png" alt="upload successful"><br>测试成功  </p><h3 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h3><p>轮询规则定义在IRule接口内</p><pre><code>/** * Interface that defines a &quot;Rule&quot; for a LoadBalancer. A Rule can be thought of * as a Strategy for loadbalacing. Well known loadbalancing strategies include * Round Robin, Response Time based etc. *  * @author stonse *  */public interface IRule&#123;    /*     * choose one alive server from lb.allServers or     * lb.upServers according to key     *      * @return choosen Server object. NULL is returned if none     *  server is available      */    public Server choose(Object key);    public void setLoadBalancer(ILoadBalancer lb);    public ILoadBalancer getLoadBalancer();    &#125;</code></pre><p><img data-src="/images/pasted-243.png" alt="upload successful">  </p><ul><li>RoundRobinRule 轮询</li><li>RandomRule 随机</li><li>RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重</li><li>WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</li><li>BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li><li>AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例</li><li>ZoneAvoidanceRule 默认规则,复合判断server所在区域的性能和server的可用性选择服务器</li></ul><h3 id="Ribbon负载规则替换"><a href="#Ribbon负载规则替换" class="headerlink" title="Ribbon负载规则替换"></a>Ribbon负载规则替换</h3><p>官方文档明确给出了警告:</p><p>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，</p><p>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。   </p><p>启动类使用了<code>@SpringBootApplication</code>注解，他所在的包都会被扫描到，因此需要重新建立一个包进行设置  </p><p><img data-src="/images/pasted-244.png" alt="upload successful"><br>建立一个单独的包来编写我们的负载均衡算法  </p><pre><code>@Configurationpublic class MySelfRule &#123;    @Bean    public IRule myRule()&#123;        return new RandomRule(); // 定义为随机    &#125;&#125;</code></pre><p>在主启动类上添加<code>@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)</code>注解表明哪一个服务用哪一个ribbon的轮询算法。  </p><h3 id="Ribbon默认负载轮询算法原理"><a href="#Ribbon默认负载轮询算法原理" class="headerlink" title="Ribbon默认负载轮询算法原理"></a>Ribbon默认负载轮询算法原理</h3><p>默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 &#x3D; 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。<br><code>List&lt;Servicelnstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);</code><br>如:</p><blockquote><p>List [0] instances &#x3D; 127.0.0.1:8002<br>List [1] instances &#x3D; 127.0.0.1:8001<br>8001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理：</p></blockquote><p>当总请求数为1时:1%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001<br>当总请求数位2时:2%2&#x3D;О对应下标位置为0，则获得服务地址为127.0.0.1:8002<br>当总请求数位3时:3%2&#x3D;1对应下标位置为1，则获得服务地址为127.0.0.1:8001<br>当总请求数位4时:4%2&#x3D;О对应下标位置为0，则获得服务地址为127.0.0.1:8002<br>如此类推…  </p><h3 id="RoundRibbonRule源码分析"><a href="#RoundRibbonRule源码分析" class="headerlink" title="RoundRibbonRule源码分析"></a>RoundRibbonRule源码分析</h3><p><img data-src="/images/pasted-252.png" alt="upload successful">  </p><p><img data-src="/images/pasted-254.png" alt="upload successful">  </p><p><img data-src="/images/pasted-253.png" alt="upload successful"><br>主要采用的就是CAS+自旋锁的方式，劲量避免了使用锁的结构，<code>next</code>为下一个服务器，使用CAS获取下一个<code>next</code>返回，最后返回需要的server。  </p><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign</a><br>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。  </p><blockquote><p>Feign旨在使编写Java Http客户端变得更容易。  </p></blockquote><p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p><blockquote><p>Feign集成了Ribbon  </p></blockquote><p>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</p><blockquote><p>Feign和OpenFeign两者区别  </p></blockquote><p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是:使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。  </p><h2 id="OpenFeign服务调用"><a href="#OpenFeign服务调用" class="headerlink" title="OpenFeign服务调用"></a>OpenFeign服务调用</h2><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;  </code></pre><p>主启动类,添加<code>@EnableFeignClients</code>接口，开启OpenFeign</p><pre><code>@SpringBootApplication@EnableFeignClientspublic class OrderFeign80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderFeign80.class , args);    &#125;&#125;</code></pre><p>编写Service接口，并且使用<code>@FeignClient</code>接口确定调用的是哪一个远程服务  </p><pre><code>@Service@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123;    @GetMapping(value = &quot;payment/get/&#123;id&#125;&quot;)    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><p>调用远程服务  </p><pre><code>@RestController@Slf4jpublic class OrderFeignController &#123;    @Resource    private PaymentFeignService paymentFeignService;    @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;        return paymentFeignService.getPaymentById(id);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-255.png" alt="upload successful"><br>测试成功  </p><h2 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h2><h3 id="服务端处理超过默认时间1s"><a href="#服务端处理超过默认时间1s" class="headerlink" title="服务端处理超过默认时间1s"></a>服务端处理超过默认时间1s</h3><p>OpenFeign的等待响应时间默认为1s，超过后报错<br>在8001服务端添加暂停方法，4s的等待必定造成超时  </p><pre><code> @GetMapping(value = &quot;/payment/feign/cs&quot;)    public String tooLate()&#123;        try &#123;            TimeUnit.SECONDS.sleep(4);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return serverPort;    &#125;    </code></pre><p>在FeignCLient标注的接口进行调用  </p><pre><code>@Service@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)public interface PaymentFeignService &#123;    @GetMapping(value = &quot;payment/get/&#123;id&#125;&quot;)    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);    @GetMapping(value = &quot;/payment/feign/cs&quot;)    public String tooLate();&#125;</code></pre><p>调用该方法  </p><pre><code>@GetMapping(value = &quot;/consumer/payment/feign/cs&quot;)    public String getTooLate()&#123;        return paymentFeignService.tooLate();    &#125;</code></pre><p><img data-src="/images/pasted-256.png" alt="upload successful"><br>结果如图所示，超时了  </p><blockquote><p>设置feign客户端超时时间（OpenFeign默认支持ribbon)  </p></blockquote><pre><code>ribbon:  #指的是建立连接后从服务器读取到可用资源所需时间  ReadTimeout: 5000  #指的是建立连接所用的时间，适用于网络状况正常情况下，两端连接所用的时间  ConnectTimeOut: 5000  </code></pre><p><img data-src="/images/pasted-257.png" alt="upload successful"><br>成功访问  </p><h2 id="OpenFeign日志增强"><a href="#OpenFeign日志增强" class="headerlink" title="OpenFeign日志增强"></a>OpenFeign日志增强</h2><h3 id="日志打印功能"><a href="#日志打印功能" class="headerlink" title="日志打印功能"></a>日志打印功能</h3><p>Feign提供了日志打印功能，我们可以通过配置来调整日恙级别，从而了解Feign 中 Http请求的细节。</p><p>说白了就是对Feign接口的调用情况进行监控和输出</p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>NONE：默认的，不显示任何日志;<br>BASIC：仅记录请求方法、URL、响应状态码及执行时间;<br>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息;<br>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p><h3 id="开启日志功能"><a href="#开启日志功能" class="headerlink" title="开启日志功能"></a>开启日志功能</h3><p>配置配置类  </p><pre><code>@Configurationpublic class FeignConfig &#123;    @Bean    Logger.Level feignLoggerLevel()&#123;        return Logger.Level.FULL;    &#125;&#125;</code></pre><p>配置yml</p><pre><code>logging:  level:    # feign日志以什么级别监控那个接口    com.ykx.springcloud.service.PaymentFeignService: debug  </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。&lt;/p&gt;
&lt;p&gt;简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。&lt;/p&gt;
&lt;p&gt;简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务分布式架构-Eureka、Zookeeper、Consul服务注册中心</title>
    <link href="https://ykxzyp0517.cn/2022/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88eureka/"/>
    <id>https://ykxzyp0517.cn/2022/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88eureka/</id>
    <published>2022-10-31T05:48:51.000Z</published>
    <updated>2022-11-02T02:32:34.243Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Cloud 封装了Netflix公司开发的Eureka模块来实现服务治理。<br>在传统的rpc远程调用框架中，管理每个服务于服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。<span id="more"></span>  </p><h1 id="服务注册与发现的概念"><a href="#服务注册与发现的概念" class="headerlink" title="服务注册与发现的概念"></a>服务注册与发现的概念</h1><p>什么是服务注册与发现?  </p><p>Eureka采用了CS的设计架构，Eureka Sever作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到 Eureka Server并维持<code>心跳连接</code>。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何RPC远程框架中，都会有一个注册中心存放服务地址相关信息(接口地址)</p><p><img data-src="/images/pasted-214.png" alt="upload successful">    </p><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><h2 id="Eureka-Eureka-Server和Eureka-Client"><a href="#Eureka-Eureka-Server和Eureka-Client" class="headerlink" title="Eureka:Eureka Server和Eureka Client"></a>Eureka:Eureka Server和Eureka Client</h2><h3 id="Eureka-Server提供服务注册服务"><a href="#Eureka-Server提供服务注册服务" class="headerlink" title="Eureka Server提供服务注册服务"></a>Eureka Server提供服务注册服务</h3><p>各个微服务节点通过配置启动后，会在<code>EurekaServer</code>中进行注册，这样<code>EurekaServer</code>中的服务注册表中将会存储所有<code>可用服务节点的信息</code>，服务节点的信息可以在界面中直观看到。</p><h3 id="Eureka-Client通过注册中心进行访问"><a href="#Eureka-Client通过注册中心进行访问" class="headerlink" title="Eureka Client通过注册中心进行访问"></a>Eureka Client通过注册中心进行访问</h3><p>它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server<code>发送心跳</code>(默认周期为30秒)。如果Eureka Server在<code>多个心跳周期</code>内<code>没有接收</code>到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)</p><h1 id="Eureka单机搭建"><a href="#Eureka单机搭建" class="headerlink" title="Eureka单机搭建"></a>Eureka单机搭建</h1><h2 id="Eureka-Server搭建"><a href="#Eureka-Server搭建" class="headerlink" title="Eureka Server搭建"></a>Eureka Server搭建</h2><p>创建工程引入pom依赖    </p><pre><code>&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;  </code></pre><p>yml进行编写  </p><pre><code>    server:      port: 7001    eureka:      instance:        hostname: localhost # eureka服务器的实例名称      client:        register-with-eureka: false # false表示不向注册中心注册自己        fetch-registry: false # false表示自己就是注册中心，职责就是维护服务实例，并不需要检索服务        service-url:          defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</code></pre><p>主启动类进行编写  </p><pre><code>@SpringBootApplication@EnableEurekaServerpublic class EurekaMain7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaMain7001.class , args);    &#125;&#125;</code></pre><p>注意的是`@EnableEurekaServer`注解，代表这个java工程为EurekaServer组件。并且注册中心不需要提供服务  </p><p>访问 localhost：7001 进入注册中心页面  </p><p><img data-src="/images/pasted-215.png" alt="upload successful">  </p><h2 id="将provider服务Client端注册进Server"><a href="#将provider服务Client端注册进Server" class="headerlink" title="将provider服务Client端注册进Server"></a>将provider服务Client端注册进Server</h2><p>引入pom  </p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>需要注意的是H版本需要加入starter的这个依赖  </p><blockquote><p>修改yml，在YMl添加相应的注册中心地址  </p></blockquote><pre><code>eureka:  client:    register-with-eureka: true # 表示是否将自己注册进注册中心，默认为true    fetch-registry: true # 是都从EurekaServer抓去已有的注册信息，默认为true    service-url:      defaultZone: http://localhost:7001/eureka</code></pre><p>在主启动类上添加@EnableEurekaClient  </p><pre><code>@SpringBootApplication@EnableEurekaClientpublic class PaymentMain8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain8001.class , args);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-216.png" alt="upload successful">  </p><h2 id="将consumer服务Client端注册进Server"><a href="#将consumer服务Client端注册进Server" class="headerlink" title="将consumer服务Client端注册进Server"></a>将consumer服务Client端注册进Server</h2><p>方法同上  </p><p><img data-src="/images/pasted-217.png" alt="upload successful">  </p><h1 id="Eureka执行流程"><a href="#Eureka执行流程" class="headerlink" title="Eureka执行流程"></a>Eureka执行流程</h1><p><img data-src="/images/pasted-218.png" alt="upload successful">  </p><h2 id="问题：微服务RPC远程服务调用最核心的是什么"><a href="#问题：微服务RPC远程服务调用最核心的是什么" class="headerlink" title="问题：微服务RPC远程服务调用最核心的是什么"></a>问题：微服务RPC远程服务调用最核心的是什么</h2><p>高可用，试想你的注册中心只有一个only one，万一它出故障了，会导致整个为服务环境不可用。</p><blockquote><p>解决办法：搭建Eureka注册中心集群，实现<code>负载均衡+故障容错</code>。    </p></blockquote><p>*互相注册，相互守望。  *  </p><p><img data-src="/images/pasted-219.png" alt="upload successful">   </p><h1 id="Eureka集群搭建"><a href="#Eureka集群搭建" class="headerlink" title="Eureka集群搭建"></a>Eureka集群搭建</h1><ul><li>在linux服务器下修改域名映射，让两台eureka服务器拥有不同的服务名称</li></ul><p><img data-src="/images/pasted-220.png" alt="upload successful">  </p><ul><li>按照相互注册的原则，将每台服务器的defaultZone设置为对方的url</li></ul><blockquote><p>7001</p></blockquote><pre><code>server:  port: 7001eureka:  instance:    hostname: eureka7001.com # eureka服务器的实例名称  client:    register-with-eureka: false # false表示不向注册中心注册自己    fetch-registry: false # false表示自己就是注册中心，职责就是维护服务实例，并不需要检索服务    service-url:      defaultZone: http://eureka7002.com:7002/eureka/</code></pre><blockquote><p>7002</p></blockquote><pre><code>server:  port: 7002eureka:  instance:    hostname: eureka7002.com # eureka服务器的实例名称  client:    register-with-eureka: false # false表示不向注册中心注册自己    fetch-registry: false # false表示自己就是注册中心，职责就是维护服务实例，并不需要检索服务    service-url:      defaultZone: http://eureka7001.com:7001/eureka/</code></pre><ul><li>这样集群就能够搭建成功</li></ul><p><img data-src="/images/pasted-221.png" alt="upload successful">  </p><p><img data-src="/images/pasted-222.png" alt="upload successful">  </p><h2 id="将支付服务8001-消费80加入到集群"><a href="#将支付服务8001-消费80加入到集群" class="headerlink" title="将支付服务8001,消费80加入到集群"></a>将支付服务8001,消费80加入到集群</h2><pre><code>eureka:  client:    register-with-eureka: true # 表示是否将自己注册进注册中心，默认为true    fetch-registry: true # 是都从EurekaServer抓去已有的注册信息，默认为true    service-url:      defaultZone: http://localhost:7001/eureka,http://eureka7002.com:7002/eureka</code></pre><p><img data-src="/images/pasted-223.png" alt="upload successful">  </p><p><img data-src="/images/pasted-224.png" alt="upload successful"><br>成功注册</p><h2 id="provider集群搭建"><a href="#provider集群搭建" class="headerlink" title="provider集群搭建"></a>provider集群搭建</h2><p>只需要将每个Provider的端口号进行修改即可  </p><p><img data-src="/images/pasted-225.png" alt="upload successful"><br><code>cloud-payment-service</code>  不需要修改，默认使用轮询的方式提供服务  </p><p>但是发现问题，多次访问的时候每次使用的都是8001端口，这是因为在消费者的<em>Controller</em>中<em>PAYMENT_URL</em>写死了。消费者只关心服务，不再关心地址和端口号    </p><pre><code>public static final String PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;</code></pre><p>但是问题又来了，发现页面直接报错了。这是因为没有给consumer定义负载均衡的方式，即使发现了服务但是不知道使用哪一台服务器。</p><pre><code>@Configurationpublic class ApplicationContextConfig &#123;    @Bean    @LoadBalanced    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;</code></pre><p>需要配置<code>@LoadBalanced</code>注解  </p><h2 id="细节配置"><a href="#细节配置" class="headerlink" title="细节配置"></a>细节配置</h2><pre><code>eureka:  client:    register-with-eureka: true # 表示是否将自己注册进注册中心，默认为true    fetch-registry: true # 是都从EurekaServer抓去已有的注册信息，默认为true    service-url:      defaultZone: http://localhost:7001/eureka,http://eureka7002.com:7002/eureka  instance:    instance-id: payment8002    prefer-ip-address: true</code></pre><p>这样就可以显式主机名和主机的ip地址  </p><p><img data-src="/images/pasted-226.png" alt="upload successful">  </p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息  </p><pre><code>@Resourceprivate DiscoveryClient discoveryClient;......@GetMapping(value=&quot;/payment/discovery&quot;)    public Object discovery()&#123;        List&lt;String&gt; services = discoveryClient.getServices();        for (String element : services)&#123;            log.info(&quot;******element:&quot;+element);        &#125;        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);        for (ServiceInstance instance : instances)&#123;            log.info(instance.getServiceId() + &quot;\t&quot; + instance.getHost());        &#125;        return this.discoveryClient;    &#125;</code></pre><p>只需要暴露一个discovey接口既可以得到注册中心的所有服务信息。  </p><h2 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h2><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。  </p><h3 id="为什么会产生Eureka自我保护机制"><a href="#为什么会产生Eureka自我保护机制" class="headerlink" title="为什么会产生Eureka自我保护机制?"></a>为什么会产生Eureka自我保护机制?</h3><p>为了EurekaClient可以正常运行，防止与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除</p><h3 id="什么是自我保护模式"><a href="#什么是自我保护模式" class="headerlink" title="什么是自我保护模式?"></a>什么是自我保护模式?</h3><p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。<br>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。</p><p>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着。</p><p>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</p><h3 id="禁用自我保护模式"><a href="#禁用自我保护模式" class="headerlink" title="禁用自我保护模式"></a>禁用自我保护模式</h3><pre><code>eureka:  ...  server:    #关闭自我保护机制，保证不可用服务被及时踢除    enable-self-preservation: false    eviction-interval-timer-in-ms: 2000</code></pre><p>关闭效果：</p><p>spring-eureka主页会显示出一句：</p><p>THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK&#x2F;OTHER PROBLEMS.</p><blockquote><p>8001配置  </p></blockquote><pre><code>eureka:  ...  instance:    instance-id: payment8001    prefer-ip-address: true    #心跳检测与续约时间    #开发时没置小些，保证服务关闭后注册中心能即使剔除服务    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)    lease-renewal-interval-in-seconds: 1    #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务    lease-expiration-duration-in-seconds: 2</code></pre><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="将微服务提供者8004注册进Zookeeper"><a href="#将微服务提供者8004注册进Zookeeper" class="headerlink" title="将微服务提供者8004注册进Zookeeper"></a>将微服务提供者8004注册进Zookeeper</h2><p>Linux开启zookeeper服务流程就不再赘述。直接上springcloud!  </p><blockquote><p>引入pom</p></blockquote><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li><p>修改yml文件    </p><p>  server:<br>port: 8004<br>  spring:<br>application:<br>  name: cloud-provider-payment<br>cloud:<br>  zookeeper:<br>    connect-string: 192.168.200.160:2181</p></li></ul><blockquote><p>其中<code>connect-string</code>为zookeeper服务器的ip地址    </p></blockquote><ul><li><p>编写启动类    </p><p>  @SpringBootApplication<br>  @EnableDiscoveryClient<br>  public class PaymentMain8004 {<br>  public static void main(String[] args) {<br>      SpringApplication.run(PaymentMain8004.class , args);<br>  }<br>  }</p></li><li><p>编写provider提供的服务-业务类  </p><p>  @RestController<br>  @Slf4j<br>  public class PaymentController {<br>  @Value(“${server.port}”)<br>  private String serverPort;<br><br>  @RequestMapping(value &#x3D; “&#x2F;payment&#x2F;zk”)<br>  public String paymentZk(){<br>      return “springcloud with zookeeper” + serverPort + “\t” + UUID.randomUUID().toString();<br>  }<br>  }</p></li></ul><p>以上就完成了服务注册的大体步骤，无非就是编写业务类的时候在yml中标记zookeeper提供者的服务地址罢了。<br>那么进入linux检查是否成功注册服务。  </p><p><img data-src="/images/pasted-227.png" alt="upload successful"><br>服务成功注册。  </p><p>其中每个微服务做为一个节点放入在zookeeper中。    </p><h2 id="与euruka节点的保护机制区别"><a href="#与euruka节点的保护机制区别" class="headerlink" title="与euruka节点的保护机制区别"></a>与euruka节点的保护机制区别</h2><p>ZooKeeper的服务节点是临时节点，没有Eureka那含情脉脉。<br>关闭8004服务器后，发现zookeeper服务器很快就将服务删除。  </p><p><img data-src="/images/pasted-228.png" alt="upload successful"><br>重新开启8004服务后，服务的流水号uuid不同，为新的服务。  </p><p><img data-src="/images/pasted-229.png" alt="upload successful">  </p><h2 id="将微服务消费者80注册进Zookeeper"><a href="#将微服务消费者80注册进Zookeeper" class="headerlink" title="将微服务消费者80注册进Zookeeper"></a>将微服务消费者80注册进Zookeeper</h2><p> 首先引入pom文件</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>修改yml文件  </p><pre><code>server:  port: 80spring:  application:    name: cloud-consumerzk-order  cloud:    zookeeper:      connect-string: 192.168.200.160:2181</code></pre><p>其中<code>connect-string</code>为zookeeper服务器的ip地址<br>编写启动类后注册<code>restTemplete</code>即可进行远程服务的调用  </p><p><img data-src="/images/pasted-230.png" alt="upload successful"><br>完成服务的注册和发现。</p><h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><p>What is Consul?<br>Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality. Each of these features can be used individually as needed, or they can be used together to build a full service mesh. Consul requires a data plane and supports both a proxy and native integration model. Consul ships with a simple built-in proxy so that everything works out of the box, but also supports 3rd party proxy integrations such as Envoy. <!--more-->  </p><p>Consul是一个服务网格解决方案，它提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。这些特性中的每一个都可以根据需要单独使用，也可以一起用于构建全服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul船与一个简单的内置代理，使一切工作的开箱即用，但也支持第三方代理集成，如Envoy。<br>提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。  </p><h2 id="Linux安装concul"><a href="#Linux安装concul" class="headerlink" title="Linux安装concul"></a>Linux安装concul</h2><p>网上很多人就是在windows本机上安装的consul进行测试，但是实际肯定是用linux啊。<br><code> wget https://releases.hashicorp.com/consul/0.7.5/consul_0.7.5_linux_amd64.zip</code><br>命令下载consul的安装包  </p><p><code> unzip consul_0.7.5_linux_amd64.zip</code>进行安装包解压  </p><p> 使用<code> ./consul</code>命令测试consul是否安装成功  </p><p><img data-src="/images/pasted-231.png" alt="upload successful"><br>这就意味着consul安装完毕啦  </p><p><code> ./consul agent -dev -ui -node=consul-dev -client=192.168.200.160</code>启动你的consul吧！ 192.168.200.160是楼主的ip地址   </p><p><img data-src="/images/pasted-232.png" alt="upload successful">  </p><h2 id="SpringCloud集成consul"><a href="#SpringCloud集成consul" class="headerlink" title="SpringCloud集成consul"></a>SpringCloud集成consul</h2><h3 id="服务提供者8006"><a href="#服务提供者8006" class="headerlink" title="服务提供者8006"></a>服务提供者8006</h3><p>引入pom文件  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改yml文件  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">consul-provider-payment</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">consul:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.200</span><span class="number">.160</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">          <span class="attr">discovery:</span></span><br><span class="line">            <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">    <span class="meta">@EnableDiscoveryClient</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8006</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            SpringApplication.run(PaymentMain8006.class , args);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>业务类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentZk</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with consul&quot;</span> + serverPort + <span class="string">&quot;\t&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试访问<code>http://localhost:8006/payment/consul</code>成功  </p><p><img data-src="/images/pasted-233.png" alt="upload successful"><br>服务成功注册进注册中心  </p><p><img data-src="/images/pasted-234.png" alt="upload successful">  </p><h3 id="服务消费者80"><a href="#服务消费者80" class="headerlink" title="服务消费者80"></a>服务消费者80</h3><p>pom文件和yml就不再赘述。  </p><pre><code>server:  port: 80spring:  application:    name: cloud-consumer-order  cloud:    consul:      host: 192.168.200.160      port: 8500      discovery:        service-name: $&#123;spring.application.name&#125;</code></pre><p>主要讲解config类的编写   </p><pre><code>@Configurationpublic class ApplicationContextConfig &#123;    @Bean    @LoadBalanced    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;  </code></pre><p>业务类  </p><pre><code class="java">@RestController@Slf4jpublic class OrderConsulController &#123;        public static final String INVOKE_URL = &quot;http://consul-provider-payment&quot;;        @Resource        private RestTemplate restTemplate;        @GetMapping(&quot;/consumer/payment/consul&quot;)        public String paymentInfo()&#123;            String res = restTemplate.getForObject(INVOKE_URL + &quot;/payment/consul&quot;, String.class);            return res;        &#125;    &#125;</code></pre><p><img data-src="/images/pasted-235.png" alt="upload successful"><br>成功注册  </p><h1 id="三者的不同"><a href="#三者的不同" class="headerlink" title="三者的不同"></a>三者的不同</h1><p><img data-src="/images/pasted-236.png" alt="upload successful"><br>CAP：</p><ul><li><p>C：Consistency (强一致性)</p></li><li><p>A：Availability (可用性)</p></li><li><p>P：Partition tolerance （分区容错性)</p></li></ul><p><img data-src="/images/pasted-237.png" alt="upload successful">  </p><h2 id="AP架构（Eureka"><a href="#AP架构（Eureka" class="headerlink" title="AP架构（Eureka)"></a>AP架构（Eureka)</h2><p>AP架构（Eureka）</p><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。</p><p>结论：违背了一致性C的要求，只满足可用性和分区容错，即AP  </p><p><img data-src="/images/pasted-238.png" alt="upload successful">  </p><h2 id="CP架构（Zookeeper、Consul）"><a href="#CP架构（Zookeeper、Consul）" class="headerlink" title="CP架构（Zookeeper、Consul）"></a>CP架构（Zookeeper、Consul）</h2><p>CP架构（ZooKeeper&#x2F;Consul）</p><p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。</p><p>结论：违背了可用性A的要求，只满足一致性和分区容错，即CP。</p><p><img data-src="/images/pasted-239.png" alt="upload successful">  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Cloud 封装了Netflix公司开发的Eureka模块来实现服务治理。&lt;br&gt;在传统的rpc远程调用框架中，管理每个服务于服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MybatisPlus重度患者重温Mybatis</title>
    <link href="https://ykxzyp0517.cn/2022/01/26/MybatisPlus%E9%87%8D%E5%BA%A6%E6%82%A3%E8%80%85%E9%87%8D%E6%B8%A9Mybatis/"/>
    <id>https://ykxzyp0517.cn/2022/01/26/MybatisPlus%E9%87%8D%E5%BA%A6%E6%82%A3%E8%80%85%E9%87%8D%E6%B8%A9Mybatis/</id>
    <published>2022-01-26T14:22:00.000Z</published>
    <updated>2022-10-28T05:56:44.450Z</updated>
    
    <content type="html"><![CDATA[<p>关于本人为什么要重新捡起Mybatis呢？一方面是为了面对复杂的sql拼接，第二是社区老哥的一句话：Mybatis-plus的特性只会让你的代码更烂。Mybatis-plus的神奇之处在于，它能让你的代码看起来整洁并且在开发阶段降低SQL报错的概率，但同时降低代码复用性和层次结构的清晰度，大幅增加代码修改维护成本。因此重度患者有必要重温mybatis！！！</p><span id="more"></span><h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul><li>打包方式：jar</li><li>引入依赖  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><ul><li>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。  </li><li>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</li><li>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environments：配置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            default ：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    MyBatis的顺序：</span></span><br><span class="line"><span class="comment">    properties?,settings?,typeAliases?,typeHandlers?,</span></span><br><span class="line"><span class="comment">    objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    引入properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.atguigu.mybatis.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        这个包下的所有实体类都默认别名为类名，不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        environment：配置某个具体的环境</span></span><br><span class="line"><span class="comment">                    属性：</span></span><br><span class="line"><span class="comment">                        id:表示连接数据库环境的唯一标识，不能重复--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            transactionManager：设置事务的管理方式</span></span><br><span class="line"><span class="comment">                                            属性  -</span></span><br><span class="line"><span class="comment">                                                type=&#x27;JDBC|MANAGED&#x27;</span></span><br><span class="line"><span class="comment">                                                JDBC: 原生的事务管理方式，事务的提交或者回滚需要手动处理</span></span><br><span class="line"><span class="comment">                                                MANAGED：被管理，例如Spring--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            dataSource：配置数据源</span></span><br><span class="line"><span class="comment">                                    属性：type 用来设置数据源的类型</span></span><br><span class="line"><span class="comment">                                            &#x27;POOLED&#x27;：表示使用数据库连接池缓存数据库连接</span></span><br><span class="line"><span class="comment">                                            &#x27;UNPOOLED&#x27;:表示不使用数据库连接池</span></span><br><span class="line"><span class="comment">                                            &#x27;JNDI&#x27;:表示使用上下文的数据源--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        以包为单位引入映射文件</span></span><br><span class="line"><span class="comment">        要求 1 mapper借口所在的包要和映射文件所在的包一直</span></span><br><span class="line"><span class="comment">            2 mapper借口要和映射文件的名字一致--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">abc123</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul></li></ul><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><ul><li>映射文件的命名规则<ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li></ul></li><li>MyBatis中可以面向接口操作数据，要保证两个一致<ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ykx.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into t_user values(1,&#x27;admin&#x27;,&#x27;123455&#x27;,23,&#x27;男&#x27;,&#x27;123123@qq.com&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>需要注意的事，此时查看数据库发现表内数据并没有更新，造成这一现象的原因是<code>mybatis-config.xml</code>文件中的<code>transactionManager=‘jdbc&#39;</code>因此需要进行手动提交失事务。</p><p><img data-src="/images/pasted-201.png" alt="upload successful"><br>手动提交事务，在执行sql语句后调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure><p>如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交  </p><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol><li>加入依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>加入log4j的配置文件<ul><li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li><li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol><li>添加 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">       delete from t_user where id = 6</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">       update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询一个实体类对象 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询集合 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>注意：<ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol></li></ul><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：${}和#{}  </li><li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li><li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img data-src="/images/pasted-202.png" alt="upload successful"><br>相当于字符串的拼接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-203.png" alt="upload successful"><br>相当于占位符</p><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中<ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</li><li>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 <ol><li>以@Param注解的value属性值为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>其中@Param注解的value属性值替换的是arg键。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>建议分成两种情况进行处理<ol><li>实体类类型的参数</li><li>使用@Param标识参数</li></ol></li></ul><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol><li>如果查询出的数据只有一条，可以通过<ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解</li></ol></li></ol><h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在MyBatis中，对于Java中常用的类型都设置了类型别名  </li><li>例如：java.lang.Integer–&gt;int|integer  </li><li>例如：int–&gt;_int|_integer  </li><li>例如：Map–&gt;map,List–&gt;list</li></ul><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li></ul><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul><li>只能使用${}，因为表名不能加单引号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>使用场景<ul><li>t_clazz(clazz_id,clazz_name)  </li><li>t_student(student_id,student_name,clazz_id)</li></ul><ol><li>添加班级信息  </li><li>获取新添加的班级的id  </li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li><li>在mapper.xml中设置两个属性<ul><li>useGeneratedKeys：设置使用自增的主键</li></ul><ul><li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li>resultMap：设置自定义映射  <ul><li>属性：  <ul><li>id：表示自定义映射的唯一标识，不能重复</li><li>type：查询的数据要映射的实体类的类型</li></ul></li><li>子标签：  <ul><li>id：设置主键的映射关系  </li><li>result：设置普通字段的映射关系  </li><li>子标签属性：  <ul><li>property：设置映射关系中实体类中的属性名  </li><li>column：设置映射关系中表中的字段名</li></ul></li></ul></li></ul></li><li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  <ol><li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote><p>查询员工信息以及员工所对应的部门信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;  </span><br><span class="line"><span class="keyword">private</span> Integer eid;  </span><br><span class="line"><span class="keyword">private</span> String empName;  </span><br><span class="line"><span class="keyword">private</span> Integer age;  </span><br><span class="line"><span class="keyword">private</span> String sex;  </span><br><span class="line"><span class="keyword">private</span> String email;  </span><br><span class="line"><span class="keyword">private</span> Dept dept;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul><li>association：处理多对一的映射关系</li><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型,知道属性的类型后就可通过反射获取类型的属性，就可以赋值。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询-延迟加载"><a href="#分步查询-延迟加载" class="headerlink" title="分步查询(延迟加载)"></a>分步查询(延迟加载)</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul><li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：设置分步查询的条件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>分布查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息；<br>lazyLoadingEnabled:延迟加载的全局开关。当开启时，所有关联的对象都会延迟加载<br>aggressiveLazyLoading（默认false）:当开启时，任何方法的调用都会加载该对象所有的属性。否则，每个属性只会按需加载  </p></blockquote><p>不打开延时加载的情况下，<code>emp.getEmail()</code>的同时也会将Dept的信息全部都查询出来，显然这是不需要的。</p><p><img data-src="/images/pasted-204.png" alt="upload successful"><br>打开延时加载后，只会查询emp的信息。  </p><p><img data-src="/images/pasted-205.png" alt="upload successful"><br>开启全局延迟加载后，可以通过<code>fetchType</code>属性，细粒度的控制延迟加载的效果  </p><p><img data-src="/images/pasted-206.png" alt="upload successful"></p><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul><li>collection：用来处理一对多的映射关系</li><li>ofType：表示该属性对饮的集合中存储的数据的类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于本人为什么要重新捡起Mybatis呢？一方面是为了面对复杂的sql拼接，第二是社区老哥的一句话：Mybatis-plus的特性只会让你的代码更烂。Mybatis-plus的神奇之处在于，它能让你的代码看起来整洁并且在开发阶段降低SQL报错的概率，但同时降低代码复用性和层次结构的清晰度，大幅增加代码修改维护成本。因此重度患者有必要重温mybatis！！！&lt;/p&gt;</summary>
    
    
    
    <category term="后端学习" scheme="https://ykxzyp0517.cn/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>一份详细的Docker学习教程</title>
    <link href="https://ykxzyp0517.cn/2022/01/23/%E4%B8%80%E4%BB%BD%E8%AF%A6%E7%BB%86%E7%9A%84Docker%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/"/>
    <id>https://ykxzyp0517.cn/2022/01/23/%E4%B8%80%E4%BB%BD%E8%AF%A6%E7%BB%86%E7%9A%84Docker%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-23T12:37:00.000Z</published>
    <updated>2022-12-01T12:34:41.114Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决同志们友善的和运维相处，共建美好的地球村。鼠鼠写了一篇关于Docker的学习教程，也当成是自己日后使用方便翻阅的笔记。<span id="more"></span><br>Docker是基于Go语言实现的云开源项目。<br>Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<code>一次镜像,处处运行</code>。</p><h1 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1.Docker概述"></a>1.Docker概述</h1><h2 id="传统虚拟机和容器区别？"><a href="#传统虚拟机和容器区别？" class="headerlink" title="传统虚拟机和容器区别？"></a>传统虚拟机和容器区别？</h2><p>传统虚拟机（virtual machine）：  </p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢</p><p>Linux容器（Linux Container，简称LXC）：</p><p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><p><img data-src="/images/pasted-451.png" alt="upload successful"><br> Docker 和传统虚拟化方式的不同之处：  </p><ul><li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li><li>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li><li>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>更快速的应用交付和部署<ul><li>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。</li></ul></li><li>更便捷的升级和扩缩容<ul><li>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。</li></ul></li><li>更简单的系统运维<ul><li>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。</li></ul></li><li>更高效的计算资源利用<ul><li>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</li></ul></li></ul><h1 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2.Docker安装"></a>2.Docker安装</h1><p><a href="https://www.docker.com/">https://www.docker.com/</a><br>Docker Hub官网: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="CentOS-Docker-安装"><a href="#CentOS-Docker-安装" class="headerlink" title="CentOS Docker 安装"></a>CentOS Docker 安装</h2><p><img data-src="/images/pasted-455.png" alt="upload successful"><br>前提条件<br>目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，<br>要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x<br>查看自己的内核  </p><p><img data-src="/images/pasted-456.png" alt="upload successful">  </p><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解</p><ul><li>镜像</li><li>容器</li><li>仓库</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。<br>相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。    </p><p><img data-src="/images/pasted-457.png" alt="upload successful">  </p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><strong>1 从面向对象角度</strong> </p><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台  </p><p><strong>2 从镜像容器角度</strong></p><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。  </p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库（Repository）是集中存放镜像文件的场所。<br>类似于<br>Maven仓库，存放各种jar包的地方；<br>github仓库，存放各种git项目的地方；<br>Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。<br>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。<br>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)%EF%BC%8C">https://hub.docker.com/)，</a><br>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>需要正确的理解仓库&#x2F;镜像&#x2F;容器这几个概念:</p></blockquote><p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。<br>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>镜像文件</p><ul><li>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</li></ul><p>容器实例</p><ul><li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li></ul><p>仓库</p><ul><li>就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</li></ul><h2 id="Docker平台架构图解-架构版"><a href="#Docker平台架构图解-架构版" class="headerlink" title="Docker平台架构图解(架构版)"></a>Docker平台架构图解(架构版)</h2><p>Docker 是一个 C&#x2F;S 模式的架构，后端是一个松耦合架构，众多模块各司其职。   </p><p><img data-src="/images/pasted-458.png" alt="upload successful">  </p><p><img data-src="/images/pasted-459.png" alt="upload successful">  </p><h2 id="Centos7安装Docker"><a href="#Centos7安装Docker" class="headerlink" title="Centos7安装Docker"></a>Centos7安装Docker</h2><p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a>   </p><p>1.安装gcc,gcc-c++</p><p><img data-src="/images/pasted-460.png" alt="upload successful">  </p><p><img data-src="/images/pasted-461.png" alt="upload successful">  </p><p>2.sudo yum install -y yum-utils  </p><p>3.sudo yum-config-manager \<br>    –add-repo \<br>    <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a><br> 建议换源，不然很容易超时  </p><p> yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br> 使用阿里云的仓库  </p><p><img data-src="/images/pasted-462.png" alt="upload successful"><br>4.重建yum索引<br><img data-src="/images/pasted-463.png" alt="upload successful"><br>5.安装docker<br><code>sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin  </code><br>6.start docker <code>sudo systemctl start docker</code><br>7.hello world <code>sudo docker run hello-world</code>  </p><p><img data-src="/images/pasted-464.png" alt="upload successful"><br>到这就安装成功了  </p><p>8.卸载<br><code>systemctl stop docker </code><br><code>yum remove docker-ce docker-ce-cli containerd.io</code><br><code>rm -rf /var/lib/docker</code><br><code>rm -rf /var/lib/containerd</code>  </p><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>1.获取镜像加速器地址  </p><p><img data-src="/images/pasted-465.png" alt="upload successful">  </p><p><img data-src="/images/pasted-466.png" alt="upload successful"><br>2.直接复制上图操作<br><img data-src="/images/pasted-467.png" alt="upload successful"><br>3.重启docker，注意上面的加速器地址每个人是不一样的  </p><h2 id="永远的HelloWorld"><a href="#永远的HelloWorld" class="headerlink" title="永远的HelloWorld"></a>永远的HelloWorld</h2><p>启动Docker后台容器(测试运行 hello-world)<br><code>docker run hello-world</code><br><img data-src="/images/pasted-468.png" alt="upload successful">    </p><p>输出这段提示以后，hello world就会停止运行，容器自动终止。  </p><h3 id="run干了什么？"><a href="#run干了什么？" class="headerlink" title="run干了什么？"></a>run干了什么？</h3><p><img data-src="/images/pasted-469.png" alt="upload successful">  </p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><blockquote><p>为什么Docker会比VM虚拟机快 ?  </p></blockquote><p>(1)docker有着比虚拟机更少的抽象层<br>   由于docker不需要Hypervisor(虚拟机)实现<code>硬件资源</code>虚拟化,运行在docker容器上的程序<code>直接使用</code>的都是<code>实际物理机</code>的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>(2)docker利用的是<code>宿主机的内核</code>,而<code>不需要</code>加载操作系统<code>OS内核 </code><br>   当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用<code>宿主机的操作系统</code>,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p><p><img data-src="/images/pasted-470.png" alt="upload successful">  </p><h1 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h1><p>帮助启动类命令<br>● 启动docker： systemctl start docker<br>● 停止docker： systemctl stop docker<br>● 重启docker： systemctl restart docker<br>● 查看docker状态： systemctl status docker<br>● 开机启动： systemctl enable docker<br>● 查看docker概要信息： docker info<br>● 查看docker总体帮助文档： docker –help<br>● 查看docker命令帮助文档： docker 具体命令 –help  </p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>列出本地主机上的镜像<code>docker images</code>  </p></blockquote><p><img data-src="/images/pasted-471.png" alt="upload successful"><br>各个选项说明:<br>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签版本号<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小<br> 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用<code>REPOSITORY:TAG</code>来定义不同的镜像。<br> 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 <code>ubuntu:latest </code>镜像</p><blockquote><p>查找某个镜像 docker search 某个XXX镜像名字  </p></blockquote><p>命令：<code>docker search [OPTIONS] 镜像名字</code>  </p><p><img data-src="/images/pasted-472.png" alt="upload successful">  </p><p><img data-src="/images/pasted-473.png" alt="upload successful"><br>OPTIONS说明：<br><code>--limit</code> : 只列出N个镜像，默认25个<br><code>docker search --limit 5 redis</code>  </p><blockquote><p>docker pull 某个XXX镜像名字  </p></blockquote><p>下载镜像<br>docker pull 镜像名字[:TAG]<br>docker pull 镜像名字<br>没有TAG就是最新版<br>等价于<br>docker pull 镜像名字:latest<br>docker pull ubuntu    </p><blockquote><p>docker system df : 查看镜像&#x2F;容器&#x2F;数据卷所占的空间  </p></blockquote><p><img data-src="/images/pasted-474.png" alt="upload successful">  </p><blockquote><p>docker rmi 某个XXX镜像名字ID. </p></blockquote><p><img data-src="/images/pasted-475.png" alt="upload successful"><br>删除失败，有容器在使用这个镜像，加<code>-f</code>  </p><p>删除镜像<br>删除单个<br>docker rmi -f 镜像ID<br>删除多个<br>docker rmi -f 镜像名1:TAG 镜像名2:TAG<br>删除全部<br>docker rmi -f $(docker images -qa)  </p><blockquote><p>面试题：谈谈docker虚悬镜像是什么？. </p></blockquote><p>是什么？<br>仓库名、标签都是<none>的镜像，俗称虚悬镜像dangling image<br>长什么样？  </p><p><img data-src="/images/pasted-476.png" alt="upload successful">  </p><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能创建容器， 这是根本前提(下载一个CentOS或者ubuntu镜像演示)  </p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]. </p></blockquote><p><img data-src="/images/pasted-478.png" alt="upload successful">  </p><p><img data-src="/images/pasted-477.png" alt="upload successful">  </p><blockquote><p>docker run -it ubuntu &#x2F;bin&#x2F;bash<br>i interactive<br>t tty   </p></blockquote><p><img data-src="/images/pasted-480.png" alt="upload successful">  </p><blockquote><p>列出当前所有正在运行的容器. docker ps [OPTIONS]  </p></blockquote><p><img data-src="/images/pasted-481.png" alt="upload successful">  </p><p><img data-src="/images/pasted-482.png" alt="upload successful">  </p><blockquote><p>docker run -it –name&#x3D;myu1 ubuntu bash </p></blockquote><p><img data-src="/images/pasted-483.png" alt="upload successful">  </p><blockquote><p>退出容器 </p></blockquote><p>两种退出方式<br>exit<br>run进去容器，exit退出，容器停止<br>ctrl+p+q<br>run进去容器，ctrl+p+q退出，容器不停止  </p><blockquote><p>启动已停止运行的容器    docker start 容器ID或者容器名</p></blockquote><blockquote><p>重启容器   docker restart 容器ID或者容器名  </p></blockquote><blockquote><p>停止容器   docker stop 容器ID或者容器名  </p></blockquote><blockquote><p>强制停止容器   docker kill 容器ID或容器名  </p></blockquote><blockquote><p>删除已停止的容器  docker rm 容器ID<br>一次性删除多个容器实例<br>docker rm -f $(docker ps -a -q)  docker ps -a -q | xargs docker rm </p></blockquote><h2 id="重要-容器命令"><a href="#重要-容器命令" class="headerlink" title="重要(容器命令)"></a>重要(容器命令)</h2><ol><li>有镜像才能创建容器，这是根本前提(下载一个Redis6.0.8镜像演示)</li><li>启动守护式容器(后台服务器)</li></ol><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。<br><code>docker run -d 容器名</code><br>#使用镜像centos:latest以后台模式启动一个容器<br><code>docker run -d centos</code><br>问题：然后<code>docker ps -a </code>进行查看, 会发现容器已经退出<br>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程。<br>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。<br>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start。但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是将你要<code>运行的程序</code>以<code>前台进程</code>的形式运行，常见就是<code>命令行模式</code>，表示我还有交互操作，<code>别中断</code>。</p><p>redis 前后台启动演示case<br>前台交互式启动<br><code>docker run -it redis:6.0.8  </code>  </p><p><img data-src="/images/pasted-484.png" alt="upload successful"><br>但是我一不小心退出，redis就挂了这是肯定不行的，因此后台启动<br>后台守护式启动<br><code>docker run -d redis:6.0.8 </code>   </p><blockquote><p>查看容器日志  docker logs 容器ID  </p></blockquote><blockquote><p>查看容器内运行的进程  docker top 容器ID  </p></blockquote><p><img data-src="/images/pasted-485.png" alt="upload successful">  </p><blockquote><p>查看容器内部细节  docker inspect 容器ID   </p></blockquote><blockquote><p>进入正在运行的容器并以命令行交互  docker exec -it 容器ID bash</p></blockquote><p><img data-src="/images/pasted-486.png" alt="upload successful">  </p><blockquote><p>重新进入docker attach 容器ID. </p></blockquote><p>attch 和 exec的区别是什么？<br>attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。  </p><p><img data-src="/images/pasted-487.png" alt="upload successful">  </p><p>exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。  </p><p><img data-src="/images/pasted-488.png" alt="upload successful"><br>推荐使用exec<br>因为退出容器终端，不会导致容器的停止。  </p><blockquote><p>从容器内拷贝文件到主机上  容器→主机   docker cp 容器ID:容器内路径 目的主机路径</p></blockquote><p><img data-src="/images/pasted-489.png" alt="upload successful">  </p><blockquote><p>导入和导出容器  </p></blockquote><p>export 导出容器的内容留作为一个tar归档文件[对应import命令]<br>import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]  </p><p><em>docker export 容器ID &gt; 文件名.tar</em>  </p><p><img data-src="/images/pasted-490.png" alt="upload successful">  </p><p><img data-src="/images/pasted-491.png" alt="upload successful">  </p><p><em>cat 文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本号</em>  </p><p><img data-src="/images/pasted-492.png" alt="upload successful">  </p><p><img data-src="/images/pasted-493.png" alt="upload successful">  </p><h1 id="4-Docker镜像"><a href="#4-Docker镜像" class="headerlink" title="4.Docker镜像"></a>4.Docker镜像</h1><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。<br>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。  </p><h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载<br><img data-src="/images/pasted-494.png" alt="upload successful">  </p><h2 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。<br>镜像可以通过<code>分层</code>来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br><strong>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</strong></p><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs  。<br>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p><p><img data-src="/images/pasted-495.png" alt="upload successful">  </p><blockquote><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ </p></blockquote><p><img data-src="/images/pasted-496.png" alt="upload successful"><br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="为什么-Docker-镜像要采用这种分层结构呢？"><a href="#为什么-Docker-镜像要采用这种分层结构呢？" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢？"></a>为什么 Docker 镜像要采用这种分层结构呢？</h2><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。<br>比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。   </p><h2 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h2><p>Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。<br>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 </p><p><img data-src="/images/pasted-497.png" alt="upload successful">  </p><h2 id="Docker镜像commit操作案例"><a href="#Docker镜像commit操作案例" class="headerlink" title="Docker镜像commit操作案例"></a>Docker镜像commit操作案例</h2><blockquote><p>docker commit 提交容器副本使之成为一个新的镜像<br>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]  </p></blockquote><h3 id="案例（VIM的添加）"><a href="#案例（VIM的添加）" class="headerlink" title="案例（VIM的添加）"></a>案例（VIM的添加）</h3><ol><li><p>从Hub上下载ubuntu镜像到本地并成功运行</p></li><li><p>原始的默认Ubuntu镜像是不带着vim命令的</p><p> <img data-src="/images/pasted-498.png" alt="upload successful">  </p></li><li><p>外网连通的情况下，安装vim  </p></li><li><p>安装成功后commit镜像  </p><p> <img data-src="/images/pasted-499.png" alt="upload successful">  </p></li><li><p>启动我们的新镜像并和原来的对比  </p><p> <img data-src="/images/pasted-500.png" alt="upload successful"></p></li></ol><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。<br>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层  </p><p><img data-src="/images/pasted-501.png" alt="upload successful">  </p><h1 id="5-本地镜像发布到阿里云"><a href="#5-本地镜像发布到阿里云" class="headerlink" title="5.本地镜像发布到阿里云"></a>5.本地镜像发布到阿里云</h1><h2 id="本地镜像发布到阿里云流程"><a href="#本地镜像发布到阿里云流程" class="headerlink" title="本地镜像发布到阿里云流程"></a>本地镜像发布到阿里云流程</h2><p><img data-src="/images/pasted-502.png" alt="upload successful">  </p><ol><li><p>创建命名空间  </p><p> <img data-src="/images/pasted-503.png" alt="upload successful">  </p></li><li><p>创建本地镜像仓库  </p><p> <img data-src="/images/pasted-504.png" alt="upload successful">  </p></li><li><p>进入管理界面获得脚本</p><p> <img data-src="/images/pasted-505.png" alt="upload successful">    </p></li><li><p>登录阿里云库  </p><p> <img data-src="/images/pasted-506.png" alt="upload successful">  </p></li><li><p>上传镜像  </p><p> <img data-src="/images/pasted-507.png" alt="upload successful"></p></li></ol><h2 id="拉取阿里云镜像"><a href="#拉取阿里云镜像" class="headerlink" title="拉取阿里云镜像"></a>拉取阿里云镜像</h2><ol><li><p>删除本地相关镜像</p><p> <img data-src="/images/pasted-508.png" alt="upload successful"></p></li><li><p>拉取  </p><p> <img data-src="/images/pasted-509.png" alt="upload successful"></p></li></ol><h1 id="6-本地镜像发布到私有库"><a href="#6-本地镜像发布到私有库" class="headerlink" title="6.本地镜像发布到私有库"></a>6.本地镜像发布到私有库</h1><ol><li>官方Docker Hub地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>  ，  中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。</li><li>Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</li></ol><h2 id="将本地镜像推送到私有库"><a href="#将本地镜像推送到私有库" class="headerlink" title="将本地镜像推送到私有库"></a>将本地镜像推送到私有库</h2><ol><li><p>下载镜像Docker Registry<br> <code>docker pull registry </code>  </p><p> <img data-src="/images/pasted-510.png" alt="upload successful"><br> 相当于本地有一个私有库</p></li><li><p>运行私有库Registry，相当于本地有个私有Docker hub<br>  <code>docker run -d -p 5000:5000  -v /ykx1/myregistry/:/tmp/registry --privileged=true registry</code></p><p> <img data-src="/images/pasted-511.png" alt="upload successful">  </p></li><li><p>案例演示创建一个新镜像，ubuntu安装ifconfig命令<br>  <code>docker run -it ubuntu /bin/bash</code>. </p><ol><li>从Hub上下载ubuntu镜像到本地并成功运行</li><li>原始的Ubuntu镜像是不带着ifconfig命令的<br> <code>apt-get install net-tools</code><br> <img data-src="/images/pasted-512.png" alt="upload successful"></li><li>安装完成后，commit我们自己的新镜像<br>  <code>docker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;ykx&quot; ed4b78992d51 ykxubuntu:1.5</code><br> <img data-src="/images/pasted-513.png" alt="upload successful"></li></ol></li><li><p>curl验证私服库上有什么镜像<br> <code>curl -XGET http://127.0.0.1:5000/v2/_catalog</code>. </p><p> <img data-src="/images/pasted-514.png" alt="upload successful">   </p></li><li><p>将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p><p> <code>按照公式： docker   tag   镜像:Tag   Host:Port/Repository:Tag</code></p><p> <code>docker tag ykxubuntu:1.5 127.0.0.1:5000/ykxubuntu:1.5</code><br> 切记需要加上端口号，我被坑了</p><p> <img data-src="/images/pasted-515.png" alt="upload successful">  </p></li><li><p>修改配置文件使之支持http<br> <code>cat /etc/docker/daemon.json</code><br> <img data-src="/images/pasted-516.png" alt="upload successful"><br> <code>vim /etc/docker/daemon.json</code><br> <img data-src="/images/pasted-517.png" alt="upload successful"><br> 上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。&#x3D;&#x3D;&#x3D;&#x3D;&gt; 修改完后如果不生效，建议重启docker。</p></li><li><p>push推送到私服库<br>  <code>docker push 192.168.200.160:5000/ykxubuntu:1.5</code><br> <img data-src="/images/pasted-518.png" alt="upload successful"></p><p> <img data-src="/images/pasted-519.png" alt="upload successful"></p></li></ol><h2 id="将私有库拉取到本地"><a href="#将私有库拉取到本地" class="headerlink" title="将私有库拉取到本地"></a>将私有库拉取到本地</h2><pre><code>`docker pull 192.168.200.160:5000/ykxubuntu:1.5`  </code></pre><p><img data-src="/images/pasted-520.png" alt="upload successful">  </p><h1 id="7-Docker容器数据卷"><a href="#7-Docker容器数据卷" class="headerlink" title="7.Docker容器数据卷"></a>7.Docker容器数据卷</h1><h2 id="容器卷记得加入"><a href="#容器卷记得加入" class="headerlink" title="容器卷记得加入"></a>容器卷记得加入</h2><p><code>--privileged=true</code>  </p><blockquote><p>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied   </p></blockquote><p>解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可<br>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用<code>--privileged=true</code>命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。   </p><p><img data-src="/images/pasted-521.png" alt="upload successful">  </p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。  </p><blockquote><p>一句话：有点类似我们Redis里面的rdb和aof文件。  </p></blockquote><p>将docker容器内的数据保存进宿主机的磁盘中，运行一个带有容器卷存储功能的容器实例。  </p><p> <code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名</code>  </p><h2 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h2><p>将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。<br>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。<br> 特点：</p><ol><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效，爽</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img data-src="/images/pasted-522.png" alt="upload successful"><br><code> docker run -it --privileged=true -v /tmp/host_data:/tmp/docker_data --name=u1 ubuntu</code>. </p><p><img data-src="/images/pasted-523.png" alt="upload successful"><br>完成宿主机和容器的映射，在宿主机的修改在容器内也能获得。完成了相同映射路劲的数据共享。  </p><p><img data-src="/images/pasted-524.png" alt="upload successful">  </p><p><img data-src="/images/pasted-525.png" alt="upload successful">  </p><p><code>docker inspect 容器id</code>  查看数据卷是否挂载成功</p><p><img data-src="/images/pasted-526.png" alt="upload successful">  </p><h2 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h2><p>读写(默认)<br><code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</code>  </p><p><img data-src="/images/pasted-527.png" alt="upload successful">  </p><p>只读<br>容器实例内部被限制，只能读取不能写  </p><p><img data-src="/images/pasted-528.png" alt="upload successful"><br><code>docker run -it --privileged=true -v /tmp/mydocker:/tmp/mydocker:ro --name=u2 ubuntu</code>   </p><p><img data-src="/images/pasted-529.png" alt="upload successful">  </p><p>宿主机可读可写  </p><p><img data-src="/images/pasted-530.png" alt="upload successful">  </p><h2 id="数据卷的继承和共享"><a href="#数据卷的继承和共享" class="headerlink" title="数据卷的继承和共享"></a>数据卷的继承和共享</h2><p>容器1完成和宿主机的映射<br><code>docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu</code><br>容器2继承容器1的卷规则<br><code>docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu</code>    </p><h1 id="8-常规安装"><a href="#8-常规安装" class="headerlink" title="8.常规安装"></a>8.常规安装</h1><h2 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h2><ol><li>搜索镜像</li><li>拉取镜像</li><li>查看镜像</li><li>启动镜像 - 服务端口映射</li><li>停止容器</li><li>移除容器</li></ol><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><ul><li>拉取tomcat镜像到本地</li></ul><p><img data-src="/images/pasted-531.png" alt="upload successful">  </p><ul><li>查看是否拉取成功</li></ul><p><img data-src="/images/pasted-532.png" alt="upload successful">    </p><ul><li>运行tomcat容器</li></ul><p><img data-src="/images/pasted-533.png" alt="upload successful">  </p><ul><li>访问猫首页</li></ul><p><img data-src="/images/pasted-534.png" alt="upload successful">  </p><ul><li>解决方案<br>  可能没有映射端口或者没有关闭防火墙<br>  把webapps.dist目录换成webapps</li></ul><p><img data-src="/images/pasted-535.png" alt="upload successful"><br>新版的tomcat的webapps是空的<br><strong>非常的麻烦也没有必要，索性换个镜像好了</strong><br><code> docker pull billygoo/tomcat8-jdk8</code>  </p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li>docker hub上面查找mysql镜像</li></ul><p><img data-src="/images/pasted-536.png" alt="upload successful">  </p><ul><li>下载镜像</li></ul><p><img data-src="/images/pasted-537.png" alt="upload successful">  </p><ul><li>启动mysql</li></ul><p><img data-src="/images/pasted-539.png" alt="upload successful">  </p><ul><li>进去mysql</li></ul><p><code>[root@ykx2 ~]# docker exec -it 5543061767e3 /bin/bash   root@5543061767e3:/# mysql -uroot -pabc123 </code>   </p><p><img data-src="/images/pasted-540.png" alt="upload successful">  </p><blockquote><p>mysql5注意字符集的问题<br>删除容器后，里面的mysql数据怎么办？. </p></blockquote><p>新建mysql容器实例<br><code>docker run -d -p 3306:3306  --privileged=true  -v /zzyyuse/mysql/log:/var/log/mysql  -v /zzyyuse/mysql/data:/var/lib/mysql  -v /zzyyuse/mysql/conf:/etc/mysql/conf.d  -eMYSQL_ROOT_PASSWORD=123456   --name mysql mysql:8</code>  </p><p><img data-src="/images/pasted-541.png" alt="upload successful"><br>新建my.cnf，通过容器卷同步给mysql容器实例  </p><pre><code>[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8</code></pre><p>重新启动mysql容器实例再重新进入并查看字符编码  </p><p><img data-src="/images/pasted-542.png" alt="upload successful">  </p><p>docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据  </p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8<br><code>docker pull redis:6.0.8</code></li></ul><p><img data-src="/images/pasted-543.png" alt="upload successful">  </p><ul><li>启动<br><code>docker run -d -p 6379:6379 redis:6.0.8</code></li></ul><p><img data-src="/images/pasted-544.png" alt="upload successful">  </p><ul><li><p>进行docker的容器数据卷的挂载<br>命令提醒：容器卷记得加入–privileged&#x3D;true<br>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可  </p></li><li><p>在CentOS宿主机下新建目录&#x2F;app&#x2F;redis</p></li></ul><p><img data-src="/images/pasted-545.png" alt="upload successful">  </p><ul><li>将一个redis.conf文件模板拷贝进&#x2F;app&#x2F;redis目录下</li></ul><p><img data-src="/images/pasted-546.png" alt="upload successful">  </p><ul><li><p>&#x2F;app&#x2F;redis目录下修改redis.conf文件  </p></li><li><p>启动redis  </p><pre><code>      docker run        -p 6379:6379       --name myr3       --privileged=true       -v /app/redis/redis.conf:/etc/redis/redis.conf       -v /app/redis/data:/data   -d redis:6.0.8 redis-server /etc/redis/redis.conf</code></pre></li></ul><h1 id="9-Docker复杂安装"><a href="#9-Docker复杂安装" class="headerlink" title="9.Docker复杂安装"></a>9.Docker复杂安装</h1><h2 id="mysql主从复制"><a href="#mysql主从复制" class="headerlink" title="mysql主从复制"></a>mysql主从复制</h2><h3 id="主机3307"><a href="#主机3307" class="headerlink" title="主机3307"></a>主机3307</h3><ul><li><p>创建3307主库  </p><pre><code>docker run -p 3307:3306 --name mysql-master -v /mydata/mysql-master/log:/var/log/mysql -v /mydata/mysql-master/data:/var/lib/mysql -v /mydata/mysql-master/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root  -d mysql:8</code></pre></li><li><p>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf  </p><pre><code>[mysqld]## 设置server_id，同一局域网中需要唯一server_id=101 ## 指定不需要同步的数据库名称binlog-ignore-db=mysql  ## 开启二进制日志功能log-bin=mall-mysql-bin  ## 设置二进制日志使用内存大小（事务）binlog_cache_size=1M  ## 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed  ## 二进制日志过期清理时间。默认值为0，表示不自动清理。expire_logs_days=7  ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062</code></pre></li><li><p>docker restart mysql-master  重启mysql容器  </p></li><li><p>master容器实例内创建数据同步用户</p><pre><code>  CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;  GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;</code></pre></li></ul><h3 id="从机3308"><a href="#从机3308" class="headerlink" title="从机3308"></a>从机3308</h3><ul><li><p>创建从机实例  </p><pre><code>docker run -p 3308:3306 --name mysql-slave \-v /mydata/mysql-slave/log:/var/log/mysql \-v /mydata/mysql-slave/data:/var/lib/mysql \-v /mydata/mysql-slave/conf:/etc/mysql \-e MYSQL_ROOT_PASSWORD=root  \-d mysql:5.7</code></pre></li></ul><p><img data-src="/images/pasted-547.png" alt="upload successful">  </p><ul><li><p>修改从机my.cnf</p><pre><code>[mysqld]## 设置server_id，同一局域网中需要唯一server_id=102## 指定不需要同步的数据库名称binlog-ignore-db=mysql  ## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用log-bin=mall-mysql-slave1-bin  ## 设置二进制日志使用内存大小（事务）binlog_cache_size=1M  ## 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed  ## 二进制日志过期清理时间。默认值为0，表示不自动清理。expire_logs_days=7  ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062  ## relay_log配置中继日志relay_log=mall-mysql-relay-bin  ## log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1  ## slave设置为只读（具有super权限的用户除外）read_only=1</code></pre></li><li><p>修改完配置后重启slave实例<br>                <code>docker restart mysql-slave</code>                </p></li><li><p>在主数据库中查看主从同步状态<br><code>show master status;</code></p></li></ul><p><img data-src="/images/pasted-548.png" alt="upload successful">  </p><ul><li><p>进入mysql-slave容器</p><pre><code>docker exec -it mysql-slave /bin/bashmysql -uroot -proot</code></pre></li><li><p>在从数据库中配置主从复制  </p><pre><code>change master to master_host=&#39;宿主机ip&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-mysql-bin.000001&#39;, master_log_pos=617, master_connect_retry=30; master_host：主数据库的IP地址；  master_port：主数据库的运行端口；  master_user：在主数据库创建的用于同步数据的用户账号；  master_password：在主数据库创建的用于同步数据的用户密码；  master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；  master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；  master_connect_retry：连接失败重试的时间间隔，单位为秒。       </code></pre></li><li><p>在从数据库中查看主从同步状态</p></li></ul><p><code>show slave status \G;</code>  </p><p><img data-src="/images/pasted-549.png" alt="upload successful">  </p><ul><li>在从数据库中开启主从同步</li></ul><p><code>start slave;</code><br><code>show slave status \G;</code>  </p><p><img data-src="/images/pasted-550.png" alt="upload successful">  </p><h2 id="安装redis集群"><a href="#安装redis集群" class="headerlink" title="安装redis集群"></a>安装redis集群</h2><blockquote><p>1~2亿条数据需要缓存，请问如何设计这个存储案例？<br>回答：单机单台100%不可能，肯定是分布式存储，用redis如何落地？  </p></blockquote><p><strong>哈希取余分区</strong>  </p><p><img data-src="/images/pasted-551.png" alt="upload successful"><br>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：<br>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。<br>优点：<br>  简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。<br>缺点：<br>   原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。<br>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。    </p><h3 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h3><p>提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系  </p><blockquote><p>一致性哈希环<br>        一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。<br>        它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。    </p></blockquote><blockquote><p>节点映射<br>   将集群中各个IP节点映射到环上的某一个位置。<br>   将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下：        </p></blockquote><p><img data-src="/images/pasted-552.png" alt="upload successful">  </p><blockquote><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。<br>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p></blockquote><p><img data-src="/images/pasted-553.png" alt="upload successful">  </p><blockquote><p>容错性<br>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p></blockquote><p><img data-src="/images/pasted-554.png" alt="upload successful">  </p><blockquote><p>一致性哈希算法的扩展性<br>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，<br>不会导致hash取余全部数据重新洗牌。  </p></blockquote><p><img data-src="/images/pasted-555.png" alt="upload successful">   </p><h3 id="一致性哈希算法的数据倾斜问题"><a href="#一致性哈希算法的数据倾斜问题" class="headerlink" title="一致性哈希算法的数据倾斜问题"></a>一致性哈希算法的数据倾斜问题</h3><p>Hash环的数据倾斜问题<br>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，<br>例如系统中只有两台服务器：  </p><p><img data-src="/images/pasted-556.png" alt="upload successful">  </p><blockquote><p>总结<br>为了在节点数目发生改变时尽可能少的迁移数据<br>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。<br>而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。<br>优点<br>加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。<br>缺点<br>数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p></blockquote><h3 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h3><ul><li>为什么出现</li></ul><p><img data-src="/images/pasted-557.png" alt="upload successful">  </p><ul><li>能干什么<br>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</li></ul><p><img data-src="/images/pasted-558.png" alt="upload successful"><br>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。<br>哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。    </p><ul><li>多少个hash槽<br>一个集群只能有16384个槽，编号0-16383（0-2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot &#x3D; CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</li><li>哈希槽计算<br>Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上</li></ul><p><img data-src="/images/pasted-559.png" alt="upload successful">  </p><p><img data-src="/images/pasted-560.png" alt="upload successful">  </p><h3 id="三主三从案例"><a href="#三主三从案例" class="headerlink" title="三主三从案例"></a>三主三从案例</h3><p><img data-src="/images/pasted-561.png" alt="upload successful">  </p><ul><li>创建6个redis容器<br><code>docker run -d --name redis-node-6 --net host --privileged=true -v /mydata/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</code></li></ul><p><img data-src="/images/pasted-562.png" alt="upload successful">  </p><ul><li>在随意一个容器中进行集群两两配对</li></ul><p><code>redis-cli --cluster create 192.168.200.161:6381 192.168.200.161:6382 192.168.200.161:6383 192.168.200.161:6384 192.168.200.161:6385 192.168.200.161:6386 --cluster-replicas 1</code>  </p><p><img data-src="/images/pasted-563.png" alt="upload successful"><br>其中6381,6382,6383位主机，区域为从机<br><img data-src="/images/pasted-564.png" alt="upload successful">  </p><ul><li>以6381为切入点查看集群状态<br><code>redis-cli -p 6381</code><br><code>cluster info</code></li></ul><p><img data-src="/images/pasted-565.png" alt="upload successful"><br><code>cluster nodes</code>  </p><p><img data-src="/images/pasted-566.png" alt="upload successful">  </p><h3 id="写入失败"><a href="#写入失败" class="headerlink" title="写入失败"></a>写入失败</h3><p><code>redis-cli -p 6381</code>插入数据时失败，是因为集群的原因，key值没有落在当前主机管理的槽位中。  </p><p><img data-src="/images/pasted-567.png" alt="upload successful"><br>使用集群的方式进行redis连接<br><code>redis-cli -p 6381 -c</code><br><img data-src="/images/pasted-568.png" alt="upload successful"><br>插入不同数据时候会跳转主机  </p><p><img data-src="/images/pasted-569.png" alt="upload successful">  </p><h3 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h3><p><code>redis-cli --cluster check 192.168.200.161:6381 </code>    </p><p><img data-src="/images/pasted-570.png" alt="upload successful">  </p><h3 id="redis集群的主从切换"><a href="#redis集群的主从切换" class="headerlink" title="redis集群的主从切换"></a>redis集群的主从切换</h3><ul><li>关闭node1  <code>docker stop redis-node-1</code></li></ul><p><img data-src="/images/pasted-571.png" alt="upload successful">  </p><ul><li><code>redis-cli -p 6382 -c</code>观察节点状态<br><code>cluster nodes</code></li></ul><p><img data-src="/images/pasted-572.png" alt="upload successful"><br>6385主机上位  </p><ul><li>此时6381恢复后，是变成6385的从机还是主机？<br><code>docker start redis-node-1</code></li></ul><p><img data-src="/images/pasted-573.png" alt="upload successful"><br>6381变成了6385的从机，6385还是主机</p><ul><li>让6381变成主机，6385变回从机<br> <code>docker stop redis-node-5</code>后查看集群状态</li></ul><p><img data-src="/images/pasted-574.png" alt="upload successful"><br>6381变成主机后，再开机6385，恢复他从机身份<br><code>docker start redis-node-5</code>    </p><p><img data-src="/images/pasted-575.png" alt="upload successful">  </p><h3 id="集群主从扩容"><a href="#集群主从扩容" class="headerlink" title="集群主从扩容"></a>集群主从扩容</h3><p><img data-src="/images/pasted-576.png" alt="upload successful"><br>添加新的主机后，槽位该如何分配？  </p><pre><code>   docker run -d --name redis-node-8 --net host --privileged=true -v /mydata/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</code></pre><ul><li>添加6387,6388两台主机容器</li></ul><p><img data-src="/images/pasted-577.png" alt="upload successful">  </p><ul><li><p>进入6387容器<br><code>docker exec -it redis-node-7 bash</code>  </p></li><li><p><code>redis-cli --cluster add-node 192.168.200.161:6387 192.168.200.161:6381</code>    通过6381找到集群，从而把6387作为master加入集群中</p></li></ul><p><img data-src="/images/pasted-578.png" alt="upload successful"><br>但是此时发现还是只有3m3s  </p><ul><li><code>redis-cli --cluster check 192.168.200.161:6381</code> 查看集群状态</li></ul><p><img data-src="/images/pasted-579.png" alt="upload successful"><br>6387没有槽位  </p><ul><li>重新分配槽号<br><code>redis-cli --cluster reshard 192.168.200.161:6381</code></li></ul><p><img data-src="/images/pasted-580.png" alt="upload successful"><br>其中要分配的槽位为16384&#x2F;4&#x3D;4096<br>receiveId为6387的id   </p><ul><li>重新查看集群状态<code>redis-cli --cluster check 192.168.200.161:6381</code></li></ul><p><img data-src="/images/pasted-581.png" alt="upload successful">  </p><p>发现6387的槽位为其它3个主机的槽位每个人匀出来的槽位共计4096  </p><blockquote><p>为什么6387要分成三个独立的新的区间呢？  </p></blockquote><ul><li><p>为主节点6387添加从节点6388<br><code> redis-cli --cluster add-node 192.168.200.161:6388 192.168.200.161:6387 --cluster-slave --cluster-master-id b9dd7cacfc4a67f29776c6ab38697cc74de6c320</code></p></li><li><p><code>redis-cli --cluster check 192.168.200.161:6381</code>.</p></li></ul><p><img data-src="/images/pasted-582.png" alt="upload successful">  </p><h3 id="集群主从缩容"><a href="#集群主从缩容" class="headerlink" title="集群主从缩容"></a>集群主从缩容</h3><blockquote><p>分配给主机的槽位节点在缩容后该如何分配？  </p></blockquote><ol><li>清楚从节点6388</li><li>请出来的槽位重新分配</li><li>再删除6387</li><li>恢复成3主3从</li></ol><ul><li>先删除6388节点<br><code>redis-cli --cluster del-node 192.168.200.161:6388 0e7b624170baecd01047eb09e4ab5fa8268a9f91</code></li></ul><p><img data-src="/images/pasted-583.png" alt="upload successful">  </p><ul><li>重新分配槽号<br><code>redis-cli --cluster reshard 192.168.200.161:6381</code></li></ul><p><img data-src="/images/pasted-584.png" alt="upload successful"><br>清空6387的4096个槽号，由6381接收这些空出来的槽号  </p><p><img data-src="/images/pasted-585.png" alt="upload successful"><br>这些空出来的槽号由6387节点清出来<br><img data-src="/images/pasted-586.png" alt="upload successful">  </p><p>查看集群状态<br><code>redis-cli --cluster check 192.168.200.161:6381</code><br>此时6381节点接收了空出来的槽位</p><p><img data-src="/images/pasted-587.png" alt="upload successful">  </p><ul><li>删除6387结点<br><code>redis-cli --cluster del-node 192.168.200.161:6387 b9dd7cacfc4a67f29776c6ab38697cc74de6c320</code></li></ul><p><img data-src="/images/pasted-588.png" alt="upload successful">  </p><ul><li>恢复成了3主3从</li></ul><p><img data-src="/images/pasted-589.png" alt="upload successful">   </p><h1 id="10-DockerFile"><a href="#10-DockerFile" class="headerlink" title="10.DockerFile"></a>10.DockerFile</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。<br>官网<br><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a><br>构建三步骤  </p><ol><li>编写Dockerfile文件</li><li>docker build 命令构建镜像</li><li>docker run 镜像 运行容器实例</li></ol><h2 id="DockerFile构建过程解析"><a href="#DockerFile构建过程解析" class="headerlink" title="DockerFile构建过程解析"></a>DockerFile构建过程解析</h2><blockquote><p>Dockerfile内容基础知识  </p></blockquote><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><blockquote><p>Docker执行Dockerfile的大致流程  </p></blockquote><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成</li></ol><p><img data-src="/images/pasted-590.png" alt="upload successful">  </p><h2 id="DockerFile常用保留字指令"><a href="#DockerFile常用保留字指令" class="headerlink" title="DockerFile常用保留字指令"></a>DockerFile常用保留字指令</h2><ul><li>FROM<br>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</li><li>MAINTAINER<br>镜像维护者的姓名和邮箱地址  </li><li>RUN<br>容器构建时需要运行的命令<br>两种格式</li></ul><p><img data-src="/images/pasted-591.png" alt="upload successful"><br>Run是在build的时候进行的</p><ul><li>EXPOSE<br>当前容器对外暴露出的端口</li><li>WORKDIR<br>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</li><li>USER<br>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</li><li>ENV<br>用来在构建镜像过程中设置环境变量</li></ul><p><img data-src="/images/pasted-592.png" alt="upload successful">  </p><ul><li>ADD<br>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li><li>COPY<br>类似ADD，拷贝文件和目录到镜像中。<br>将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置  </li><li>VOLUME<br>容器数据卷，用于数据保存和持久化工作</li><li>CMD<br>指定容器启动后的要干的事情</li></ul><p><img data-src="/images/pasted-593.png" alt="upload successful"><br>它和前面RUN命令的区别<br>● CMD是在docker run 时运行。<br>● RUN是在 docker build 时运行。    </p><ul><li>ENTRYPOINT<br>也是用来指定一个容器启动时要运行的命令<br>类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。<br>命令格式和案例说明</li></ul><p><img data-src="/images/pasted-594.png" alt="upload successful"><br>优点：在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。<br>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。  </p><h2 id="自定义Centos7镜像vim-ifconfig-jdk8"><a href="#自定义Centos7镜像vim-ifconfig-jdk8" class="headerlink" title="自定义Centos7镜像vim+ifconfig+jdk8"></a>自定义Centos7镜像vim+ifconfig+jdk8</h2><p>JDK的下载镜像地址：<a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a>  </p><p><img data-src="/images/pasted-595.png" alt="upload successful">  </p><ul><li><p>新建vim Dockerfile</p><pre><code>  FROM centos  MAINTAINER ykx&lt;loveykxfor1999@163.com&gt;  ENV MYPATH /usr/local  WORKDIR $MYPATH  #安装vim编辑器  RUN yum -y install vim  #安装ifconfig命令查看网络IP  RUN yum -y install net-tools  #安装java8及lib库  RUN yum -y install glibc.i686  RUN mkdir /usr/local/java  #ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置  ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/  #配置java环境变量  ENV JAVA_HOME /usr/local/java/jdk1.8.0_171  ENV JRE_HOME $JAVA_HOME/jre  ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH  ENV PATH $JAVA_HOME/bin:$PATH  EXPOSE 80  CMD echo $MYPATH  CMD echo &quot;success--------------ok&quot;  CMD /bin/bash  ~                      </code></pre></li><li><p>docker build -t centosjava8:1.5 .   注意，上面TAG后面有个空格，有个点<br>创建新的镜像文件</p></li></ul><p><img data-src="/images/pasted-596.png" alt="upload successful"><br>成功  </p><p><img data-src="/images/pasted-597.png" alt="upload successful">  </p><h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>仓库名、标签都是none的镜像，俗称dangling image  </p><p><img data-src="/images/pasted-598.png" alt="upload successful"><br>查看所有的虚悬镜像<br><code>docker image ls -f dangling=true</code></p><p><img data-src="/images/pasted-599.png" alt="upload successful"><br>删除所有虚悬镜像<br><code>docker image prune</code>  </p><h1 id="11-Docker微服务实战"><a href="#11-Docker微服务实战" class="headerlink" title="11.Docker微服务实战"></a>11.Docker微服务实战</h1><h2 id="编写简单的微服务业务"><a href="#编写简单的微服务业务" class="headerlink" title="编写简单的微服务业务"></a>编写简单的微服务业务</h2><p>别的不需要过多赘述，只展示业务类  </p><p><img data-src="/images/pasted-600.png" alt="upload successful">  </p><ol><li><p>MAVEN打包完后将jar包传给服务器</p></li><li><p>服务器在jar包所在目录编写Dockerfile </p><pre><code> # 基础镜像使用java FROM java:8 # 作者 MAINTAINER ykx # VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp VOLUME /tmp # 将jar包添加到容器中并更名为zzyy_docker.jar ADD docker_boot-1.0-SNAPSHOT.jar ykx_docker.jar # 运行jar包 RUN bash -c &#39;touch /ykx_docker.jar&#39; ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/ykx_docker.jar&quot;] #暴露6001端口作为微服务 EXPOSE 6001</code></pre><p> <img data-src="/images/pasted-601.png" alt="upload successful">  </p></li><li><p>运行Dockerfile<br> <code>docker build -t ykx_docker:1.6 .</code>   </p><p> <img data-src="/images/pasted-602.png" alt="upload successful">  </p></li><li><p>查看镜像  </p><p> <img data-src="/images/pasted-603.png" alt="upload successful">  </p></li><li><p>运行镜像<br> <code>docker run -d -p 6001:6001 489c48f4a13b</code>  </p><p> <img data-src="/images/pasted-604.png" alt="upload successful">  </p></li><li><p>成功访问微服务  </p><p> <img data-src="/images/pasted-605.png" alt="upload successful"></p></li></ol><h1 id="12-Docker-network"><a href="#12-Docker-network" class="headerlink" title="12.Docker network"></a>12.Docker network</h1><p> docker启动后，网络情况<br>会产生一个名为docker0的虚拟网桥  </p><p><img data-src="/images/pasted-606.png" alt="upload successful"><br>查看docker网络模式命令，默认创建3大网络模式。  </p><p><img data-src="/images/pasted-607.png" alt="upload successful">  </p><ul><li>查看网络<br><code>docker network ls</code></li><li>查看网络源数据<br><code>docker network inspect XXX网络名字</code>  </li><li>删除网络<br><code>docker network rm XXX网络名字</code></li></ul><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><p>容器间的互联和通信以及端口映射<br>容器IP变动时候可以通过服务名直接网络通信而不受到影响  </p><h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><p><img data-src="/images/pasted-608.png" alt="upload successful"><br>容器实例内默认网络IP生产规则  </p><p><img data-src="/images/pasted-610.png" alt="upload successful"><br>docker容器内部的ip是有可能会发生改变的  </p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><ul><li>docker network inspect bridge</li></ul><p><img data-src="/images/pasted-611.png" alt="upload successful">  </p><h2 id="bridge是什么？"><a href="#bridge是什么？" class="headerlink" title="bridge是什么？"></a>bridge是什么？</h2><p><img data-src="/images/pasted-612.png" alt="upload successful">  </p><p><img data-src="/images/pasted-615.png" alt="upload successful">  </p><p><img data-src="/images/pasted-614.png" alt="upload successful">  </p><h3 id="验证bridge"><a href="#验证bridge" class="headerlink" title="验证bridge"></a>验证bridge</h3><p>宿主机上有veth28-27\veth30-29<br>容器上有eth027-28\etho29-30<br>两两匹配，一一匹配<br><img data-src="/images/pasted-616.png" alt="upload successful">  </p><h2 id="host是什么？"><a href="#host是什么？" class="headerlink" title="host是什么？"></a>host是什么？</h2><p>容器将不会获得一个独立的Network Namespace， 而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡而是使用宿主机的IP和端口。</p><p><img data-src="/images/pasted-617.png" alt="upload successful">  </p><p><img data-src="/images/pasted-619.png" alt="upload successful">  </p><h2 id="none是什么？"><a href="#none是什么？" class="headerlink" title="none是什么？"></a>none是什么？</h2><p>在none模式下，并不为Docker容器进行任何网络配置。<br>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo需要我们自己为Docker容器添加网卡、配置IP等。</p><p><img data-src="/images/pasted-621.png" alt="upload successful">  </p><h2 id="container是什么？"><a href="#container是什么？" class="headerlink" title="container是什么？"></a>container是什么？</h2><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。  </p><p><img data-src="/images/pasted-623.png" alt="upload successful">  </p><p><img data-src="/images/pasted-624.png" alt="upload successful">  </p><p><img data-src="/images/pasted-625.png" alt="upload successful"><br>关闭alpine1，再看看alpine2</p><p><img data-src="/images/pasted-627.png" alt="upload successful">  </p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>传统的bridge模式，可以通过ip地址互相 ping共同  </p><p><img data-src="/images/pasted-628.png" alt="upload successful"><br>但是ping服务名是ping不同的</p><p><img data-src="/images/pasted-629.png" alt="upload successful"><br>但是实际情况下不可能用ip进行通信，因为ip一直会变更，必须用服务名ping  </p><blockquote><p>引入自定义网络能解决这个问题吗？  </p></blockquote><p><img data-src="/images/pasted-631.png" alt="upload successful">  </p><p>新建容器加入上一步新建的自定义网络<br><code>docker run -d -p 8081:8080 --network zzyy_network  --name tomcat81 billygoo/tomcat8-jdk8</code><br><code>docker run -d -p 8082:8080 --network zzyy_network  --name tomcat82 billygoo/tomcat8-jdk8</code>  </p><p><img data-src="/images/pasted-634.png" alt="upload successful"><br><strong>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）</strong>  </p><h1 id="13-Compose"><a href="#13-Compose" class="headerlink" title="13.Compose"></a>13.Compose</h1><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动&#x2F;关闭这些容器  </p><p><img data-src="/images/pasted-638.png" alt="upload successful">  </p><h2 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛?"></a>能干嘛?</h2><p> docker建议我们每一个容器中只运行一个服务,因为docker容器本身占用资源极少,所以最好是将每个服务单独的分割开来但是这样我们又面临了一个问题？</p><p>如果我需要同时部署好多个服务,难道要每个服务单独写Dockerfile然后在构建镜像,构建容器,这样累都累死了,所以docker官方给我们提供了docker-compose多服务部署的工具</p><p>例如要实现一个Web微服务项目，除了Web服务容器本身，往往还需要再加上后端的数据库mysql服务容器，redis服务器，注册中心eureka，甚至还包括负载均衡容器等等。。。。。。</p><p>Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。</p><p>官网：<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a><br>下载：<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a><br><code>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code><br><img data-src="/images/pasted-643.png" alt="upload successful"><br><code>chmod +x /usr/local/bin/docker-compose</code><br><code>docker-compose --version</code>  </p><p><img data-src="/images/pasted-648.png" alt="upload successful">  </p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>1+2<br>docker-compose.yml - 1<br>service  ·一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器  -2<br>project ·由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。-2  </p><h2 id="Compose使用的三个步骤"><a href="#Compose使用的三个步骤" class="headerlink" title="Compose使用的三个步骤"></a>Compose使用的三个步骤</h2><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><h2 id="Compose常用命令"><a href="#Compose常用命令" class="headerlink" title="Compose常用命令"></a>Compose常用命令</h2><p><img data-src="/images/pasted-664.png" alt="upload successful"><br>必须得在同一目录下执行  </p><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><ol><li>mvn package命令将微服务形成新的jar包 并上传到Linux服务器&#x2F;mydocker目录下    </li><li>编写Dockerfile文件构建镜像<br> docker build -t zzyy_docker:1.6 .<br> <img data-src="/images/pasted-654.png" alt="upload successful"></li></ol><h3 id="不用Compose编写"><a href="#不用Compose编写" class="headerlink" title="不用Compose编写"></a>不用Compose编写</h3><ol><li><p>运行mysql容器<br> <img data-src="/images/pasted-655.png" alt="upload successful">  </p></li><li><p>运行redis容器  </p><p> <img data-src="/images/pasted-656.png" alt="upload successful">  </p></li><li><p>启动微服务容器  </p><p> <img data-src="/images/pasted-657.png" alt="upload successful"></p></li></ol><blockquote><p>产生问题：<br>启动顺序是固定的<br>多个run命令<br>容器间的启停或宕机，有可能导致IP地址对应的容器实例变化，映射出错， 要么生产IP写死(可以但是不推荐)，要么通过服务调用  </p></blockquote><h3 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h3><p>编写docker-compose.yml </p><pre><code>    version: &quot;3&quot;    services:      microService:        image: zzyy_docker:1.6        container_name: ms01        ports:          - &quot;6001:6001&quot;        volumes:          - /app/microService:/data        networks:           - atguigu_net         depends_on:           - redis          - mysql      redis:        image: redis:6.0.8        ports:          - &quot;6379:6379&quot;        volumes:          - /app/redis/redis.conf:/etc/redis/redis.conf          - /app/redis/data:/data        networks:           - atguigu_net        command: redis-server /etc/redis/redis.conf      mysql:        image: mysql:5.7        environment:          MYSQL_ROOT_PASSWORD: &#39;123456&#39;          MYSQL_ALLOW_EMPTY_PASSWORD: &#39;no&#39;          MYSQL_DATABASE: &#39;db2021&#39;          MYSQL_USER: &#39;zzyy&#39;          MYSQL_PASSWORD: &#39;zzyy123&#39;        ports:           - &quot;3306:3306&quot;        volumes:           - /app/mysql/db:/var/lib/mysql           - /app/mysql/conf/my.cnf:/etc/my.cnf           - /app/mysql/init:/docker-entrypoint-initdb.d        networks:          - atguigu_net        command: --default-authentication-plugin=mysql_native_password #解决外部无法访问    networks:        atguigu_net: </code></pre><p><img data-src="/images/pasted-660.png" alt="upload successful"><br>将yml中ip地址修改为服务名  </p><p><img data-src="/images/pasted-661.png" alt="upload successful"><br>将修改后打包玩的jar包上传到服务器   </p><p><img data-src="/images/pasted-662.png" alt="upload successful"><br><code>docker build -t zzyy_docker:1.6 .</code><br>生成新的镜像文件  </p><p><img data-src="/images/pasted-663.png" alt="upload successful"><br><code>docker-compose up -d</code>  </p><h1 id="14-Portainer"><a href="#14-Portainer" class="headerlink" title="14. Portainer"></a>14. Portainer</h1><p><a href="https://www.portainer.io/">https://www.portainer.io/</a>   </p><p><a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a><br>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。<br>docker命令安装  <code>docker run -d -p 8000:8000 -p 9000:9000 --name portainer     --restart=always     -v /var/run/docker.sock:/var/run/docker.sock     -v portainer_data:/data     portainer/portainer</code>  </p><p>localhost:9000进入图形界面  </p><p><img data-src="/images/pasted-668.png" alt="upload successful"><br><code>docker system df</code>.<br><img data-src="/images/pasted-669.png" alt="upload successful">  </p><h1 id="15-CIG容器监控-CAdvisor-InfluxDB-Granfana"><a href="#15-CIG容器监控-CAdvisor-InfluxDB-Granfana" class="headerlink" title="15.CIG容器监控 CAdvisor+InfluxDB+Granfana"></a>15.CIG容器监控 CAdvisor+InfluxDB+Granfana</h1><p><code>docker stats</code>  </p><p><img data-src="/images/pasted-670.png" alt="upload successful">  </p><ul><li>问题</li></ul><p>通过<code>docker stats</code>命令可以很方便的看到当前宿主机上所有容器的CPU,内存以及网络流量等数据，一般小公司够用了。。。。</p><p>但是，<code>docker stats</code>统计结果只能是<code>当前宿主机</code>的全部容器，数据资料是<code>实时</code>的，没有地方存储、没有健康指标过线预警等功能</p><p><img data-src="/images/pasted-673.png" alt="upload successful"><br>CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表  </p><ul><li>CAdvisor<br><img data-src="/images/pasted-675.png" alt="upload successful">  </li><li>InfluxDB</li></ul><p><img data-src="/images/pasted-677.png" alt="upload successful">  </p><ul><li>Granfana</li></ul><p><img data-src="/images/pasted-678.png" alt="upload successful">  </p><h2 id="使用Compose编排CIG"><a href="#使用Compose编排CIG" class="headerlink" title="使用Compose编排CIG"></a>使用Compose编排CIG</h2><ol><li><p>新建cig文件夹<br> <img data-src="/images/pasted-679.png" alt="upload successful">  </p></li><li><p><code>vim docker-compose.yml</code>  </p><pre><code> version: &#39;3.1&#39; volumes:   grafana_data: &#123;&#125; services:  influxdb:   image: tutum/influxdb:0.9   restart: always   environment:     - PRE_CREATE_DB=cadvisor   ports:     - &quot;8083:8083&quot;     - &quot;8086:8086&quot;   volumes:     - ./data/influxdb:/data  cadvisor:   image: google/cadvisor   links:     - influxdb:influxsrv   command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086   restart: always   ports:     - &quot;8080:8080&quot;   volumes:     - /:/rootfs:ro     - /var/run:/var/run:rw     - /sys:/sys:ro     - /var/lib/docker/:/var/lib/docker:ro  grafana:   user: &quot;104&quot;   image: grafana/grafana   user: &quot;104&quot;   restart: always   links:     - influxdb:influxsrv   ports:     - &quot;3000:3000&quot;   volumes:     - grafana_data:/var/lib/grafana   environment:     - HTTP_USER=admin     - HTTP_PASS=admin     - INFLUXDB_HOST=influxsrv     - INFLUXDB_PORT=8086     - INFLUXDB_NAME=cadvisor     - INFLUXDB_USER=root     - INFLUXDB_PASS=root</code></pre><p> <code>docker-compose up</code></p></li></ol><p><img data-src="/images/pasted-681.png" alt="upload successful">  </p><p><img data-src="/images/pasted-682.png" alt="upload successful">  </p><ol start="3"><li><p>查看三个服务是否启动  </p><p> <img data-src="/images/pasted-683.png" alt="upload successful">  </p></li><li><p>浏览cAdvisor收集服务，<a href="http://ip:8080/">http://ip:8080/</a>  </p><p> <img data-src="/images/pasted-685.png" alt="upload successful">  </p></li><li><p>浏览influxdb存储服务，<a href="http://ip:8083/">http://ip:8083/</a></p></li><li><p>浏览grafana展现服务，<a href="http://ip:3000/">http://ip:3000</a><br> ip+3000端口的方式访问,默认帐户密码（admin&#x2F;admin）</p><p> <img data-src="/images/pasted-688.png" alt="upload successful"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了解决同志们友善的和运维相处，共建美好的地球村。鼠鼠写了一篇关于Docker的学习教程，也当成是自己日后使用方便翻阅的笔记。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>消息中间件RabbitMQ</title>
    <link href="https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/"/>
    <id>https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/</id>
    <published>2021-11-10T06:57:00.000Z</published>
    <updated>2022-11-10T12:32:13.225Z</updated>
    
    <content type="html"><![CDATA[<p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。<span id="more"></span></p><h1 id="1-为什么使用MQ"><a href="#1-为什么使用MQ" class="headerlink" title="1.为什么使用MQ"></a>1.为什么使用MQ</h1><ul><li>流量消峰</li></ul><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p><p><img data-src="/images/pasted-282.png" alt="upload successful">  </p><ul><li>应用解耦</li></ul><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><p><img data-src="/images/pasted-283.png" alt="upload successful">  </p><ul><li>异步处理</li></ul><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消 息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><p><img data-src="/images/pasted-284.png" alt="upload successful">  </p><h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>RabbitMQ 是一个消息中间件:它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它<code>不处理</code>快件而是<code>接收</code>， <code>存储</code>和<code>转发</code>消息数据。</p><p><img data-src="/images/pasted-285.png" alt="upload successful">  </p><h2 id="2-2-四大核心"><a href="#2-2-四大核心" class="headerlink" title="2.2 四大核心"></a>2.2 四大核心</h2><ul><li><p>生产者</p><p>  产生数据发送消息的程序是生产者</p></li><li><p>交换机</p><p>  交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自<code>生产者</code>的消息，另一方面它将消息 推送到<code>队列</code>中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到<code>特定队列</code>还是推 送到<code>多个队列</code>，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列</p><p>  队列是 RabbitMQ 内部使用的一种数据结构，尽管<code>消息</code>流经 RabbitMQ 和应用程序，但它们<code>只能存 储在队列</code>中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者  </p><p>  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><p><img data-src="/images/pasted-286.png" alt="upload successful">  </p><h2 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h2><p><img data-src="/images/pasted-287.png" alt="upload successful"><br>Broker:接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p><p>Virtual host:出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange&#x2F;queue 等  </p><p>Connection:publisher&#x2F;consumer 和 broker 之间的 TCP 连接<br>Channel:如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销  </p><p>Exchange:message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有:direct (point-to-point), topic (publish-subscribe) and fanout<br>(multicast)  </p><p>Queue:消息最终被送到这里等待 consumer 取走  </p><p>Binding:exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p><h2 id="2-4-常用命令"><a href="#2-4-常用命令" class="headerlink" title="2.4 常用命令"></a>2.4 常用命令</h2><p>添加开机启动 RabbitMQ 服务：<br>chkconfig rabbitmq-server on  </p><p>启动服务：<br>&#x2F;sbin&#x2F;service rabbitmq-server start  </p><p>查看服务状态：<br>&#x2F;sbin&#x2F;service rabbitmq-server status  </p><p><img data-src="/images/pasted-288.png" alt="upload successful"><br>停止服务(选择执行)：<br>&#x2F;sbin&#x2F;service rabbitmq-server stop  </p><p>开启 web 管理插件（启用前需要关闭RabbitMQ服务）：<br>rabbitmq-plugins enable rabbitmq_management</p><p>打开相应的后台管理界面<br><img data-src="/images/pasted-289.png" alt="upload successful">  </p><p><img data-src="/images/pasted-290.png" alt="upload successful"><br>此时还不能够登录  </p><blockquote><p>添加一个新的用户  </p></blockquote><p>创建账号<br>rabbitmqctl add_user admin 123<br>设置用户角色<br>rabbitmqctl set_user_tags admin administrator<br>设置用户权限<br>rabbitmqctl set_permissions -p “&#x2F;“ admin “.<em>“ “.</em>“ “.*”<br>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限<br>当前用户和角色<br>rabbitmqctl list_users</p><h1 id="3-HelloWorld"><a href="#3-HelloWorld" class="headerlink" title="3.HelloWorld"></a>3.HelloWorld</h1><p><img data-src="/images/pasted-292.png" alt="upload successful">  </p><p>pom</p><pre><code>&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;8&lt;/source&gt;                    &lt;target&gt;8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;            &lt;version&gt;5.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-io&lt;/groupId&gt;            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;            &lt;version&gt;2.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>整体架构  </p><p><img data-src="/images/pasted-293.png" alt="upload successful">  </p><h2 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h2><pre><code>public class Producer &#123;    //队列名称    public static final  String QUEUE_NAME = &quot;hello&quot;;    //发消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        //创建一个链接工厂        ConnectionFactory factory = new ConnectionFactory();        //工厂ip， 连接rabbitmq队列        factory.setHost(&quot;192.168.200.160&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123&quot;);        //创建链接        Connection connection = factory.newConnection();        //获取信道        Channel channel = connection.createChannel();        //创建一个队列        /**         * @param1:String queue:队列名称         * @param2:boolean durable:队列里的消息是否持久化在磁盘，默认情况存储在内存         * @param3：boolean exclusive：该队列是否只能让一个消费者消费，是否进行消息共享，true表示可以多个消费者消费，false表示不可以         * @param4:boolean autoDelete: 是都自动删除，最后一个消费者断开连接后，该队列是否自动删除         *         * @param5:Map&lt;String, Object&gt; arguments  :null         */        channel.queueDeclare(QUEUE_NAME , false , false , false , null);        //发消息        String message = &quot;hello world&quot;;        /**         * @param1:表示发送到哪个交换机         * @param2:路由的Key值是哪个，本次是队列的名称         * @param3:其他参数信息         * @param4:发送其他消息的消息体         */        channel.basicPublish(&quot;&quot; ,QUEUE_NAME , null , message.getBytes() );        System.out.println(&quot;消息发送完毕&quot;);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-294.png" alt="upload successful">  </p><h2 id="3-2-消费者"><a href="#3-2-消费者" class="headerlink" title="3.2 消费者"></a>3.2 消费者</h2><pre><code>public class Consumer &#123;    //队列的名称    public static final String QUEUE_NAME = &quot;hello&quot;;    //接受消息    public static void main(String[] args) throws IOException, TimeoutException &#123;        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;192.168.200.160&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123&quot;);        Connection connection = factory.newConnection();        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;            System.out.println(new String(message.getBody()));        &#125;;        CancelCallback cancelCallback = consumerTag -&gt; &#123;            System.out.println(&quot;消费消息被中断&quot;);        &#125;;        Channel channel = connection.createChannel();        /**         * 消费者消费消息         * @param1:消费那个队列         * @param2:消费成功后是否要自动应答，true表示自动应答，false表示手动应答         * @param3:消费者成功消费的回调         * @param4:消费者取消消费的回调         */        channel.basicConsume(QUEUE_NAME ,true, deliverCallback , cancelCallback);    &#125;&#125;</code></pre><p><img data-src="/images/pasted-295.png" alt="upload successful">  </p><h1 id="4-Work-Queues"><a href="#4-Work-Queues" class="headerlink" title="4.Work Queues"></a>4.Work Queues</h1><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。  </p><p><img data-src="/images/pasted-296.png" alt="upload successful"><br>因此RabbitMQ采用<code>轮询</code>的方式分发消息，防止任务处理多次  </p><h2 id="4-1搭建"><a href="#4-1搭建" class="headerlink" title="4.1搭建"></a>4.1搭建</h2><p><img data-src="/images/pasted-299.png" alt="upload successful">  </p><p>工具类</p><pre><code>public class RabbitMQUtils &#123;    public static Channel getChannel() throws Exception&#123;        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;192.168.200.160&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        return channel;    &#125;&#125;</code></pre><h3 id="4-11-消费者（C1-C2）"><a href="#4-11-消费者（C1-C2）" class="headerlink" title="4.11 消费者（C1\C2）"></a>4.11 消费者（C1\C2）</h3><pre><code>public class Work01 &#123;    public static final  String QUEUE_NAME = &quot;hello&quot;;    //接受消息    public static void main(String[] args) throws Exception &#123;        DeliverCallback deliverCallback = (consumerTag , message) -&gt; &#123;            System.out.println(&quot;接受到的消息&quot; + new String(message.getBody()));        &#125;;        //消息接收被取消时执行下面的内容        CancelCallback cancelCallback = (consumerTag)  -&gt; &#123;            System.out.println(consumerTag +&quot;消息者取消消费接口回调&quot;);        &#125;;        Channel channel = RabbitMQUtils.getChannel();        System.out.println(&quot;C2_等待接受消息....&quot;);        //消息的接收        channel.basicConsume(QUEUE_NAME,false,deliverCallback , cancelCallback);    &#125;&#125;</code></pre><h3 id="4-12-生产者"><a href="#4-12-生产者" class="headerlink" title="4.12 生产者"></a>4.12 生产者</h3><pre><code>public class Task01 &#123;    public static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        channel.queueDeclare(QUEUE_NAME,false,false , false ,null);        //从控制台接受信息        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null , message.getBytes());            System.out.println(&quot;发送消息完成&quot; + message);        &#125;    &#125;</code></pre><h3 id="4-13-测试"><a href="#4-13-测试" class="headerlink" title="4.13 测试"></a>4.13 测试</h3><p><img data-src="/images/pasted-297.png" alt="upload successful"></p><p><img data-src="/images/pasted-298.png" alt="upload successful"><br>成功完成多个线程工作消息只能处理一次，不能处理多次  </p><h2 id="4-2-消息应答"><a href="#4-2-消息应答" class="headerlink" title="4.2 消息应答"></a>4.2 消息应答</h2><h3 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1 概念"></a>4.2.1 概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p><blockquote><p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。  </p></blockquote><h3 id="4-2-2-自动应答"><a href="#4-2-2-自动应答" class="headerlink" title="4.2.2 自动应答"></a>4.2.2 自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<code>高吞吐量和数据传输安全性方面</code>做权 衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制， 当 然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</p><h3 id="4-2-3-手动应答"><a href="#4-2-3-手动应答" class="headerlink" title="4.2.3 手动应答"></a>4.2.3 手动应答</h3><p>A.Channel.basicAck(用于肯定确认)<br>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了<br>B.Channel.basicNack(用于否定确认)<br>C.Channel.basicReject(用于否定确认)<br>与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了</p><h3 id="4-2-4-Multiple"><a href="#4-2-4-Multiple" class="headerlink" title="4.2.4 Multiple"></a>4.2.4 Multiple</h3><p>手动应答的好处是可以批量应答并且减少网络拥堵  </p><p><img data-src="/images/pasted-300.png" alt="upload successful">  </p><blockquote><p>multiple 的 true 和 false 代表不同意思  </p></blockquote><p>true 代表批量应答 channel 上未应答的消息<br>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时  5-8 的这些还未应答的消息都会被确认收到消息应答<br>false 同上面相比  只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答    </p><p><img data-src="/images/pasted-301.png" alt="upload successful">  </p><h3 id="4-2-5-消息自动重新入队"><a href="#4-2-5-消息自动重新入队" class="headerlink" title="4.2.5 消息自动重新入队"></a>4.2.5 消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。  </p><p><img data-src="/images/pasted-302.png" alt="upload successful">  </p><h3 id="4-2-6-消息手动应答代码"><a href="#4-2-6-消息手动应答代码" class="headerlink" title="4.2.6 消息手动应答代码"></a>4.2.6 消息手动应答代码</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code>/** * Created on 2022/11/9. *  消息在手动应答时是不会消失的，放回队列中重新消费 * @author KaiXuan Yang */public class Task2 &#123;    public static final String task_queue_name = &quot;ack_queue&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        channel.queueDeclare(task_queue_name,false,false,false,null);        //从控制台输入信息        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;,task_queue_name , null,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息&quot;+message);        &#125;    &#125;&#125;</code></pre><h4 id="消费者（C1等待时间断）"><a href="#消费者（C1等待时间断）" class="headerlink" title="消费者（C1等待时间断）"></a>消费者（C1等待时间断）</h4><pre><code>/** * Created on 2021/11/9. *  消息在手动应答时不会丢失，放回队列重新消费 * @author KaiXuan Yang */public class Worker03 &#123;    public static final String task_queue_name = &quot;ack_queue&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        System.out.println(&quot;C1等待接收消息处理，事件较短&quot;);        DeliverCallback deliverCallback = ( consumerTag,  message) -&gt; &#123;            try &#123;                TimeUnit.SECONDS.sleep(1);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;接收到的消息：&quot;+ new String(message.getBody() , &quot;UTF-8&quot;));            /**             * @param1:消息的标记             * @param2:是否批量应答 false:不批量应答信道中的消息 true             */            channel.basicAck(message.getEnvelope().getDeliveryTag() , false);        &#125;;        boolean autoAck = false;        channel.basicConsume(task_queue_name , autoAck ,deliverCallback,(consumerTag -&gt; &#123;            System.out.println(&quot;消费者取消消费&quot;);        &#125;));    &#125;&#125;</code></pre><h4 id="消费者（C2等待时间长）"><a href="#消费者（C2等待时间长）" class="headerlink" title="消费者（C2等待时间长）"></a>消费者（C2等待时间长）</h4><pre><code>/** * Created on 2021/11/9. *  消息在手动应答时不会丢失，放回队列重新消费 * @author KaiXuan Yang */public class Worker04 &#123;    public static final String task_queue_name = &quot;ack_queue&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        System.out.println(&quot;C2等待接收消息处理，事件较短&quot;);        DeliverCallback deliverCallback = ( consumerTag,  message) -&gt; &#123;            try &#123;                TimeUnit.SECONDS.sleep(30);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;接收到的消息：&quot;+ new String(message.getBody() , &quot;UTF-8&quot;));            /**             * @param1:消息的标记             * @param2:是否批量应答 false:不批量应答信道中的消息 true             */            channel.basicAck(message.getEnvelope().getDeliveryTag() , false);        &#125;;        boolean autoAck = false;        channel.basicConsume(task_queue_name , autoAck ,deliverCallback,(consumerTag -&gt; &#123;            System.out.println(&quot;消费者取消消费&quot;);        &#125;));    &#125;&#125;</code></pre><p><img data-src="/images/pasted-303.png" alt="upload successful"><br>挂掉C2后，消息因为是手动应答并不会丢失，而是由C1消费消息。</p><p><img data-src="/images/pasted-304.png" alt="upload successful">  </p><h2 id="4-3-消息持久化"><a href="#4-3-消息持久化" class="headerlink" title="4.3 消息持久化"></a>4.3 消息持久化</h2><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事:我们需要将队列和消息都标 记为持久化。  </p><h3 id="4-3-1-队列实现持久化"><a href="#4-3-1-队列实现持久化" class="headerlink" title="4.3.1 队列实现持久化"></a>4.3.1 队列实现持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p><p><img data-src="/images/pasted-306.png" alt="upload successful">  </p><blockquote><p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新<br>创建一个持久化的队列，不然就会出现错误  </p></blockquote><p><img data-src="/images/pasted-305.png" alt="upload successful">  </p><h3 id="4-3-2-消息实现持久化"><a href="#4-3-2-消息实现持久化" class="headerlink" title="4.3.2 消息实现持久化"></a>4.3.2 消息实现持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添 加这个属性。<br>设置生产者发送消息为持久化消息，保存在磁盘上，不然保存在内存中<br><img data-src="/images/pasted-307.png" alt="upload successful"><br>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。  </p><h3 id="4-3-3-不公平分发"><a href="#4-3-3-不公平分发" class="headerlink" title="4.3.3 不公平分发"></a>4.3.3 不公平分发</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><blockquote><p>为了避免这种情况，我们可以设置参数 channel.basicQos(1);  </p></blockquote><pre><code>    channel.basicQos(1);        </code></pre><p><img data-src="/images/pasted-308.png" alt="upload successful">  </p><p><img data-src="/images/pasted-309.png" alt="upload successful"><br>此时处理快的C1处理更多的消费，充分利用能力  </p><h3 id="4-3-4-预取值"><a href="#4-3-4-预取值" class="headerlink" title="4.3.4 预取值"></a>4.3.4 预取值</h3><pre><code>        //设置不公平分发        int prefetchCount = 1;        //预取值//        int prefetchCount = 5;        channel.basicQos(prefetchCount);</code></pre><p><img data-src="/images/pasted-310.png" alt="upload successful">  </p><p><img data-src="/images/pasted-311.png" alt="upload successful"><br>设置预取值是为了<code>限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</code><br><code>该值定义通道上允许的未确认消息的最大数量</code>一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。</p><h1 id="5-发布确认"><a href="#5-发布确认" class="headerlink" title="5.发布确认"></a>5.发布确认</h1><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。<br>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。<br><img data-src="/images/pasted-312.png" alt="upload successful"><br>只进行1 ， 2两个步骤是不能保证消息进行持久化的，比如说步骤1持久化队列，步骤2进行消息的持久化的，在系统的时间间隔内，MQ就挂了，就不能保证消息能够持久化成功了<br>因此必须要进行<code>发布确认</code>才行  </p><pre><code>public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        //开启发布确认        channel.confirmSelect();        channel.queueDeclare(task_queue_name,false,false,false,null);        //从控制台输入信息        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;,task_queue_name , MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息&quot;+message);        &#125;    &#125;</code></pre><h2 id="5-1-效率对比"><a href="#5-1-效率对比" class="headerlink" title="5.1 效率对比"></a>5.1 效率对比</h2><h3 id="5-1-1-单个确认"><a href="#5-1-1-单个确认" class="headerlink" title="5.1.1 单个确认"></a>5.1.1 单个确认</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,<code>waitForConfirmsOrDie(long)</code>这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。<br>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p><pre><code>public class ConfirmMessage &#123;    //批量发送消息的个数    public static final int MESSAGE_COUNT = 1000;    public static void main(String[] args) throws Exception &#123;        ConfirmMessage.publishMessageIndividually();    &#125;    //单个确认    public static void publishMessageIndividually() throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        //队列的队名        String queueName = UUID.randomUUID().toString();        channel.queueDeclare(queueName ,false , false , false , null);        channel.confirmSelect();        //开始时间        long begin = System.currentTimeMillis();        for (int i = 0 ; i &lt; MESSAGE_COUNT ; i ++)&#123;            String message = i + &quot;&quot;;            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes() );            //单个消息马上进行发布确认            boolean flag = channel.waitForConfirms();            if (flag)&#123;                System.out.println(&quot;消息发送成功&quot;);            &#125;        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;消费时间：&quot; + (end - begin));    &#125;&#125;</code></pre><p><img data-src="/images/pasted-313.png" alt="upload successful">  </p><h3 id="5-1-2-批量确认"><a href="#5-1-2-批量确认" class="headerlink" title="5.1.2 批量确认"></a>5.1.2 批量确认</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个<code>批处理</code>保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是<code>同步</code>的，也一样阻塞消息的发布。</p><pre><code>public static void publicMessageBatch() throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        //队列的队名        String queueName = UUID.randomUUID().toString();        channel.queueDeclare(queueName ,false , false , false , null);        channel.confirmSelect();        //开始时间        long begin = System.currentTimeMillis();        //批量确认消息大小        int batchSize = 100;        for (int i = 0 ; i &lt; MESSAGE_COUNT ; i ++)&#123;            String message = i + &quot;&quot;;            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes() );            //判断达到了100条消息的时候批量确认一次            if(i % 100 == 0)&#123;                channel.waitForConfirms();            &#125;        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;消费时间：&quot; + (end - begin));    &#125;</code></pre><p>   <img data-src="/images/pasted-314.png" alt="upload successful">    </p><h3 id="5-1-3-异步批量确认"><a href="#5-1-3-异步批量确认" class="headerlink" title="5.1.3 异步批量确认"></a>5.1.3 异步批量确认</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。  </p><p><img data-src="/images/pasted-315.png" alt="upload successful">  </p><pre><code>//异步发布确认    public static void publishMessageAsync() throws Exception&#123;        Channel channel = RabbitMQUtils.getChannel();        //队列的队名        String queueName = UUID.randomUUID().toString();        channel.queueDeclare(queueName ,false , false , false , null);        channel.confirmSelect();        //开始时间        long begin = System.currentTimeMillis();        ConfirmCallback ackCallback = ( deliveryTag,  multiple) -&gt; &#123;            System.out.println(&quot;确认的消息：&quot; + deliveryTag);        &#125;;        /**         * @param1 : 消息的标记         * @param2 : 是否为批量确认         */        ConfirmCallback nackCallback = ( deliveryTag,  multiple) -&gt; &#123;            System.out.println(&quot;未确认的消息：&quot; + deliveryTag);        &#125;;        /**         *@param1 监听哪些消息成功         *@param2 哪些消息失败         */        //准备消息的监听器  监听哪些消息成功，哪些消息失败        channel.addConfirmListener(ackCallback , nackCallback); //异步通知        //批量发送信息        for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;            String message = &quot;消息&quot; + i;            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes());        &#125;        //结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;消费时间：&quot; + (end - begin));    &#125;</code></pre><p>可以得知 ，异步确认消息的效率是最快的</p><h3 id="5-1-4-如何处理异步未确认消息"><a href="#5-1-4-如何处理异步未确认消息" class="headerlink" title="5.1.4 如何处理异步未确认消息"></a>5.1.4 如何处理异步未确认消息</h3><p><img data-src="/images/pasted-316.png" alt="upload successful"><br>我们发现的问题是，以及发送完消息显示发送时间后，监听器任然监听到消息人发送完成的回调信息，如果此时消息发送失败我们该如何处理呢？<br>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。  </p><pre><code>//异步发布确认    public static void publishMessageAsync() throws Exception&#123;        Channel channel = RabbitMQUtils.getChannel();        //队列的队名        String queueName = UUID.randomUUID().toString();        channel.queueDeclare(queueName ,false , false , false , null);        channel.confirmSelect();        /**         * 线程安全有序的一个哈希表，适用于高并发的情况下关联发布线程和回调线程         * 1.轻松的将序号与消息进行关联         * 2.轻松的批量删除已经确认的消息         * 3.支持高并发         */        ConcurrentSkipListMap&lt;Long , String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;&gt;();        ConfirmCallback ackCallback = ( deliveryTag,  multiple) -&gt; &#123;            if (multiple)&#123;                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);                confirmed.clear();            &#125;else &#123;                outstandingConfirms.remove(deliveryTag);            &#125;            System.out.println(&quot;确认的消息：&quot; + deliveryTag);        &#125;;        ConfirmCallback nackCallback = ( deliveryTag,  multiple) -&gt; &#123;            System.out.println(&quot;未确认的消息：&quot; + deliveryTag);        &#125;;        channel.addConfirmListener(ackCallback , nackCallback); //异步通知        long begin = System.currentTimeMillis();        for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;            String message = &quot;消息&quot; + i;            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes());            //1.此处记录下所有要发送的消息  消息的总和            outstandingConfirms.put(channel.getNextPublishSeqNo() , message);        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;消费时间：&quot; + (end - begin));    &#125;</code></pre><h1 id="6-交换机"><a href="#6-交换机" class="headerlink" title="6.交换机"></a>6.交换机</h1><p><img data-src="/images/pasted-317.png" alt="upload successful"><br>先前的问题是，一个队列中的消息只能被消费一次，如果想要多次订阅呢？那就得用交换机，创造多个队列。  </p><h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h2><p>RabbitMQ 消息传递模型的核心思想是: <code>生产者生产的消息从不会直接发送到队列</code>。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。<br>相反，生产者<code>只能将消息发送到交换机(exchange)</code>，交换机工作的内容非常简单，一方面它<code>接收</code>来 自生产者的消息，另一方面将<code>它们推入队列</code>。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到<code>特定队列</code>还是说把他们到<code>许多队列</code>中还是说应该<code>丢弃</code>它们。这就的由交换机的<code>类型来决定</code>。</p><h2 id="6-2-交换机类型"><a href="#6-2-交换机类型" class="headerlink" title="6.2 交换机类型"></a>6.2 交换机类型</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p><h2 id="6-3-无名-exchange"><a href="#6-3-无名-exchange" class="headerlink" title="6.3 无名 exchange"></a>6.3 无名 exchange</h2><p><img data-src="/images/pasted-318.png" alt="upload successful"><br>第一个参数是交换机的名称。空字符串表示默认或无名称交换机:消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话  </p><h2 id="6-4-绑定"><a href="#6-4-绑定" class="headerlink" title="6.4 绑定"></a>6.4 绑定</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><p><img data-src="/images/pasted-319.png" alt="upload successful">  </p><h2 id="6-5-Fanout交换机"><a href="#6-5-Fanout交换机" class="headerlink" title="6.5 Fanout交换机"></a>6.5 Fanout交换机</h2><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<code>广播</code>到它知道的 <code>所有队列</code>中。系统中默认有些 exchange 类型。Fanout模式不会管routingKey，无论routingKey多少，直接把消息放松给所有绑定的队列  </p><p><img data-src="/images/pasted-320.png" alt="upload successful">  </p><p><img data-src="/images/pasted-321.png" alt="upload successful">  </p><h3 id="6-5-1-消费者"><a href="#6-5-1-消费者" class="headerlink" title="6.5.1 消费者"></a>6.5.1 消费者</h3><pre><code>public class ReceiveLogs02 &#123;    public static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        //声明一个交换机        channel.exchangeDeclare(EXCHANGE_NAME , &quot;fanout&quot;);        //声明一个队列 临时队列 队列名称是随机的        //当消费者断开连接后，队列删除        String queueName = channel.queueDeclare().getQueue();        /**         * 绑定交换机与队列         */        channel.queueBind(queueName , EXCHANGE_NAME , &quot;&quot;);        System.out.println(&quot;等待接受消息。。。&quot;);        DeliverCallback deliverCallback = (consumerTag,  message) -&gt; &#123;            System.out.println(&quot;控制台消息：&quot; + new String(message.getBody() , &quot;UTF-8&quot;));        &#125;;        channel.basicConsume(queueName , true ,deliverCallback ,consumerTag -&gt; &#123;&#125; );    &#125;&#125;</code></pre><h3 id="6-5-2-生产者"><a href="#6-5-2-生产者" class="headerlink" title="6.5.2 生产者"></a>6.5.2 生产者</h3><pre><code>public class EmitLog &#123;    //交换机的名称    public static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME ,&quot;fanout&quot;);        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(EXCHANGE_NAME , &quot;&quot; , null , message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产在发出消息：&quot; + message);        &#125;    &#125;&#125;</code></pre><h2 id="6-6-Direct交换机"><a href="#6-6-Direct交换机" class="headerlink" title="6.6 Direct交换机"></a>6.6 Direct交换机</h2><p>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p><p><img data-src="/images/pasted-322.png" alt="upload successful"><br>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.<br>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。<br>绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p><h3 id="6-6-1-生产者"><a href="#6-6-1-生产者" class="headerlink" title="6.6.1 生产者"></a>6.6.1 生产者</h3><pre><code>public class DirectLogs &#123;    //交换机的名称    public static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(EXCHANGE_NAME , &quot;error&quot; , null , message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产在发出消息：&quot; + message);        &#125;    &#125;&#125;</code></pre><h3 id="6-6-2-消费者"><a href="#6-6-2-消费者" class="headerlink" title="6.6.2 消费者"></a>6.6.2 消费者</h3><pre><code>public class ReceiveLogsDirect01 &#123;    public static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        //声明一个交换机        channel.exchangeDeclare(EXCHANGE_NAME , BuiltinExchangeType.DIRECT);        //声明一个队列        channel.queueDeclare(&quot;console&quot; , false , false , false , null);        //绑定队列和交换机        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME , &quot;info&quot;);        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME , &quot;warning&quot;);        //接受消息        DeliverCallback deliverCallback = (consumerTag,  message) -&gt; &#123;            System.out.println(&quot;ReceiveLogsDirect01：&quot; + new String(message.getBody() , &quot;UTF-8&quot;));        &#125;;        channel.basicConsume(&quot;console&quot; , true , deliverCallback , consumerTag -&gt; &#123;&#125;);    &#125;&#125;</code></pre><h2 id="6-7-Topic交换机"><a href="#6-7-Topic交换机" class="headerlink" title="6.7 Topic交换机"></a>6.7 Topic交换机</h2><p>尽管使用direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候 就只能使用 topic 类型</p><h3 id="6-7-1-Topic-的要求"><a href="#6-7-1-Topic-的要求" class="headerlink" title="6.7.1 Topic 的要求"></a>6.7.1 Topic 的要求</h3><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单 词列表，以点号分隔开。这些单词可以是任意单词，比如说:”stock.usd.nyse”,   “nyse.vmw”, “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p><blockquote><p>*(星号)可以代替一个单词<br>#(井号)可以替代零个或多个单词  </p></blockquote><p><img data-src="/images/pasted-323.png" alt="upload successful">  </p><h3 id="6-7-2-消费者"><a href="#6-7-2-消费者" class="headerlink" title="6.7.2 消费者"></a>6.7.2 消费者</h3><pre><code>public class ReceiveLogsTopic02 &#123;    //交换机名称    public static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME , BuiltinExchangeType.TOPIC);        channel.queueDeclare(&quot;Q2&quot; , false , false , false ,null);        channel.queueBind(&quot;Q2&quot; , EXCHANGE_NAME , &quot;lazy.#&quot;);        channel.queueBind(&quot;Q2&quot; , EXCHANGE_NAME , &quot;*.*.rabbit&quot;);        System.out.println(&quot;等待接受消息。。。&quot;);        DeliverCallback deliverCallback = (consumerTag , message) -&gt; &#123;            System.out.println(&quot;接收到的消息：&quot; + new String(message.getBody() , &quot;UTF_*&quot;));            System.out.println(&quot;接受队列：&quot; + &quot;Q2&quot; + &quot;绑定键：&quot; + message.getEnvelope().getRoutingKey());        &#125;;        channel.basicConsume(&quot;Q2&quot; , true ,deliverCallback ,consumerTag -&gt; &#123;&#125; );    &#125;    &#125;</code></pre><h3 id="6-7-3-生产者"><a href="#6-7-3-生产者" class="headerlink" title="6.7.3 生产者"></a>6.7.3 生产者</h3><pre><code>public class TopicExchangeOmit &#123;    public static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMQUtils.getChannel();        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext())&#123;            String message = scanner.next();            channel.basicPublish(EXCHANGE_NAME ,&quot;lazy.1&quot; ,null ,message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;消息已经发送&quot;);        &#125;    &#125;&#125;</code></pre><h1 id="7-死信队列"><a href="#7-死信队列" class="headerlink" title="7.死信队列"></a>7.死信队列</h1><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。<br>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效  </p><h2 id="7-1-来源"><a href="#7-1-来源" class="headerlink" title="7.1 来源"></a>7.1 来源</h2><p>消息 TTL 过期<br>队列达到最大长度(队列满了，无法再添加数据到 mq 中)<br>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LambdaQueryWrapper的理解</title>
    <link href="https://ykxzyp0517.cn/2021/10/04/LambdaQueryWrapper%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://ykxzyp0517.cn/2021/10/04/LambdaQueryWrapper%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-04T05:07:00.000Z</published>
    <updated>2022-11-02T13:36:54.765Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis-Plus QueryWrapper及LambdaQueryWrapper的使用。从使用的实际情况来解释为什么使用LambdaQueryWrapper而不使用QueryWrapper。</p><span id="more"></span><h1 id="QueryWrapper的弊端"><a href="#QueryWrapper的弊端" class="headerlink" title="QueryWrapper的弊端"></a>QueryWrapper的弊端</h1><p>假设数据库中存在user1表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user1</span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在使用mybatis-plus查询时，只需要编写pojo类，关联映射，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;email&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userEmail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持久层的mapper借口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">User1Mapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User1&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能进行查询操作，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LombokQueryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User1Mapper user1Mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        QueryWrapper&lt;User1&gt; user1QueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        user1QueryWrapper.eq(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        user1Mapper.selectOne(user1QueryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然很方便，但是这里需要注意一个问题：QueryWrapper中的eq、in等操作，第一个参数往往是列名！如果实际开发中表结构经常改变，岂不是涉及到变动的列名相关代码都需要改！！！！</p><h1 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h1><p>那么现在就变更表的列名。表结构如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">user_name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">user_age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">user_email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, user_name, user_age, user_email) <span class="keyword">VALUE</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>依旧还是编写pojo类，实现映射对应关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User2</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(value = &quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;user_age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;user_email&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userEmail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User2Mapper user2Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User2&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>();</span><br><span class="line">    queryWrapper.eq(User2::getUserName,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="type">User2</span> <span class="variable">users</span> <span class="operator">=</span> user2Mapper.selectOne(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的QueryWrapper和LambdaQueryWrapper，传递参数信息很容易发现：<br><strong>LambdaQueryWrapper的传参支持User2::getUserName语法！当表结构发生改变时，如@TableField(value &#x3D; “user_name”) 更改为 @TableField(value &#x3D; “name”)只要类的成员变量别名不变，就不会影响到程序结果的获取！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis-Plus QueryWrapper及LambdaQueryWrapper的使用。从使用的实际情况来解释为什么使用LambdaQueryWrapper而不使用QueryWrapper。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://ykxzyp0517.cn/2021/09/26/Take-Out-Software/"/>
    <id>https://ykxzyp0517.cn/2021/09/26/Take-Out-Software/</id>
    <published>2021-09-26T04:34:00.000Z</published>
    <updated>2022-10-31T05:51:36.607Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是阿里巴巴开源的基于 Java 的高性能RPC（一种远程调用） 分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，Dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有Dubbo这样的分布式服务框架的需求。</p><span id="more"></span><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h2><h3 id="1-什么是分布式系统？"><a href="#1-什么是分布式系统？" class="headerlink" title="1 什么是分布式系统？"></a>1 什么是分布式系统？</h3><p>将一个大系统分布成多个小功能的模块，数量庞大的小模块组成一个分布式系统。<br>分布式系统是若干独立计算机的集合， 这些计算机对于用户来说就是一个系统  </p><h3 id="2-发展演变"><a href="#2-发展演变" class="headerlink" title="2 发展演变"></a>2 发展演变</h3><p><img data-src="/images/pasted-116.png" alt="upload successful">    </p><p>单一应用架构：<br><img data-src="/images/pasted-117.png" alt="upload successful"><br><strong>不易扩展，不易协同开发</strong><br>垂直应用架构：<br>将大的单体的应用修改为多个<br><img data-src="/images/pasted-118.png" alt="upload successful"><br><strong>容易扩展，协同开发方便。<br>1.界面+业务逻辑的实现分离 2.应用不可能完全独立，大量的应用之间需要交互</strong><br>分布式服务架构：</p><p><img data-src="/images/pasted-119.png" alt="upload successful"><br>不同服务器之间的业务调用采用rpc（远程过程调用）<br>流动计算框架：  </p><p><img data-src="/images/pasted-120.png" alt="upload successful"><br>通过负载均衡控制流量的利用率。</p><p><em><strong>RPC框架原理</strong></em></p><p><img data-src="/images/pasted-121.png" alt="upload successful"><br>A\B服务器之间建立通信，通过socket链接，A服务器将所需调用方法和方法的参数发送B，B服务器接受到后调用方法，使用传输过来的参数并且将结果发送给A.</p><h1 id="二、Dubbo"><a href="#二、Dubbo" class="headerlink" title="二、Dubbo"></a>二、Dubbo</h1><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><h3 id="1-提供的服务"><a href="#1-提供的服务" class="headerlink" title="1.提供的服务"></a>1.提供的服务</h3><p><img data-src="/images/pasted-122.png" alt="upload successful"><br>例如当业务web需要使用业务服务器，业务服务器分布在多个服务器中，如何知道这些服务器，并且当这些服务器有问题时该如何解决？<br><strong>注册中心</strong>：将所有的服务都注册到注册中心中，出问题的服务器从注册中心中删除。如果订单想调用支付业务，rpc框架询问注册中心支付业务存在哪个服务器中，使用负载均衡的方式选择服务器。<br><strong>灰度发布</strong>：服务器升级时在部分服务器上先进行升级，随后再慢慢的升级到所有服务器上。</p><h3 id="2-Dubbo设计架构"><a href="#2-Dubbo设计架构" class="headerlink" title="2.Dubbo设计架构"></a>2.Dubbo设计架构</h3><p><img data-src="/images/pasted-123.png" alt="upload successful"><br>Registry(注册中心)<br>Provider(服务者）<br>Consumer(消费者）<br>Container(框架容器）<br>Monitor(监控中心）<br>服务启动流程：Dubbo启动后容器启动，服务提供者将自己提供的信息提供到注册中心中。消费者从注册中心中订阅需要的服务，如果服务提供者服务器出现变更，注册中心和消费者通过长连接的方式将变更通知给消费者。消费者可以调用服务者提供的服务，通过随机的负载均衡算法选择相应的服务器提供服务。每隔一段时间将内容交给监控器监控。</p><h3 id="3-Zookeeper-注册中心）"><a href="#3-Zookeeper-注册中心）" class="headerlink" title="3.Zookeeper(注册中心）"></a>3.Zookeeper(注册中心）</h3><p><img data-src="/images/pasted-124.png" alt="upload successful"></p><h3 id="4-Dubbo-Hello-world-Spring"><a href="#4-Dubbo-Hello-world-Spring" class="headerlink" title="4.Dubbo Hello world (Spring)"></a>4.Dubbo Hello world (Spring)</h3><p><img data-src="/images/pasted-125.png" alt="upload successful"><br>将公共接口，bean放入公共工程gmallinterface中<br>（1）将服务提供者注册到注册中心（暴露服务）<br>    1 导入dubbo依赖  </p><p><img data-src="/images/pasted-126.png" alt="upload successful"><br>    2 注册中心使用的是zookeeper,引入操作zookeeper的客户端（curator）  </p><p><img data-src="/images/pasted-127.png" alt="upload successful">  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    1，指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;user-service-provider&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    2. 指定注册中心的位置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    3. 指定通信规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4. 暴露服务，让其他人调用 ref:指向服务的真正实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.ykx.gmall.service.UserService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ykx.gmall.service.Impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成了对Provider的命名，以及将服务注册到注册中心的过程  </p><p><img data-src="/images/pasted-128.png" alt="upload successful">  </p><p>（2）服务消费者订阅服务提供者的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ykx.gmall.service.impl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;consumer-client-consum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    需要调用的远程服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.ykx.gmall.service.UserService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-Dubbo-Hello-world-Spring-Boot"><a href="#5-Dubbo-Hello-world-Spring-Boot" class="headerlink" title="5.Dubbo Hello world (Spring Boot)"></a>5.Dubbo Hello world (Spring Boot)</h3><p>引入dubbo依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-1Provider"><a href="#4-1Provider" class="headerlink" title="4.1Provider"></a>4.1Provider</h4><p>@Service注解表示Provider提供的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">//暴露服务</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl.....old...&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">UserAddress</span> <span class="variable">address1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">1</span>, <span class="string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;李老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="type">UserAddress</span> <span class="variable">address2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">2</span>, <span class="string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;王老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务的main函数上需要添加@EnableDubbo注解，开启基于注解的dubbo功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span> <span class="comment">//开启基于注解的dubbo功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootOrderApplicationProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootOrderApplicationProvider.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先spring项目的xml配置由properties代替  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.protocol</span>=<span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo.protocol.name</span>=<span class="string">dubbo</span></span><br><span class="line"><span class="attr">dubbo.protocol.port</span>=<span class="string">20880</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo.monitor.protocol</span>=<span class="string">registry</span></span><br></pre></td></tr></table></figure><h4 id="4-2Consumer"><a href="#4-2Consumer" class="headerlink" title="4.2Consumer"></a>4.2Consumer</h4><p>consumer<br>同provider引入dubbo的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原先spring项目的xml配置由properties代替</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">boot-consum-consumer</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">dubbo.registry.protocol</span>=<span class="string">registry</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><p>使用的服务@Reference注解自动消费服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">initOrder</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="comment">//1.查询用户的收货地址</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户id：&quot;</span>+userId);</span><br><span class="line">        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userId);</span><br><span class="line">        <span class="keyword">for</span> (UserAddress userAddress : userAddressList)&#123;</span><br><span class="line">            System.out.println(userAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userAddressList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意的是消费端的@Service只是javaBean的注册，服务器端的是提供服务</strong><br>启动服务的main函数上需要添加@EnableDubbo注解，开启基于注解的dubbo功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span> <span class="comment">//开启基于注解的dubbo功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootOrderApplicationProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootOrderApplicationProvider.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是需要一直保证注册中心zookeeper的开启状态，加入zookeeper没有开启会报错。</p><p><img data-src="/images/pasted-129.png" alt="upload successful">  </p><h2 id="6-Dubbo的配置文件"><a href="#6-Dubbo的配置文件" class="headerlink" title="6.Dubbo的配置文件"></a>6.Dubbo的配置文件</h2><p>Dubbo属性的覆盖策略</p><p><img data-src="/images/pasted-130.png" alt="upload successful"><br>JVM启动-D参数优先，优先级从上往下。其中xml配置&#x3D;&#x3D;application.properties</p><h2 id="7-启动时检查"><a href="#7-启动时检查" class="headerlink" title="7.启动时检查"></a>7.启动时检查</h2><p>check&#x3D;true会在启动时检查，确保服务提供中注册到了注册中心。<br>关闭某个服务的启动时检查（没有提供者时报错）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.ykx.BarService&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当前所有的服务的消费者都不进行检查  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:consume</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-超时-amp-覆盖配置关系-timeout"><a href="#8-超时-amp-覆盖配置关系-timeout" class="headerlink" title="8.超时&amp;覆盖配置关系-timeout"></a>8.超时&amp;覆盖配置关系-timeout</h2><p>timeout属性，如果方法超过设置时间没有返回就立即终止，避免线程大量阻塞。<br>provider设置4000ms的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title function_">getUserAddressList</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl.....old...&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">UserAddress</span> <span class="variable">address1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">1</span>, <span class="string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;李老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="type">UserAddress</span> <span class="variable">address2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserAddress</span>(<span class="number">2</span>, <span class="string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;王老师&quot;</span>, <span class="string">&quot;010-56253825&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>consumer端的reference的timeout属性为3000ms。默认采用1000ms.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.ykx.gmall.service.UserService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-131.png" alt="upload successful"><br>配置的覆盖关系：</p><p><img data-src="/images/pasted-132.png" alt="upload successful">  </p><h2 id="9-重试次数"><a href="#9-重试次数" class="headerlink" title="9.重试次数"></a>9.重试次数</h2><p>重试次数不包括第一次执行<br>只能在幂等操作上执行：查询、删除、修改<br>不能再非幂等操作上执行：新增  0 代表不重试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.ykx.gmall.service.UserService&quot;</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3000&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-本地存根"><a href="#10-本地存根" class="headerlink" title="10.本地存根"></a>10.本地存根</h2><h2 id="11-Springboot-和-Dubbo的整合"><a href="#11-Springboot-和-Dubbo的整合" class="headerlink" title="11.Springboot 和 Dubbo的整合"></a>11.Springboot 和 Dubbo的整合</h2><p>为了达到方法的精确进度，传统方法的整合配置怕是不太行</p><h3 id="方式1：dubbo-starter"><a href="#方式1：dubbo-starter" class="headerlink" title="方式1：dubbo-starter"></a>方式1：dubbo-starter</h3><p>导入dubbo-starter,在application.properties配置属性，使用@Service暴露服务，@Reference引用服务<br>在启动类使用@EnableDubbo</p><h3 id="方式2：dubbo-xml"><a href="#方式2：dubbo-xml" class="headerlink" title="方式2：dubbo xml"></a>方式2：dubbo xml</h3><p>保留dubbo xml配置文件<br>在启动类使用@ImportResource(“classpath:provider.xml”)</p><h3 id="方式3：注解api"><a href="#方式3：注解api" class="headerlink" title="方式3：注解api"></a>方式3：注解api</h3><p>将每一个组件手动创建在文件中  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDubboConfig</span> &#123;</span><br><span class="line"><span class="comment">//    &lt;dubbo:application name=&quot;consumer-client-consum&quot;&gt;&lt;/dubbo:application&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationConfig <span class="title function_">applicationConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">applicationConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">        applicationConfig.setName(<span class="string">&quot;boot-consum-consumer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RegistryConfig <span class="title function_">registryConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;127.0.0.1:2181&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ProtocolConfig <span class="title function_">protocolConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20882</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中每一个xml配置类的配置都可以用一个JavaConfig类配对。<br>最后在启动类上添加 @EnableDubbo注解  </p><h1 id="三、高可用"><a href="#三、高可用" class="headerlink" title="三、高可用"></a>三、高可用</h1><h2 id="1-zookeeper宕机与dubbo直连"><a href="#1-zookeeper宕机与dubbo直连" class="headerlink" title="1.zookeeper宕机与dubbo直连"></a>1.zookeeper宕机与dubbo直连</h2><p>当没有zookeeper注册中心可以使用dubbo直连的方式直接调用提供服务者的服务。因为注册中心只是保存了服务提供者的地址而已。<br><img data-src="/images/pasted-191.png" alt="upload successful"><br>当zookeeper注册中心宕机后可以使用本地缓存通讯继续使用服务。<br><img data-src="/images/pasted-192.png" alt="upload successful">  </p><h1 id="四、负载均衡策略"><a href="#四、负载均衡策略" class="headerlink" title="四、负载均衡策略"></a>四、负载均衡策略</h1><h2 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h2><p><img data-src="/images/pasted-193.png" alt="upload successful"><br>请求发送后根据权重调用随机一台服务器  </p><h2 id="RandomRobin-LoadBalance"><a href="#RandomRobin-LoadBalance" class="headerlink" title="RandomRobin LoadBalance"></a>RandomRobin LoadBalance</h2><p><img data-src="/images/pasted-194.png" alt="upload successful"><br>根据轮询方式的同时考虑权重  </p><h2 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h2><p><img data-src="/images/pasted-195.png" alt="upload successful"><br>在每次调用服务器前会查看上一次使用该服务器所用时间，总是选择处理最快的服务器  </p><h2 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h2><p><img data-src="/images/pasted-196.png" alt="upload successful"><br>如图，根据getUserId的一致性hash，相同的hash落在相同的服务器</p><h1 id="五、服务降级-动态调配服务器资源"><a href="#五、服务降级-动态调配服务器资源" class="headerlink" title="五、服务降级(动态调配服务器资源)"></a>五、服务降级(动态调配服务器资源)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种方式处理，从而释放服务器资源以保证核心交易正常运作或者高效运作。<br>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。  </p><ul><li>mock&#x3D;force:return+null 表示消费方对该服务的方法调用都直接返回null，不发起远程调用。<br><strong>屏蔽</strong><br><img data-src="/images/pasted-197.png" alt="upload successful"></li><li>mock&#x3D;fail:return+null 表示消费方对服务的方法调用失败(超时，调用失败)后，在返回null，不抛异常。<br><strong>容错</strong></li></ul><p><img data-src="/images/pasted-198.png" alt="upload successful">  </p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><ul><li>Failover Custer（默认）:失败自动切换，当出现失败，重试其他服务器。常用来读操作，但是重试会带来更长延迟，可通过retries&#x3D;”2”来设置重试次数  </li><li>Failfast Cluster：快速失败，只发起一次调用没失败立即报错。常用于非幂等性的写操作，如新增记录  </li><li>Failsafe Cluster：失败安全，出现异常时直接忽略。通常用于写入审计日志的操作  </li><li>Failback Cluster:失败自动回复，后台记录失败请求，定时重发。通常用于消息通知操作  </li><li>Forking Cluster:并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但是很浪费资源。</li><li>Broadcast Cluster: 广播调用所有提供者，逐个调用，任意一台报错则报错。</li></ul><h1 id="六、Dubbo原理"><a href="#六、Dubbo原理" class="headerlink" title="六、Dubbo原理"></a>六、Dubbo原理</h1><h2 id="Dubbo框架设计"><a href="#Dubbo框架设计" class="headerlink" title="Dubbo框架设计"></a>Dubbo框架设计</h2><p><img data-src="/images/pasted-199.png" alt="upload successful">  </p><ul><li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo是阿里巴巴开源的基于 Java 的高性能RPC（一种远程调用） 分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，Dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有Dubbo这样的分布式服务框架的需求。&lt;/p&gt;</summary>
    
    
    
    <category term="后端学习" scheme="https://ykxzyp0517.cn/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="微服务" scheme="https://ykxzyp0517.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis(Review)对Redis的重新理解</title>
    <link href="https://ykxzyp0517.cn/2021/09/22/Redis-Review/"/>
    <id>https://ykxzyp0517.cn/2021/09/22/Redis-Review/</id>
    <published>2021-09-22T14:42:00.000Z</published>
    <updated>2022-10-26T14:21:05.971Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。</p><span id="more"></span><h1 id="NoSql数据库"><a href="#NoSql数据库" class="headerlink" title="NoSql数据库"></a>NoSql数据库</h1><h2 id="1-1技术发展"><a href="#1-1技术发展" class="headerlink" title="1.1技术发展"></a>1.1技术发展</h2><h3 id="1-1-1-web1-0时代"><a href="#1-1-1-web1-0时代" class="headerlink" title="1.1.1 web1.0时代"></a>1.1.1 web1.0时代</h3><p>数据量访问有限，一台服务器对应一台数据库进行访问。<br>缺点：无法支撑大量的访问量<br><img data-src="/images/pasted-113.png" alt="upload successful">  </p><h4 id="1-1-2-解决cpu和内存的压力"><a href="#1-1-2-解决cpu和内存的压力" class="headerlink" title="1.1.2 解决cpu和内存的压力"></a>1.1.2 解决cpu和内存的压力</h4><p>设置服务器的集群，采用nginx进行负载均衡。<br>**Q:session该如何处理？第一次访问服务器1建立session对象，第二次访问服务器2时没有session对象 **  </p><p><img data-src="/images/pasted-114.png" alt="upload successful"><br>(1)将session处理在客户端cookie中，但是安全无法保证<br>(2)将session复制到每一台服务器中，但是造成了数据的冗余<br>(3)采用Nosql数据库中，优点：不需要进行io操作，可以直接存储在<strong>内存</strong>中，缓解来cpu和io的压力。  </p><p><img data-src="/images/pasted-115.png" alt="upload successful"><br>将频繁进行查询的数据放入缓存数据库进行存储。提高数据库的访问效率。  </p><h2 id="1-2-NoSql数据库"><a href="#1-2-NoSql数据库" class="headerlink" title="1.2 NoSql数据库"></a>1.2 NoSql数据库</h2><h3 id="1-2-1-NoSql数据库概述"><a href="#1-2-1-NoSql数据库概述" class="headerlink" title="1.2.1 NoSql数据库概述"></a>1.2.1 NoSql数据库概述</h3><p>NoSql(Not Only Sql)，泛指非关系型的数据库。以键值对key-value进行存储。  </p><ul><li>不遵循SQL的标准</li><li>不支持ACID </li><li>远超SQL的性能</li></ul><h3 id="1-2-2-NoSql适用场景"><a href="#1-2-2-NoSql适用场景" class="headerlink" title="1.2.2 NoSql适用场景"></a>1.2.2 NoSql适用场景</h3><ul><li>对海量数据的读写</li><li>对数据高并发的读写</li><li>对数据高可扩展性的</li></ul><h3 id="1-2-3-NoSql不适用场景"><a href="#1-2-3-NoSql不适用场景" class="headerlink" title="1.2.3 NoSql不适用场景"></a>1.2.3 NoSql不适用场景</h3><ul><li>需要事务的支持  </li><li>基于sql的结构化查询存储，处理复杂的关系</li></ul><h1 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h1><h2 id="2-1-REDIS-单线程-多路IO复用"><a href="#2-1-REDIS-单线程-多路IO复用" class="headerlink" title="2.1 REDIS 单线程 + 多路IO复用"></a>2.1 REDIS 单线程 + 多路IO复用</h2><p><img data-src="/images/pasted-133.png" alt="upload successful"><br>黄牛的买票过程是单线程操作，多路IO复用体现在用户没有拿到票的时候去做别的事情，充分利用cpu的性能。  </p><h2 id="2-2-五大基本数据类型"><a href="#2-2-五大基本数据类型" class="headerlink" title="2.2 五大基本数据类型"></a>2.2 五大基本数据类型</h2><h3 id="2-2-1-Key的操作"><a href="#2-2-1-Key的操作" class="headerlink" title="2.2.1 Key的操作"></a>2.2.1 Key的操作</h3><p>keys _ ：查看当前库的所有key<br>exists key：判断key是否存在<br>type key:查看key的类型<br>del key: 删除指定的key数据<br>unlink key：根据value选择非阻塞删除 <em>只是从keyspace元数据中删除，真正的删除会在后续异步操作</em><br>expire [key] [seconds] : 给定key设置过期时间<br>ttl [key] :查看还有多少秒过去，-1为永不过期，-2表示已经过期<br>select :切换数据库<br>dbsize：查看当前数据库的key的数量<br>flushdb：清空当前数据库<br>flushall:通杀全部库</p><h3 id="2-2-2-String"><a href="#2-2-2-String" class="headerlink" title="2.2.2 String"></a>2.2.2 String</h3><p>String 是redis最基本的数据类型，一个key对应一个value。<br>String是二进制安全的，意味着redis的string可以包含任何数据，一个redis的string可以存储512M的数据  </p><p>set [key][value]; 添加键值对<br>get [key]:查询键值对信息<br>append [key] [value] :追加信息<br>strlen [key] : 获取值的长度<br>setnx [key] [value] :只有在key不存在的时候才能够操作<br>incr [key] :加一<br>decr [key]: 减一<br>incrby&#x2F;decrby [key] [步长] 将key中储存的数字值增减，自定义步长<br>incr &#x2F; decr :原子操作，不会被线程调度机制打断的操作<br>这种操作一旦开始，就一直运行到结束，中间不会有任何的context switch<br>mset [key1][value1][k2][v2]… :同时设置多个key和value<br>mget [key1][k2]…:获取多个值<br>msetnx [k1][v1][k2][v2]… :有一个存在的话就设置失败<br>getrange [key][start][end]:获取值的范围<br>setrange [key][start][value] :用value覆盖[key]存吃的字符串值，从[start]开始<br>setex [key][seconds][value] : 设置值的时候同时设置过期时间  </p><h3 id="2-2-3-数据结构-简单动态字符串"><a href="#2-2-3-数据结构-简单动态字符串" class="headerlink" title="2.2.3 数据结构(简单动态字符串)"></a>2.2.3 数据结构(简单动态字符串)</h3><p>String 的数据结构为简单动态字符串 ，是可以修改的字符串，内部结构类似于java的Arraylist，采用预分配冗余空间的方式来减少内存的频繁分配。</p><p><img data-src="/images/pasted-135.png" alt="upload successful"><br>如图所示，实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现在的空间，如果超过1M时，扩容只会多扩容1M的空间。最大的长度为512M。  </p><h3 id="2-2-4-List"><a href="#2-2-4-List" class="headerlink" title="2.2.4 List"></a>2.2.4 List</h3><p>Redis列表简单的字符串列表，按照插入的顺序排序，你可以在列表的头部和尾部插入元素，底层其实是一个双向链表，对两边的操作性能很高，通过索引下标的操作中间的节点性能会比较差。  </p><p><img data-src="/images/pasted-136.png" alt="upload successful"><br>lpush&#x2F;rpush [key][v1][v2]…<br>lpop&#x2F;rpop [key]:从左边&#x2F;右边吐出一个值，值在键在，值亡人亡。<br>rpoplpush [k1][k2] ： 从列表k1右边吐出一个值，插到k2左边。<br>lrange：<br>lindex [key][index] : 从0开始往左取下标元素<br>llen [key] : 获取列表长度<br>linsert [key] [before | after] [pivot] [element]: 在某个元素的前面或者后面加入一个值<br>lrem: [key][count][value] :从左边删除几个value<br>lset [key][index][value] :将key下标位index的值替换为value</p><h3 id="2-2-5-数据结构-quickList"><a href="#2-2-5-数据结构-quickList" class="headerlink" title="2.2.5 数据结构(quickList)"></a>2.2.5 数据结构(quickList)</h3><p>当元素很少的时候，使用ziplist存储-&gt;ziplist是一块连续的存储空间。它将所有的元素紧挨在一起，分配的是一块连续的内存。  </p><p><img data-src="/images/pasted-137.png" alt="upload successful"><br>当数据量太多的时候才会改回quickList。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。<br>Redis将链表和ziplist结合起来构成了quickList。也就是讲多个ziplist使用双向指针串起来使用。  </p><h3 id="2-2-6-Set"><a href="#2-2-6-Set" class="headerlink" title="2.2.6 Set"></a>2.2.6 Set</h3><p>set能够自动排重，并且提供了判断某个成员是否在一个Set集合内的重要接口。<br>Redis的Set是String类型的无序集合。它底层其实是一个value为null的hash表。所有的添加删除查询的复杂度都是O（1）.  </p><p>sadd[key][v1][v2]  将一个或者多个元素加入集合key中<br>smembers [key]： 取出该集合的所有值<br>sismembers [key][value]:判断集合中是否存在value值<br>scard [key]:返回该集合的元素个数<br>screm[key][v1][v2]：删除集合中的某个元素<br>spop [key]:随机从该集合中吐出一个值,如果值都取完，那么集合也就删除。<br>srandmember[key][n]:随机取出n个值，不会从集合删除<br>smove [source][dest][value]:移动value<br>sinter[k1][k2]:返回交集<br>sunion[k1][k2]:返回并集<br>sdiff[k1][k2]返回两个集合的差集</p><h3 id="2-2-7-Hash"><a href="#2-2-7-Hash" class="headerlink" title="2.2.7 Hash"></a>2.2.7 Hash</h3><p>Redis Hash是一个键值对的集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合存储对象<br>hset[key][field][value] ：<br>hget[key][field] :<br>hmset[key][field1][value1][field2][value2]:批量设置hash的值<br>hexits[key][field]:查看hash中是否存在<br>hkeys[key]:查看该hash集合的所有的field<br>hvals[key] :查看hash集合的所有的value<br>hincrby[key][field][increment]:为hash表key中的filed的值加上增量<br>hsetnx [key][field][value]:添加数据，存在的话添加失败。</p><h3 id="2-2-8-数据结构"><a href="#2-2-8-数据结构" class="headerlink" title="2.2.8 数据结构"></a>2.2.8 数据结构</h3><p>Hash的数据结构是两种：ziplist , hashtable当field-value的长度较短且个数较少时使用ziplist,否则使用hashtable。  </p><h3 id="2-2-9-有序集合Zset"><a href="#2-2-9-有序集合Zset" class="headerlink" title="2.2.9 有序集合Zset"></a>2.2.9 有序集合Zset</h3><p>Zset是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个评分，这个score被用来按照从最低分到最高分的排列方式。评分是可以重复的，成员是唯一的。  </p><p>zadd[key][s1][v1][s2][v2]…:<br>zrange[key][start][end] [withscores]:<br>zrangebyscore [key][min][max]<br>ZINCRBY [key] [increment] [member]:<br>zcount [key] [min][max]:<br>zrank[key][value]:返回再集合中的排名</p><h3 id="2-2-10-数据结构"><a href="#2-2-10-数据结构" class="headerlink" title="2.2.10 数据结构"></a>2.2.10 数据结构</h3><p>底层采用两种数据结构：<br>（1）hash,hash的作用是在hash的field，value中存储value和score,保障元素value的唯一性，可以通过value查找到score值。<br>（2）跳跃表，在于给元素value排序，根据score的范围获取元素列表  </p><h3 id="2-2-11-Bitmaps"><a href="#2-2-11-Bitmaps" class="headerlink" title="2.2.11 Bitmaps"></a>2.2.11 Bitmaps</h3><p>bitmaps本身不是一种数据类型，实际上它就是字符串，但是它可以对字符串的位进行操作。<br>bitmaps单独提供了一套命令，所以在redis中使用bitmaps和使用字符串的方法不太相同，可以把bitmaps想象成一个以位为单位的数据，数组的每个单元只能存储0和1，数组的下标在bitmaps中叫做偏移量。</p><p><img data-src="/images/pasted-143.png" alt="upload successful"><br> setbit [key][offset][value]:<br> getbit [key][offset]:<br> bitcount [key][start end]:<br> bitop [operation][destkey][key][key2]:</p><p> 实例：每个独立用户是否访问过网站存放在bitmaps中，将访问过的用户记作1，没有访问的用户记作0，偏移量为用户的id。<br> 假设有20个用户，userid &#x3D; 1,6,11,15,19的用户对网站进行了访问，那么当前的bitmaps如图所示。</p><p><img data-src="/images/pasted-144.png" alt="upload successful">  </p><p><img data-src="/images/pasted-145.png" alt="upload successful">  </p><h3 id="2-2-12-HyperLogLog"><a href="#2-2-12-HyperLogLog" class="headerlink" title="2.2.12 HyperLogLog"></a>2.2.12 HyperLogLog</h3><p>解决基数问题的方案有很多，在数据库中采用DISTINCT COUNT来计算不重复个数，在Redis中使用hash ，set , bitmap等数据结构来存储，但是，随着数据的不断增加会导致占用空间越来越大，对于非常大的数据集而言不切实际。<br>能否降低一定的精度来平衡存储空间？<br>HyperLogLog是用来做基数统计的算法，在输入元素的数量体积非常庞大的时候，计算基数所需的空间总是固定的，并且非常小。<br>每个hyperLogLog键只要花费12kb的内存，就可以计算将近2^64个不同的基数。</p><h3 id="2-2-13-GEOspatial"><a href="#2-2-13-GEOspatial" class="headerlink" title="2.2.13 GEOspatial"></a>2.2.13 GEOspatial</h3><p>geoadd[key][经度][纬度][member]:<br>geopos [key] [member]:<br>gepdist[key][member1][member2] [m|km|ft|mi]:获取两个位置之间的直接距离<br>georadius[key][经度][纬度][radius][m|km|ft|mi]:以给定经纬度为中心，找出某一半径内的元素</p><h1 id="Redis发布和订阅"><a href="#Redis发布和订阅" class="headerlink" title="Redis发布和订阅"></a>Redis发布和订阅</h1><h2 id="3-1-什么是发布和订阅？"><a href="#3-1-什么是发布和订阅？" class="headerlink" title="3.1 什么是发布和订阅？"></a>3.1 什么是发布和订阅？</h2><p>redis发布和订阅是一种消息通信模式：发送者（pub）发送消息，订阅者(sub)接收消息。  </p><p><img data-src="/images/pasted-138.png" alt="upload successful"><br><strong>Redis客户端可以订阅任意数量的频道。</strong>  </p><p><img data-src="/images/pasted-139.png" alt="upload successful">  </p><h2 id="3-2发布订阅命令行的实现"><a href="#3-2发布订阅命令行的实现" class="headerlink" title="3.2发布订阅命令行的实现"></a>3.2发布订阅命令行的实现</h2><p>1.第一个客户端订阅channel1频道  </p><p><img data-src="/images/pasted-140.png" alt="upload successful"><br>2.第二个客户端向channel1发送信息  </p><p><img data-src="/images/pasted-141.png" alt="upload successful"><br>3.第一个客户端接收到信息  </p><p><img data-src="/images/pasted-142.png" alt="upload successful">  </p><h1 id="Jedis操作"><a href="#Jedis操作" class="headerlink" title="Jedis操作"></a>Jedis操作</h1><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="操作key"><a href="#操作key" class="headerlink" title="操作key"></a>操作key</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span> , <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        jedis.mset(<span class="string">&quot;k1&quot;</span> , <span class="string">&quot;v1&quot;</span> , <span class="string">&quot;k2&quot;</span> , <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        List&lt;String&gt; mget = jedis.mget(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : mget)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key: keys)&#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="操作list"><a href="#操作list" class="headerlink" title="操作list"></a>操作list</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;key1&quot;</span> , <span class="string">&quot;lucy&quot;</span>,<span class="string">&quot;mary&quot;</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        List&lt;String&gt; key1 = jedis.lrange(<span class="string">&quot;key1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name :key1)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">## 操作Set</span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;names&quot;</span> , <span class="string">&quot;jack&quot;</span> , <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; name = jedis.smembers(<span class="string">&quot;names&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="操作hash"><a href="#操作hash" class="headerlink" title="操作hash"></a>操作hash</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;hname&quot;</span> , <span class="string">&quot;age&quot;</span> , <span class="string">&quot;20&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hget</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;hname&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(hget);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="操作Zset"><a href="#操作Zset" class="headerlink" title="操作Zset"></a>操作Zset</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;china&quot;</span>,<span class="number">100d</span>,<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">        List&lt;String&gt; china = jedis.zrange(<span class="string">&quot;china&quot;</span>, <span class="number">0</span>, (<span class="type">long</span>) <span class="number">100d</span>);</span><br><span class="line">        <span class="keyword">for</span> (String n : china)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a>完成一个手机验证码功能</h1><p> 要求：1.输入手机号，点击发送一条随机的6位数验证码(random)，2分钟有效(ttl)<br> 2.输入验证码，点击验证，返回成功或失败<br> 3.每个手机号每天只能输入3次（incr）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        verifyCode(&quot;13812272897&quot;);</span></span><br><span class="line"></span><br><span class="line">        getRedisCode(<span class="string">&quot;13812272897&quot;</span>,<span class="string">&quot;528407&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.生成6位数验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rand</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line">            code += rand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.每个手机每天只能发送3次，验证码放在redis中，设置过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">verifyCode</span><span class="params">(String phone)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链接redis</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//拼接key</span></span><br><span class="line">        <span class="comment">//手机发送次数key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">countKey</span> <span class="operator">=</span> <span class="string">&quot;VerifyCode&quot;</span> + phone+<span class="string">&quot;phone:&quot;</span>;</span><br><span class="line">        <span class="comment">//验证码key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">codeKey</span> <span class="operator">=</span> <span class="string">&quot;VerifyCode&quot;</span> + phone + <span class="string">&quot;code:&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">count</span> <span class="operator">=</span> jedis.get(countKey);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.setex(countKey , <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> , <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            jedis.incr(count);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不能再进行发送了&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送的验证码要放在redis中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code1</span> <span class="operator">=</span> getCode();</span><br><span class="line">        jedis.setex(codeKey , <span class="number">120</span> ,code1);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.校验</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getRedisCode</span><span class="params">(String phone , String code)</span>&#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.160&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">codeKey</span> <span class="operator">=</span> <span class="string">&quot;VerifyCode&quot;</span> + phone +<span class="string">&quot;code:&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jedisCode</span> <span class="operator">=</span> jedis.get(codeKey);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(jedisCode)) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;验证成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="Redis与SpringBoot的整合"><a href="#Redis与SpringBoot的整合" class="headerlink" title="Redis与SpringBoot的整合"></a>Redis与SpringBoot的整合</h1><p>redis配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1800000</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>redisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span> , <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis事务、锁"><a href="#Redis事务、锁" class="headerlink" title="Redis事务、锁"></a>Redis事务、锁</h1><h2 id="4-1-redis事务"><a href="#4-1-redis事务" class="headerlink" title="4.1 redis事务"></a>4.1 redis事务</h2><h3 id="4-1-1-事务的定义"><a href="#4-1-1-事务的定义" class="headerlink" title="4.1.1 事务的定义"></a>4.1.1 事务的定义</h3><p>redis事务是一个单独的隔离操作：事务中的所有命令都会序列化，按顺序的执行。事务在执行过程中，不会被其他客户端发送来的请求所打断。  </p><h3 id="4-1-2-Multi-x2F-Exec-x2F-Discard"><a href="#4-1-2-Multi-x2F-Exec-x2F-Discard" class="headerlink" title="4.1.2 Multi&#x2F;Exec&#x2F;Discard"></a>4.1.2 Multi&#x2F;Exec&#x2F;Discard</h3><p>输入multi命令开始，输入的命令都会一次进入命令队列中，但不会执行，知道输入exec后，redis会将之前的命令队列中的命令依次执行。<br>组队过程中可以用discard放弃组队。</p><p><img data-src="/images/pasted-146.png" alt="upload successful">  </p><h3 id="4-1-3-事务的错误处理"><a href="#4-1-3-事务的错误处理" class="headerlink" title="4.1.3 事务的错误处理"></a>4.1.3 事务的错误处理</h3><p>组队的过程中某个命令出错，执行时整个队列都会被取消。  </p><p><img data-src="/images/pasted-147.png" alt="upload successful">  </p><p><img data-src="/images/pasted-148.png" alt="upload successful"><br>组队没有失败，只有在执行的过程中失败，只有错误的队列不会执行成功，其他的命令都会执行不会回滚。</p><p><img data-src="/images/pasted-150.png" alt="upload successful"><br><img data-src="/images/pasted-149.png" alt="upload successful">  </p><h3 id="4-1-4-事务冲突问题"><a href="#4-1-4-事务冲突问题" class="headerlink" title="4.1.4 事务冲突问题"></a>4.1.4 事务冲突问题</h3><p><img data-src="/images/pasted-151.png" alt="upload successful">  </p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>每次操作之前进行上锁，上锁后其他用户不能够操作，别人为阻塞状态，修改完后才释放锁。</p><p><img data-src="/images/pasted-152.png" alt="upload successful">  </p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>给数据加上版本号，每次用户修改数据内容的同时更新版本号</p><p><img data-src="/images/pasted-153.png" alt="upload successful"><br>每次去拿数据都认为别人不会修改，所以不会上锁，但是在更新时会判断在此期间有没有别人修改过这些数据，可以使用版本号机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p><h3 id="乐观锁的使用-WATCH-key-x2F-UNWATCH-key"><a href="#乐观锁的使用-WATCH-key-x2F-UNWATCH-key" class="headerlink" title="乐观锁的使用-WATCH[key] &#x2F; UNWATCH [key]"></a>乐观锁的使用-WATCH[key] &#x2F; UNWATCH [key]</h3><p>在执行multi之前，先执行watch[key] ,可以监视一个或者多个key，如果在事务执行之前这个key被其他命令修改，那么事务将被打断。</p><h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ul><li>单独的隔离操作，事务中的命令都会序列化，按顺序执行。事务在执行的过程中不会被其他客户端发送的命令打断。</li><li>没有隔离级别的概念</li><li>不保证原子性</li></ul><h1 id="Redis持久化-RDB"><a href="#Redis持久化-RDB" class="headerlink" title="Redis持久化-RDB"></a>Redis持久化-RDB</h1><h2 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h2><p>在指定的时间间隔内将内存中的数据集快照写入硬盘中。  </p><h2 id="RDB如何进行备份"><a href="#RDB如何进行备份" class="headerlink" title="RDB如何进行备份"></a>RDB如何进行备份</h2><p>Redis会创建一个子进程来进行持久化，会将数据写入到一个临时文件中，当持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程不进行任何IO操作。</p><p><img data-src="/images/pasted-156.png" alt="upload successful"><br>采用”写时复制技术“，先将所有内存的内容同步到临时文件中，同步完成后再将数据同步到dump.rdb中，以此来保证数据的完整性。<br>只适合大规模的数据恢复，在对数据完整性要求不大的情况下可以使用，但是需要膨胀两倍的空间，因为需要先同步到临时文件中。  </p><h1 id="Redis持久化-AOF"><a href="#Redis持久化-AOF" class="headerlink" title="Redis持久化-AOF"></a>Redis持久化-AOF</h1><h2 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h2><p>AOF以日志的形式来记录每个写操作,将Redis中执行过的所有写的指令记录下来（读操作不记录）。  </p><h2 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h2><p>可以在配置文件中配置，</p><p><img data-src="/images/pasted-158.png" alt="upload successful"><br>appendonly yes设置开启aof  </p><h2 id="AOF同步频率"><a href="#AOF同步频率" class="headerlink" title="AOF同步频率"></a>AOF同步频率</h2><ul><li>appendfsync always  始终同步，每次写入都会立刻计入日志，性能较差但完整性好  </li><li>appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失  </li><li>appendfsync no redis不主动同步，同步时机交给操作系统</li></ul><h2 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h2><p>aof采用文件追加的方式，文件会越来越大，为了避免这个情况，新增了重写机制，当aof的大小超过阈值，就会启动aof的内容压缩，只保留可以会回复数据的最小指令集，可以使用命令 bgrewriteaof<br>aof文件持续增长而过大时，会fork一个新的进程来讲文件重写，文件大于64M的100%（128M）才会触发重写机制。</p><p><img data-src="/images/pasted-159.png" alt="upload successful">  </p><p><img data-src="/images/pasted-160.png" alt="upload successful"><br>备份机制更加稳健，丢失数据概率更低。可以处理一下误操作。<br>但是比rdb占用更多的空间，并且备份恢复速度慢，每次写操作都追加文件增大了内存压力  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>最好两个都启用<br>如果对数据不敏感用rdb<br>不建议单独使用aof 因为会有bug<br>如果只是纯内存缓存，可以都不用</strong>  </p><p><img data-src="/images/pasted-162.png" alt="upload successful">  </p><p><img data-src="/images/pasted-163.png" alt="upload successful">  </p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>主机的数据更新后根据配置和策略，自动同步到备机的master&#x2F;slave机制，Master以写为主，Slave以读为主<br>一主多从图示：<br><img data-src="/images/pasted-164.png" alt="upload successful">  </p><ul><li>1.读写分离  </li><li>2.容灾的快速回复，一台从服务器down了后能快速切换到另一台从服务器</li></ul><h2 id="搭建基本的主从服务器"><a href="#搭建基本的主从服务器" class="headerlink" title="搭建基本的主从服务器"></a>搭建基本的主从服务器</h2><ul><li>1.创建&#x2F;myredis文件夹</li><li>2.复制redis.conf文件到文件夹中</li><li>3.启动3台端口号分别为6379 ， 6380 ， 6381的redis服务</li></ul><p><img data-src="/images/pasted-165.png" alt="upload successful"><br>使用命令 INFO replication 查看当前服务器是否是master  </p><p><img data-src="/images/pasted-166.png" alt="upload successful">  </p><ul><li>4.在从机上执行slaveof [主机ip] [端口号]</li></ul><p><img data-src="/images/pasted-167.png" alt="upload successful">  </p><p><img data-src="/images/pasted-168.png" alt="upload successful"><br>此时主机状态： </p><p><img data-src="/images/pasted-169.png" alt="upload successful">  </p><p><strong>当其中的从服务器挂掉后，从服务器重新启动是以master的身份重启的，不会自动恢复slave的角色。</strong><br><strong>但是从服务器重新连接主服务器后，从服务器会从头开始复制主服务器的内容。</strong><br><strong>主服务器挂掉后，从服务器仍然是从服务器。主服务器挂掉重启后，依然是主服务器。</strong>  </p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>1.从服务器连接上主服务器之后，从服务器向主服务器发送进行数据同步消息。<br>2.主服务器接受到从服务器发送过来的同步信息，把主服务器数据进行持久化，rdb文件，把rdb文件发送给从服务器，从服务拿到rdb进行读取<br>3.每次主服务器进行写操作后，和从服务器进行数据的同步。<br><strong>从服务器只在第一次连接时主要发起同步请求</strong>  </p><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img data-src="/images/pasted-170.png" alt="upload successful"><br>从服务器下面挂载另一个从服务器<br>反客为主 - 当主服务器down了以后，从服务器重当主服务器  slaveof no one<br><strong>缺点是需要手动完成</strong>  </p><h1 id="哨兵模式-反客为主的自动版"><a href="#哨兵模式-反客为主的自动版" class="headerlink" title="哨兵模式 -反客为主的自动版"></a>哨兵模式 -反客为主的自动版</h1><p><img data-src="/images/pasted-171.png" alt="upload successful">  </p><ul><li>1.自定义的&#x2F;myredis目录下新建sentinel.conf文件，名字绝对不能错！  </li><li>2.sentinel monitor mymaster 127.0.0.1 6379 1  其中mymaster为监控对象的服务器别名，1为至少多少个哨兵同意迁移的数量。  </li><li>3.启动哨兵模式 redis-sentinel &#x2F;myredis&#x2F;sentinel.conf</li></ul><p><img data-src="/images/pasted-172.png" alt="upload successful">  </p><p><img data-src="/images/pasted-173.png" alt="upload successful">  </p><ul><li>4.主服务器挂掉后，会推举一个从服务器为新的主服务器，当主服务器恢复后，变成从服务器。</li></ul><p>会产生复制延迟的问题：因为所有的操作都是在主服务器上操作，所以主服务器同步到从服务器需要时间。<br>选举规则： </p><ul><li>优先级靠前的优先选举  优先级在redis.conf中默认，replica-priority&#x3D;100 ,值越小优先级越高 （600行左右）</li><li>偏移量最小 谁和主服务器的数据同步最高</li><li>选择runid最小的从服务</li></ul><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="容量不够-，-并发写操作"><a href="#容量不够-，-并发写操作" class="headerlink" title="容量不够 ， 并发写操作"></a>容量不够 ， 并发写操作</h2><p>无中心化集群  </p><p><img data-src="/images/pasted-174.png" alt="upload successful">  </p><h2 id="什么是集群？"><a href="#什么是集群？" class="headerlink" title="什么是集群？"></a>什么是集群？</h2><p>redis集群实现了对redis的水平扩容，启动N个节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N<br>redis集群通过分区来提供一定的可用性，及时集群中有一部分节点失效，集群也可以继续处理命令。  </p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>在redis.conf中加入</p><p><img data-src="/images/pasted-175.png" alt="upload successful"><br>启动6台服务器，组成6节点的集群  </p><p><img data-src="/images/pasted-176.png" alt="upload successful"><br>启动后确保每台服务的node文件能够生成  </p><p><img data-src="/images/pasted-177.png" alt="upload successful"><br>在redis的src目录下执行命令 ： redis-cli –cluster create –cluster-replicas 1 192.168.200.160:6379 192.168.200.160:6380 192.168.200.160:6381 192.168.200.160:6389 192.168.200.160:6390 192.168.200.160:6391</p><p>–replicas 1 采用最简单的方式配置集群：一台主机，一台从机，正好三组。<br>此处为模拟的效果，在实际中每个ip为一个独立ip的服务器地址  </p><p>采用集群方式连接redis服务器  redis-cli -c -p 6379<br>-c 代表采用集群方式连接，可以采用任何一个端口  </p><p>cluster nodes 查看集群信息</p><p>分配原则：尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在同一个IP地址。</p><p><img data-src="/images/pasted-178.png" alt="upload successful"><br>这样才能保证集成的高可用性  </p><h2 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h2><p>一个redis集群会包含16384个插槽（0-16383），数据库添加值set k1 v1 ,redis会计算键值k1所在的插槽，在插槽位置加入数据。  </p><p><img data-src="/images/pasted-179.png" alt="upload successful"><br>目的是将值平均分摊到每台子服务器上。  </p><p><strong>插入单个数据</strong><br><img data-src="/images/pasted-180.png" alt="upload successful"><br>选择12706插槽插入数据<br><strong>插入多个数据</strong></p><p><img data-src="/images/pasted-181.png" alt="upload successful"><br>没有办法一次性插入多个值，但是可以通过组的方式进行插入。  </p><p><img data-src="/images/pasted-182.png" alt="upload successful"><br>user是组的名字，根据user的插槽进行插入  </p><h2 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h2><p><img data-src="/images/pasted-183.png" alt="upload successful"><br>通过上述操作为什么看不到插槽中先前插入的值？<br>因为k1在先前的插槽计算中插入在6381端口服务器的插槽中，而我们使用的是6380端口的redis服务器，所以看不到 <strong>redis只能看到自己服务器插槽范围内的值</strong>  </p><h2 id="故障恢复特点"><a href="#故障恢复特点" class="headerlink" title="故障恢复特点"></a>故障恢复特点</h2><p><img data-src="/images/pasted-184.png" alt="upload successful"><br>当主机挂了后，从机会变成主机替代服务，如果主机回复后会变成从机。  </p><p><img data-src="/images/pasted-186.png" alt="upload successful"></p><h2 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.200.160&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostAndPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行操作</span></span><br><span class="line">        jedisCluster.set(<span class="string">&quot;b1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        jedisCluster.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D; redis-cli -c -p 6379<br>从一个端口连接集群  </p><h1 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>现象 ：  </p><ul><li>1.应用服务器压力突然增大  </li><li>2.redis的命中率降低，一直无法在缓存中查询到数据</li><li>3.一直查询数据库，造成数据库压力急剧增加</li></ul><p><img data-src="/images/pasted-187.png" alt="upload successful"><br>造成原因：  </p><ul><li>1.redis查询不到数据  </li><li>2.出现很多非正常的url访问</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>1.对空值进行缓存<br>如果一个查询的返回数据为空，任然进行缓存，设置空结果的ttl很短，最长不超过5分钟</li><li>2.设置可访问的名单（白名单）<br>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里的id进行比较，如果访问不在bitmaps中，进行拦截。  </li><li>3.采用布隆过滤器  </li><li>4.进行实时监控<br>当检测到redis的命中率开始急剧下降，将访问设置为黑名单。</li></ul><p>总的来说就是为了让访问工具被拦截在服务器外。  </p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>现象：  </p><ul><li>1.数据库访问压力瞬间增加  </li><li>2.redis中的key并没有大量过期</li><li>3.redis正常运行</li></ul><p><img data-src="/images/pasted-188.png" alt="upload successful"><br>造成原因：  </p><ul><li>1.redis某个key过期了，大量的访问用了这个key</li></ul><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>1.预先设置热门数据，加大热门数据的时长  </li><li>2.实时调整<br>现场监控哪些数据热门，实时调整key的过期时长  </li><li>3.使用锁</li></ul><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><p>现象：  </p><ul><li>1.数据库压力变大导致服务器崩溃  在极少时间段内，查询大量key的集中过期情况<br>造成大量的查询压力都给了数据库</li></ul><p><img data-src="/images/pasted-189.png" alt="upload successful">  </p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>1.构建多级缓存架构：nginx缓存 + redis缓存 + 其他缓存</li><li>2.设置锁  </li><li>3.设置过期标志更新缓存<br>记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存  </li><li>4.将失效时间分散开<br>在原有的失效时间上随机增加一值，这样每一个缓存的过期时间重复率就会降低，很难发生集体失效的事件</li></ul><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在一个分布式集群系统中，由于分布式系统多线程多进程并且分布在不同的机器上，这使单机器部署的并发控制锁策略失效，单纯的javaAPI并不能提供分布式锁的能力。因此需要分布式锁。<br>分布式锁实现的主流方式 ：<br>1.redis<br>2.数据库<br>3.zookeeper  </p><p>用setnx进行解决  ， setnx k1 v1 （”locl”）等于分布式锁<br>del k1 (“unlock”)释放锁<br>万一一直setnx后，相当于别人就无法获得锁该怎么办<br>给key设置过期时间，超时后自动释放锁<br><strong>上锁后突然出现异常，无法设置过期时间该怎么办？</strong><br>上锁时同时设置过期时间就可以了<br><strong>set users 10 nx ex 12</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span> , ++num);</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                testLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="锁释放问题（UUID防止误删）"><a href="#锁释放问题（UUID防止误删）" class="headerlink" title="锁释放问题（UUID防止误删）"></a>锁释放问题（UUID防止误删）</h2><p>可能会产生的问题是：自己的锁被别人给释放了  </p><p><img data-src="/images/pasted-190.png" alt="upload successful"><br>a上锁后服务器卡顿超过ttl后自动释放本地的锁，那么b就能获取到锁，b在执行操作的过程中a恢复服务后最后需要释放一个锁，这时就会将b的锁释放，这显然是不对的。  </p><p>因此需要对每一个lock设置一个uuid唯一值，用uuid做判断。  </p><ul><li>1.uuid表示不同的服务器操作  set lock uuid nx ex 10</li><li>2.释放锁时候，首先判断当前uuid和要释放锁的uuid是否一样  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (lock)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span> , ++num);</span><br><span class="line">            <span class="type">String</span> <span class="variable">lockUuid</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (uuid.equals(lockUuid))&#123;</span><br><span class="line">                redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                testLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>netty网络编程</title>
    <link href="https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-09-02T05:11:00.000Z</published>
    <updated>2022-10-26T14:20:20.448Z</updated>
    
    <content type="html"><![CDATA[<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.<br>Netty是一个异步事件驱动的网络应用程序框架用于快速开发可维护的高性能协议服务器和客户端。</p><span id="more"></span><h1 id="一-NIO基础"><a href="#一-NIO基础" class="headerlink" title="一.NIO基础"></a>一.NIO基础</h1><h2 id="1-三大-组件"><a href="#1-三大-组件" class="headerlink" title="1.三大 组件"></a>1.三大 组件</h2><p>non-blocking io 非阻塞IO</p><h3 id="1-1-Channel-amp-amp-Buffer"><a href="#1-1-Channel-amp-amp-Buffer" class="headerlink" title="1.1 Channel &amp;&amp; Buffer"></a>1.1 Channel &amp;&amp; Buffer</h3><p>Channel:数据的传输通道，读写的双向同道.<br>可以从channel将数据读入buffer，也可以将buffer的数据写入channel。</p><h3 id="1-2-Selector-选择器"><a href="#1-2-Selector-选择器" class="headerlink" title="1.2 Selector 选择器"></a>1.2 Selector 选择器</h3><p><img data-src="/images/pasted-0.png" alt="upload successful"></p><p>传统多线程办的设计，一个socket对应一个thread处理</p><p><strong>缺点</strong></p><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的情况<br>一个客户端用一个线程处理，线程的本身就会占用内存。客户端的连接数越多，内存溢出<br>线程数多，cpu得跟得上性能。</li></ul><p><img data-src="/images/pasted-1.png" alt="upload successful"><br>改进成线程池的设计缺点：</p><ul><li>阻塞模式下，线程只能能处理一个socket操作，线程的利用率不高</li><li>适合短连接场景</li></ul><p><img data-src="/images/pasted-3.png" alt="upload successful"><br>一个selector配合一个线程管理多个channel<br>工作在非阻塞模式下，第一个channel没有事件后会转到第二个channel进行处理</p><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2.ByteBuffer"></a>2.ByteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileChannel</span></span><br><span class="line">        <span class="comment">//1.输入输出流， 2.RandomAccessFile</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="comment">//准备缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.flip(); <span class="comment">// 切换至读模式</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">                    System.out.println((<span class="type">char</span>) b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换成写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1ByteBuffer的使用姿势"><a href="#2-1ByteBuffer的使用姿势" class="headerlink" title="2.1ByteBuffer的使用姿势"></a>2.1ByteBuffer的使用姿势</h3><ol><li>向buffer写入数据，channel.read(buffer)</li><li>buffer切换至读模式,buffer.flip()</li><li>从buffer中读数据，buffer.get()</li><li>调用clear()或compact()切换至写模式</li><li>重复1 - 4</li></ol><h3 id="2-2ByteBuffer结构"><a href="#2-2ByteBuffer结构" class="headerlink" title="2.2ByteBuffer结构"></a>2.2ByteBuffer结构</h3><p>ByteBuffer的重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><hr><p><strong>ByteBuffer的初始状态</strong><br>一开始</p><p><img data-src="/images/pasted-4.png" alt="upload successful"></p><hr><p>写模式下，position是当前写入的位置，limit相当于容量</p><p><img data-src="/images/pasted-5.png" alt="upload successful"></p><hr><p>读模式下，flip动作发生以后，position切换到读取的位置，limit切换成读取限制</p><p><img data-src="/images/pasted-6.png" alt="upload successful"></p><hr><p><img data-src="/images/pasted-7.png" alt="upload successful"></p><hr><p>compact方法，是把未读完的部分向前压缩。<br><img data-src="/images/pasted-8.png" alt="upload successful"></p><h3 id="方法调用与演示"><a href="#方法调用与演示" class="headerlink" title="方法调用与演示"></a>方法调用与演示</h3><p>导入netty的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBufferReadWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="number">0x61</span>); <span class="comment">//&#x27;a&#x27;</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>&#125;); <span class="comment">// b , c , d</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        </span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">position: [<span class="number">1</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |a.........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">4</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |abcd......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h3 id="2-3ByteBuffer常见方法"><a href="#2-3ByteBuffer常见方法" class="headerlink" title="2.3ByteBuffer常见方法"></a>2.3ByteBuffer常见方法</h3><p><strong>分配空间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass());</span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * class java.nio.HeapByteBuffer -java 堆内存，读写效率较低 ， 收到GC垃圾回收的影响</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * class java.nio.DirectByteBuffer - 直接内存 ，读写效率高（少一次拷贝） ， 不会收到GC的影响</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 垃圾回收GC的往往会让数据变得更加紧凑，因此需要进行一次拷贝<br> 直接内存不会受到GC的影响，就不需要搬动<br> 但是DirectByteBuffer分配内存的效率低，还容易造成内存泄漏</p><hr><p><strong>写入</strong></p><ul><li><p>调用channel自己的read（） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf)</span><br></pre></td></tr></table></figure></li><li><p>调用buffer自己的put()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">123</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>从buffer读取数据</strong></p><ul><li>调用channel自身的write()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf)</span><br></pre></td></tr></table></figure></li><li>调用buffer自己的get()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure>get()会让position指针往后走，如果想重复读取数据</li><li>调用rewind()将postion指针置0</li><li>调用get(int i)方法获取索引i的内容，并且不会移动指针<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>mark &amp; reset<br>mark做一个标记，记录position位置<br>reset是将position重置到mark的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mark &amp; reset</span></span><br><span class="line">        <span class="comment">//mark做一个标记，记录position位置；reset是将position重置到mark的位置</span></span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        buffer.mark();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        buffer.reset();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串和bytebuffer的相互转换"><a href="#字符串和bytebuffer的相互转换" class="headerlink" title="字符串和bytebuffer的相互转换"></a>字符串和bytebuffer的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.字符串转为ByteBuffer</span></span><br><span class="line">        <span class="comment">//再次转换需要buffer.flip()</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        <span class="comment">//2.Charset</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        debugAll(buffer2);</span><br><span class="line">        <span class="comment">//3.wrap</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.ByteBuffer字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4Scattering-Reads"><a href="#2-4Scattering-Reads" class="headerlink" title="2.4Scattering Reads"></a>2.4Scattering Reads</h3><p><strong>通过集中写，分散读的方法，减少数据在ByteBuffer中拷贝的次数</strong><br>分散读取，有一个文本文件3parts.txt<br>onetwothree<br>长度已知的时候，用三个ByteBuffer进行分散读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScatteringReads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buf1,buf2,buf3&#125;);</span><br><span class="line">            buf1.flip();</span><br><span class="line">            buf2.flip();</span><br><span class="line">            buf3.flip();</span><br><span class="line">            debugAll(buf1);</span><br><span class="line">            debugAll(buf2);</span><br><span class="line">            debugAll(buf3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集中写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScatteringReads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buf1,buf2,buf3&#125;);</span><br><span class="line">            buf1.flip();</span><br><span class="line">            buf2.flip();</span><br><span class="line">            buf3.flip();</span><br><span class="line">            debugAll(buf1);</span><br><span class="line">            debugAll(buf2);</span><br><span class="line">            debugAll(buf3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习-黏包、半包现象）"><a href="#练习-黏包、半包现象）" class="headerlink" title="练习(黏包、半包现象）"></a>练习(黏包、半包现象）</h3><p>网络上有多条数据发送给服务器，数据之间使用\n进行分割但由于某种原因这些数据在接受时，倍进行了重新组合，例如原始数据如下：</p><hr><p>hello,world\n<br>I’m zhangsan\n<br>How are you?\n</p><hr><p>变成了下面的两个buffer  （黏包、半包现象）  </p><hr><p>hello,world\nI’m zhangsan\nHow<br>w are you?\n  </p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; source.limit() ; i++)&#123;</span><br><span class="line">            <span class="comment">//找到一条完整的消息</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//将这条完整消息存入新的ByteBuffer</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(lenth);</span><br><span class="line">                <span class="comment">//从source中读,向target中写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; lenth ; j ++)&#123;</span><br><span class="line">                    target.put(source.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3.文件编程"></a>3.文件编程</h2><p><strong>FileChannel只能工作在阻塞模式下</strong><br><strong>获取</strong><br>不能直接打开FileChannel,必须 通过FileInputStream,FileOutputStream或者RandomAccessFile来获取FileChannel，他们都有getChannel()方法。</p><ul><li>通过FileInputChannel获取的Channel只能读</li><li>通过FileOutputChannel获取的channel只能写</li><li>通过RandomAccessFile读写功能根据RandomAccessFile的读写模式决定</li></ul><h3 id="3-1两个Channel传输数据"><a href="#3-1两个Channel传输数据" class="headerlink" title="3.1两个Channel传输数据"></a>3.1两个Channel传输数据</h3><p><strong>transferTo()</strong><br>-底层利用操作系统的零拷贝进行优化，效率高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">            from.transferTo(<span class="number">0</span>,from.size(),to);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次最多上传2G数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size ; left &gt; <span class="number">0</span>; )&#123;</span><br><span class="line">                left -= from.transferTo(size - left , left ,to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2Path"><a href="#3-2Path" class="headerlink" title="3.2Path"></a>3.2Path</h3><p>jdk引入了path和Paths类</p><ul><li>Path用来表示文件路径</li><li>Paths是工具类，用来获取Path实例</li></ul><p><img data-src="/images/pasted-21.png" alt="upload successful"></p><h3 id="3-3Files"><a href="#3-3Files" class="headerlink" title="3.3Files"></a>3.3Files</h3><p><img data-src="/images/pasted-22.png" alt="upload successful"></p><p><img data-src="/images/pasted-23.png" alt="upload successful"></p><p><img data-src="/images/pasted-24.png" alt="upload successful"></p><p><img data-src="/images/pasted-25.png" alt="upload successful"></p><p><img data-src="/images/pasted-26.png" alt="upload successful"></p><p><img data-src="/images/pasted-27.png" alt="upload successful"></p><p><img data-src="/images/pasted-28.png" alt="upload successful"></p><hr><p><strong>walkFileTree()</strong><br>查询指定路径下以’.jpg’结尾文件的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilesWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/yangkaixuan/Desktop/Paper&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                @Override</span></span><br><span class="line"><span class="comment">//                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(dir);</span></span><br><span class="line"><span class="comment">//                    dirCount.incrementAndGet();</span></span><br><span class="line"><span class="comment">//                    return super.preVisitDirectory(dir, attrs);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="keyword">if</span>(file.toString().endsWith(<span class="string">&quot;.pdf&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(file);</span><br><span class="line">                        fileCount.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    System.out.println(file);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>层级删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilesWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/yangkaixuan/Desktop/资料&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    Files.delete(file);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    Files.delete(dir);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行前确保不是重要内容<br><strong>拷贝多级目录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;/Users/yangkaixuan/Desktop/资料&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">traget</span> <span class="operator">=</span> <span class="string">&quot;/Users/yangkaixuan/Desktop/资料2&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walk(Paths.get(source)).forEach(path -&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source,traget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path))&#123;</span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Files.isRegularFile(path))&#123;</span><br><span class="line">                    Files.copy(path,Paths.get(targetName));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4.网络编程"></a>4.网络编程</h2><h3 id="4-1使用NIO理解阻塞模式"><a href="#4-1使用NIO理解阻塞模式" class="headerlink" title="4.1使用NIO理解阻塞模式"></a>4.1使用NIO理解阻塞模式</h3><p><strong>Server端</strong><br>Channel是数据读写的通道，通过channel实现数据通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用NIO理解阻塞模式，单线程</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//1.创建服务器</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.绑定监听端口</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//3.连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4.accept 建立与客户端之间的连接，SocketChannel用来与客服端之间的通信</span></span><br><span class="line">            log.debug(<span class="string">&quot;connecting ...&quot;</span>);      </span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">            channels.add(sc);</span><br><span class="line">            log.debug(<span class="string">&quot;connected ...&#123;&#125;&quot;</span>,sc);</span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channels)&#123;</span><br><span class="line">                <span class="comment">//5.接收客户端发送的数据</span></span><br><span class="line">                log.debug(<span class="string">&quot;before read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                debugRead(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                log.debug(<span class="string">&quot;after read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端启动，客户端没有启动</p><hr><p>17:56:58.686 [main] DEBUG cn.itcast.netty.c4.Server - connecting …  </p><hr><p>其中accept()是阻塞方法，线程阻塞<br>客户端运行，但没有发送数据时，客户端read()阻塞（read()是阻塞方法）</p><hr><p>18:02:42.583 [main] DEBUG cn.itcast.netty.c4.Server - connecting …<br>18:02:48.181 [main] DEBUG cn.itcast.netty.c4.Server - connected …java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60801]<br>18:02:48.183 [main] DEBUG cn.itcast.netty.c4.Server - before read …java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60801]</p><hr><p>客户端运行，发送数据给服务器端后：</p><p><img data-src="/images/pasted-29.png" alt="upload successful"></p><p><strong>总结：accept（），read（）都是阻塞方法，得到数据开始运行，否则线程停止运行。阻塞模式和单线程结合后有很大的弊端：阻塞模式下，某个方法的执行会影响另一个方法的执行</strong></p><h3 id="4-2使用NIO理解非阻塞模式"><a href="#4-2使用NIO理解非阻塞模式" class="headerlink" title="4.2使用NIO理解非阻塞模式"></a>4.2使用NIO理解非阻塞模式</h3><p>非阻塞模式下，对服务器端的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">//非阻塞模式下,没有接收到链接的时候会返回null值，线程还会继续运行</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (sc != <span class="literal">null</span>)&#123;</span><br><span class="line">   log.debug(<span class="string">&quot;connected ...&#123;&#125;&quot;</span>,sc);</span><br><span class="line">   sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">   channels.add(sc);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">//非阻塞，线程任然会继续运行，如果没有读到数据,read返回0</span></span><br><span class="line"><span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    debugRead(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">    log.debug(<span class="string">&quot;after read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单的非阻塞模式虽然能够处理问题，但是没有连接请求，没有数据可读的时候也在不断循环，严重的造成了cpu的浪费<br>因此考虑到使用selector，很好的管理线程，当有任务的时候安排线程工作，没工作安排线程休息</strong>  </p><h3 id="4-3使用selector处理非阻塞模式"><a href="#4-3使用selector处理非阻塞模式" class="headerlink" title="4.3使用selector处理非阻塞模式"></a>4.3使用selector处理非阻塞模式</h3><ul><li>accept-会在有连接请求时触发(ServerSocketChannel)</li><li>connect-客户端，连接建立后触发（SocketChannel）</li><li>read-可读事件（SocketChannel）</li><li>write-可写事件</li></ul><hr><p>对ServerSocketChannel进行注册到Selector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意selector.select();select()在事件未处理的时候不会阻塞<br>如果对事件不需要进行处理，调用key.cancel()</strong><br><strong>总结：事件发生后，要吗处理、要吗取消，不能够置之不理</strong></p><hr><p>接下来，对ServerSocketChannel处理的同时处理SokectChannel  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugRead(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果发现，出现了空指针的报错</strong><br>Exception in thread “main” java.lang.NullPointerException<br>    at cn.itcast.netty.c4.Server.main(Server.java:52)</p><hr><p><img data-src="/images/pasted-31.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br></pre></td></tr></table></figure><p><strong>对客户端的额外处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        debugRead(buffer);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端断开连接就会发送一次read事件，然而由于IoException后没有对事件进行处理，所以跳出到下一次循环后会一直重复循环，所以需要反注册cancel()事件<br>无论客户端是正常断开还是异常断开，都会发送read事件，读取完后都需要删除<br><strong>正常断开</strong><br>判断channel.read()的返回值，为-1时代表客户端正常断开，cancel（）这个key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer2);<span class="comment">//如果是正常断开，read返回值为-1</span></span><br><span class="line">                        <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugRead(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="4-4消息边界问题"><a href="#4-4消息边界问题" class="headerlink" title="4.4消息边界问题"></a>4.4消息边界问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-34.png" alt="upload successful"><br>存在消息边界问题，系统默认使用字符集utf-8，一个中文字符占3个字节，需要第二次read()才能读完，导致乱码现象<br><img data-src="/images/pasted-35.png" alt="upload successful"><br>可以看出，要是message过长，那么bytebuffer扩容<br>如果message过短，可能造成半包或者粘包的现象。<br><strong>第一种方式：客户端和服务器约定相同的bytebuffer大小</strong>  </p><p><img data-src="/images/pasted-36.png" alt="upload successful"><br>问题：虽然简单，但是会造成空间的浪费，网络的带宽也会受到影响<br><strong>第二种方式：客户端发送消息时，采用分隔符对消息分割，服务器端根据分隔符长度，创建新的bytebuffer</strong></p><p><img data-src="/images/pasted-37.png" alt="upload successful"><br>问题：效率太低，需要一个字节一个字节的对比<br><strong>第三种方式：使用固定大小的空间，存储后续内容的大小，根据实际内容，先将内容长度发送给服务器，服务器根据数据的长度，根据长度分配bytebuffer</strong></p><p><img data-src="/images/pasted-38.png" alt="upload successful"><br>http 2.0是LTV<br>当bytebuffer的长度不能够一次读取完客户端发送的数据的时候。客户端就会再次发送read()事件，因为将Bytebuffer目前设置为局部变量，所以服务器会将第二次发送的数据当成完整数据接受。</p><p><img data-src="/images/pasted-40.png" alt="upload successful"></p><p><img data-src="/images/pasted-39.png" alt="upload successful"><br>产生的问题，bytebuffer需要扩容，把剩余部分接收到，接受完整的消息。<br>bytebuffer不能设置为局部变量。<br><strong>ByteBuffer能不能放在最外层？<br>不能！这样的话channel可能会复用一个bytebuffer，导致消息混乱</strong>  </p><hr><p><strong>采用附件的概念</strong><br>channel注册在selector的时候，附件关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; source.limit() ; i++)&#123;</span><br><span class="line">            <span class="comment">//找到一条完整的消息</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//将这条完整消息存入新的ByteBuffer</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(lenth);</span><br><span class="line">                <span class="comment">//从source中读,向target中写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; lenth ; j ++)&#123;</span><br><span class="line">                    target.put(source.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Key ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="comment">//将bytebuffer作为附件关联在selectionKey上</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer2);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//读取附件</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">//如果是正常断开，read返回值为-1</span></span><br><span class="line">                        <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            split(buffer);</span><br><span class="line">                            <span class="keyword">if</span> (buffer.position() == buffer.limit())&#123;</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                newBuffer.put(buffer);</span><br><span class="line">                                key.attach(newBuffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ByteBuffer的大小分配，每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，每个channel都需要维护一个独立的ByteBuffer<br>ByteBuffer不能太大，要设计大小可变的ByteBuffer</strong></p><h3 id="4-5可写事件"><a href="#4-5可写事件" class="headerlink" title="4.5可写事件"></a>4.5可写事件</h3><p>WriteServer  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">//1.向客户端发送大量数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">30000000</span>;i++)&#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">//2.返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WriteClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8081</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.接受数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器没有办法一次性将所有数据发送给客户端，写满后就为0<br><img data-src="/images/pasted-41.png" alt="upload successful"><br>不符合非阻塞的思想，没有发完的信息无限循环，直到发完才为止<br>不要让尝试反复地在写事件，关注可写事件后，写缓冲区满了，就进行读事件</p><p><strong>处理可写事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">//1.向客户端发送大量数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">30000000</span>;i++)&#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">//2.返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//缓冲区满了，但是数据仍然有剩余没有写</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">//4.关注可写事件</span></span><br><span class="line">                        scKey.interestOps(SelectionKey.OP_WRITE + scKey.interestOps());</span><br><span class="line">                        <span class="comment">//5.将未写完的数据挂到sckey上</span></span><br><span class="line">                        scKey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//6.清理操作</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining())&#123;</span><br><span class="line">                        key.attach(<span class="literal">null</span>); <span class="comment">//新关联，会把上次关联释放</span></span><br><span class="line">                        <span class="comment">//都写完后就不要关注write()</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多路复用</strong><br>单线程可以配合selector完成对多个Channel可读写事件的监控，这称之为多路复用。<br><strong>select()何时不阻塞</strong></p><ul><li>事件发生时<ul><li>客户端发起链接请求，触发accept事件</li><li>客户端发送数据，客户端正常、异常关闭，都会触发read()，如果数据大于buffer缓冲区，会触发多次read()</li><li>channel可写，write()</li><li>在linux下nio bug发生</li></ul></li></ul><h3 id="4-6利用多线程优化"><a href="#4-6利用多线程优化" class="headerlink" title="4.6利用多线程优化"></a>4.6利用多线程优化</h3><p>Boss selector只负责建立连接，不负责数据读写<br>worker selector负责数据的读写  </p><p><img data-src="/images/pasted-43.png" alt="upload successful"><br>MultiThreadServer  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//1.创建固定数量的worker,并初始化</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-0&quot;</span>);</span><br><span class="line">        worker.register();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    sc.register(worker.selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                    log.info(<span class="string">&quot; after connected , connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 还未初始化</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            log.info(<span class="string">&quot;read ..&#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程和selector</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start)&#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span> , name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现问题</p><p><img data-src="/images/pasted-52.png" alt="upload successful"><br>work的select（）执行，影响了register（）的执行<br>selector.select()是work方法的的select()  sc.register()也是用的work的select()  </p><p><strong>修改:将这两个方法挨着执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.register();</span><br><span class="line">sc.register(worker.selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这样子的操作，有很大的概率先执行sc.register()再执行worker.register()<br>同时也存在问题，当有一个新的线程进来后，就无法保证先后问题了，那么放在一个线程中执行就成了一个解决问题的办法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//1.创建固定数量的worker,并初始化</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    worker.register(sc);</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot; after connected , connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 还未初始化</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task !=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            log.info(<span class="string">&quot;read ..&#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程和selector</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start)&#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span> , name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向队列添加了任务但没有执行</span></span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用队列ConcurrentLinkedQueue对要做的事务进行处理，主线程向队列中添加了register任务。为了避免select() 和 register相互阻塞，想到的办法是将其放在一个线程中进行处理。<br>第一次循环：thread.start()后，进入循环的同时，select()方法阻塞。主线程通过wakeup()方法唤醒selector()。<br>第二次循环：从队列中去除Runnable的子类task，执行run()方法 （）-&gt;{ .. register()..}在同一线程内注册sc.register（）<br>第三次循环：检测到可读实现，实现可读功能。<br><strong>总结：也就是说使用队列的方式，将两个事件放在同一个线程中处理先后顺序</strong></p><h3 id="4-7-NIO-vs-BIO"><a href="#4-7-NIO-vs-BIO" class="headerlink" title="4.7 NIO vs BIO"></a>4.7 NIO vs BIO</h3><p><strong>stream vs channel</strong></p><ul><li><p>stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区、接受缓冲区</p></li><li><p>steam只支持阻塞API，channel同时支持阻塞、非阻塞API，网络channel可配合selector实现多路复用</p></li><li><p>二者都为全双工，读写可以同时进行<br><strong>IO模型</strong><br>同步阻塞、同步非阻塞、多路复用、异步阻塞（没有这种情况）、异步非阻塞</p></li><li><p>阻塞IO</p></li></ul><p><img data-src="/images/pasted-55.png" alt="upload successful"><br>等待数据时阻塞，一直到接受到数据后，返回给用户线程,等待的过程用户线程被阻塞</p><ul><li>非阻塞IO</li></ul><p><img data-src="/images/pasted-54.png" alt="upload successful"><br>通过while(true)没有接受到数据后立刻返回，再重新发起read()，此时线程不会被阻塞。但是当接收到数据后，用户线程也是会被阻塞的，以等待返回的数据。<br>只是等待数据阶段不是阻塞过程，并且多次与系统和用户之间进行切换，影响系统的性能。  </p><ul><li>多路复用</li></ul><p><img data-src="/images/pasted-56.png" alt="upload successful"><br>两个阶段阻塞用户线程，select阶段阻塞，read阶段阻塞。<br><strong>Q：阻塞模式下只进行一次系统调用，而多路复用涉及到两次系统调用，那么多路复用的优势在哪呢？</strong>  </p><p><img data-src="/images/pasted-57.png" alt="upload successful"><br>阻塞IO的问题：在accpet等待连接的时候就没有办法处理channel的read,处理一件事的时候没有办法处理别的事情。  </p><p><img data-src="/images/pasted-58.png" alt="upload successful"><br>多路复用，select阻塞过程中能获得多个channel，再一次处理过程中能处理多个事件。  </p><ul><li>同步：线程自己去获得结果（一个线程）</li><li>异步：线程自己不去获取结果，而是有其他线程送结果（至少两个线程）<br><strong>异步</strong><br>异步情况下，线程一定是非阻塞的。</li></ul><p><img data-src="/images/pasted-59.png" alt="upload successful"></p><h3 id="4-8-零拷贝"><a href="#4-8-零拷贝" class="headerlink" title="4.8 零拷贝"></a>4.8 零拷贝</h3><p><img data-src="/images/pasted-60.png" alt="upload successful">  </p><p><img data-src="/images/pasted-61.png" alt="upload successful"><br>1.java本身不具备IO读写能力，因此read方法调用后，要从用户态转换成内核态，去调用操作系统的读写能力，将数据写入内核缓冲区。这期间用户线程阻塞。<br>2.从内核态切换成用户态，将数据从内核缓冲区读入用户缓冲区。<br>3.调用write方法，这时将数据从用户缓冲区写入socket缓冲区<br>4.接下来向网卡写数据，java不具备读写能力，因此从用户态切换到内核态，将socket缓冲区中的数据写入网卡<br><strong>NIO优化</strong><br>通过DirectByteBuf</p><ul><li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是java内存</li><li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li></ul><p><img data-src="/images/pasted-62.png" alt="upload successful"><br>进一步优化，（底层代用了linux2.1后提供的sendFile方法）,java中对应着两个channel调用transferTo&#x2F;transferFrom拷贝数据</p><p><img data-src="/images/pasted-63.png" alt="upload successful"><br>1.java调用transferTo方法后，要从java的用户态切换成内核态，将数据写入内核缓冲区<br>2.数据从内核缓冲区传输到socket缓冲区<br>3.将socket缓冲区数据写入网卡<br>进一步优化，（linu2.4）  </p><p><img data-src="/images/pasted-64.png" alt="upload successful"><br>1.java调用transferTo方法后，要从java的用户态切换成内核态，将数据写入内核缓冲区<br>2.只会将一些offset和length信息拷贝进socket缓冲区，几乎没有消耗<br>3.从内核缓冲区直接写入网卡<br><strong>最后两种优化有可以是 零拷贝 ，也就是说数据只在操作系统中拷贝，而不会拷贝在jvm内存中</strong><br>优点：  </p><ul><li>更少的内核态和用户态的转换</li><li>使用专门的DMA硬件进行拷贝，不利用cpu计算</li><li>零拷贝适合小文件的传输</li></ul><h1 id="二-Netty入门"><a href="#二-Netty入门" class="headerlink" title="二.Netty入门"></a>二.Netty入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li>netty vs NIO 工作量大，bug多<ul><li>需要自己构建协议</li><li>解决TCP的传输问题，粘包，半包</li><li>epoll空轮询，导致cpu100%</li><li>对API进行增强，更容易使用</li></ul></li></ul><h2 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2.hello world"></a>2.hello world</h2><p><img data-src="/images/pasted-68.png" alt="upload successful"><br>1.创建启动器类<br>2.添加组件，一开始关心accept事件，<br>3.channel<br>4.添加处理器，处理器initChannel（）不会立刻执行,只有在连接建立后才执行<br>5.channel<br>6.bind绑定端口<br>7.启动类<br>8.EventLoop添加<br>9.选择channel<br>10.添加处理器<br>11.connect()；链接服务器，服务器监听到后，会调用accpet相应的处理器进行处理，不需要写出来，但它会调用initChannel（）<br>12.服务器端，链接建立后，执行initChannel()<br>12.客户端一样，连接建立后，调用客户端的initChannel（）<br>14.发送数据，凡是收发数据，必须执行handler<br>15.调用StringEncoder()，将hello转为ByteBuf格式<br>16.又EventLoopGroup中某个EventLoop处理read事件<br>17.调用服务器的hanlder进行处理，首先调用StringDecoder()，将ByteBuf还原成字符串<br>18.执行channelread（）打印由（17）还原的字符串<br><strong>一开始需要注意的思想</strong></p><p><img data-src="/images/pasted-69.png" alt="upload successful"><br>其中handler表示每一道工序，左右工序整合成为pipeline。Inbound和Outbound两类分别处理入站、出站。<br>eventLoop中包含线程，真正的能够处理数据。<br>工人和channel的绑定，工人可以管理多个channel，保证线程的安全。  </p><h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3.组件"></a>3.组件</h2><h3 id="3-1EventLoop"><a href="#3-1EventLoop" class="headerlink" title="3.1EventLoop"></a>3.1EventLoop</h3><p>事件循环对象EventLoop本质是一个单线程执行器（同时维护一个selector），里面的run方法处理源源不断的channel上的IO事件  </p><ul><li>继承自j.u.c.ScheduledExecutorService 因此包含线程池中的所有方法</li><li>另一条线是继承自netty自己的OrderedEventExecutor<ul><li>isEventLoop(Thread thread)判断是否是一个EventLoop</li><li>parent()判断来自那个EventLoopGroup</li></ul></li></ul><p>事件循环组EventLoopGroup,Channel一般会调用EventLoopGroup的Register方法来绑定一个EventLoop,后续这个channel的io时间都由此EventLoop负责。（保证io处理事线程安全)<br>EventLoop的普通任务，定时任务  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventLoop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建事件循环组</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io , 普通任务 ， 定时任务</span></span><br><span class="line"><span class="comment">//        DefaultEventLoopGroup group = new DefaultEventLoopGroup();  普通任务 ， 定时任务</span></span><br><span class="line">        <span class="comment">//2.获取下一个时间循环对象</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行普通任务</span></span><br><span class="line">        group.next().submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIOEventLoopGroup中的EventLoop一旦与channel绑定关系，都不可更改，后续的所有请求都由同一个eventLoop进行处理。  </p><p><img data-src="/images/pasted-72.png" alt="upload successful"><br>对NioEventLoopGroup的两次细分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//细分2：创建一个独立的EventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();<span class="comment">//只能处理普通任务，定时任务，不能处理io事件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// boss 和 worker</span></span><br><span class="line">                <span class="comment">//细分1：boss 只负责serverSocketChannel上的accept事件  worker只负责socketChannel上的读写</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span>                                           <span class="comment">//ByteBuf</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));<span class="comment">//开发时需要强制指定字符集，不然会乱码</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group , <span class="string">&quot;handler2&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(buf);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细分一：为什么不只设置一个NioEventLoop的boss呢？<br>因为其中NioServerChannel只会有一个，而也只会有一个EventLoop进行绑定，不需要设置。<br>如果有一个handler执行时间过长该怎么解决？<br>为了不影响到worker线程的nio操作影响服务器的读写性能，创建一个新的NioEventLoopGroup,用它来处理耗时的工作。  </p><p><img data-src="/images/pasted-73.png" alt="upload successful">  </p><h3 id="3-2线程切换"><a href="#3-2线程切换" class="headerlink" title="3.2线程切换"></a>3.2线程切换</h3><p>那么其中的不同线程是如何切换的？<br>我们将NioEventLoopGroup中的线程成为nio线程，DefaultEventLoopGroup中的线程称为普通线程</p><p><img data-src="/images/pasted-74.png" alt="upload successful"><br>如果两个handler绑定的是同一个线程，那么直接调用<br>如果两个handler不是同一个线程，那么要把调用的代码封装在一个Runnable对象中，作为任务对象由下一个handler的线程调用。</p><h3 id="3-3-Channel"><a href="#3-3-Channel" class="headerlink" title="3.3 Channel"></a>3.3 Channel</h3><p>sync()和connect（）方法的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.启动器</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 2.添加EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 3.选择客户端Channel的实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4.添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//连接建立后调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//1.连接到服务器</span></span><br><span class="line"><span class="comment">//                异步非阻塞：main线程发起了调用，但是不是主线程去做链接服务器的工作，真正执行的是nio线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)); <span class="comment">// 假如1s后完成链接</span></span><br><span class="line"><span class="comment">//        channelFuture.sync();</span></span><br><span class="line">        <span class="comment">//因为主线程connect是非阻塞的，瞬间就会来到下一行代码，但是此时还没有建立好链接，拿不到目标channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello , world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中connect()方法是异步非阻塞的，主线程不需要知道调用后的结果如何，链接工作交给了nio线程去完成，假如需要在1s后完成连接，而此时主线程的connect()方法异步非阻塞，那么一个瞬间就会来到channelFutrue.channel()方法，那么就拿不到目标的channel.<br><strong>带有Futrue、Promise的类型往往和异步方法搭配使用，用来处理结果</strong><br>方法1：<br>使用sync()方法来同步处理结果，将当前线程阻塞住，知道nio线程完成连接，sync()方法向下运行。其中，主线程等待nio线程完成连接。<br>方法2：<br>使用addListener()方法异步处理结果，等待连接建立，链接建立成功都由其他线程处理。在nio线程建立连接后，nio线程调用operationComplete()方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> future.channel();</span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-4-channelFuture处理关闭"><a href="#3-4-channelFuture处理关闭" class="headerlink" title="3.4 channelFuture处理关闭"></a>3.4 channelFuture处理关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line))&#123;</span><br><span class="line">                    channel.close(); <span class="comment">//异步操作</span></span><br><span class="line">                    log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;input&quot;</span>).start();</span><br></pre></td></tr></table></figure><p> channel.close()是异步方法，由NioEventLoop进行控制，而log.debug()是由input线程控制，不能控制谁前谁后发生。有可能先做了善后的工作，才关闭channel。<br> <strong>通过获取ClosedFuture对象： 1)同步处理关闭  2)异步处理关闭</strong><br> 同步处理关闭，善后操作由主线程完成<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">System.out.println(<span class="string">&quot;waiting close&quot;</span>);</span><br><span class="line">closeFuture.sync();</span><br><span class="line">log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br></pre></td></tr></table></figure></p><p> 异步处理关闭，善后操作由关闭chanenl的nio线程完成<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">       closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><br> 优雅的关闭客户端。 group.shutdownGracefully();<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line))&#123;</span><br><span class="line">                    channel.close(); <span class="comment">//异步操作</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;);</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;input&quot;</span>).start();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;waiting close&quot;);</span></span><br><span class="line"><span class="comment">//        closeFuture.sync();</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;处理关闭之后的操作&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="3-5-为什么要使用异步？"><a href="#3-5-为什么要使用异步？" class="headerlink" title="3.5 为什么要使用异步？"></a>3.5 为什么要使用异步？</h3><p>netty使用异步的操作，究竟提升了哪些性能？<br>要点：  </p><ul><li>单线程无法异步提高效率，必须配合多线程，多核cpu才能够发挥异步的优势</li><li>异步没有缩短响应时间，反而有所增加</li><li>合理进行任务拆分，也是利用异步的关键</li></ul><h3 id="3-6-Future-amp-Promise"><a href="#3-6-Future-amp-Promise" class="headerlink" title="3.6 Future &amp; Promise"></a>3.6 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口<br>首先要说明netty中Future与jdk中的Future同名，netty的Futrue继承自jdk的Future,而Promise又对netty Future进行了扩展。  </p><p><img data-src="/images/pasted-75.png" alt="upload successful">  </p><p><img data-src="/images/pasted-76.png" alt="upload successful"><br>java Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJdkFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2.提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.主线程通过Future获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,future.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-77.png" alt="upload successful">  </p><p>netty Future使用异步方式获取结果  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line"><span class="comment">//        log.debug(&quot;结果是&#123;&#125;&quot;,future.getNow());</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-78.png" alt="upload successful"><br>我们需要的结果都是通过线程池，或者eventLoop返回的Future对象，我们没有办法自己进行创建，是无法控制的。那么就考虑使用Promise，主动的创建<strong>结果容器</strong>，而不是被动的获取结果。<br><strong>构建Promise需要新建一个eventLoop传入构造器中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyPromise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建EventLoop对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">        <span class="comment">//2.主动创建promise，结果容器</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始计算&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果。。。&quot;</span>);</span><br><span class="line">        promise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,promise.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-7-Handler-amp-Pipeline"><a href="#3-7-Handler-amp-Pipeline" class="headerlink" title="3.7 Handler &amp; Pipeline"></a>3.7 Handler &amp; Pipeline</h3><p><img data-src="/images/pasted-79.png" alt="upload successful">  </p><p>ChannelInboundHandlerAdapter 入站处理器<br>ChannelOutboundHandlerAdapter 出站处理器  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPipeLine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//1.通过channel拿到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                        <span class="comment">//2.添加handler : head -&gt; h1 -&gt; h2 -&gt; h3 -&gt;tail  （双向链表）</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h1&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h2&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h3&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h4&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h5&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h6&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-embeddedChannel"><a href="#3-8-embeddedChannel" class="headerlink" title="3.8 embeddedChannel"></a>3.8 embeddedChannel</h3><h3 id="3-9-ByteBuf"><a href="#3-9-ByteBuf" class="headerlink" title="3.9 ByteBuf"></a>3.9 ByteBuf</h3><p><img data-src="/images/pasted-81.png" alt="upload successful"><br>只有触发writeAndFlush方法才会触发出战处理器，入站顺序执行，出站逆序执行。<br>super.channelRead(ctx, msg);<br>将数据传递给下一个handler，如果不调用的话，传递链就会断开。</p><hr><p>ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(“server”.getBytes()));<br>                              ch.writeAndFlush(ctx.alloc().buffer().writeBytes(“server”.getBytes()));</p><hr><p>ctx从当前处理器往回找出站处理器，ch则是从整个pipline的tail往回找出站处理器。  </p><p><img data-src="/images/pasted-82.png" alt="upload successful"></p><p><strong>Bytebuf的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBuf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        System.out.println(buf);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">300</span> ; i ++)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.writeBytes(sb.toString().getBytes());</span><br><span class="line">        System.out.println(buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接内存 vs 堆内存</strong><br>netty一般默认情况下选择<em>直接内存</em><br>创建池化基于堆的ByteBUf<br>ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(10);<br>创建池化基于直接内存的ByteBuf<br>ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(10);  </p><ul><li>直接内存的创建和销毁的代价昂贵，但是读写性能很高，适合配合池化功能一起使用 </li><li>直接内存收到的GC压力小，因为这部分内存不收JVM垃圾回收的管理，但是要注意及时释放</li></ul><p><strong>池化 vs 非池化</strong><br>池化的意义在于可以重用BuyeBuf：  </p><ul><li>没有池化，则每次都要创建新的ButeBuf实力，这个操作对直接内存代价昂贵。就算是堆内存，都会有GC的压力</li><li>有了池化可以重用池中的ByteBuf,并且采用了jemalloc类似的内存分配算法提升分配效率</li><li>高并发时，池化可以节省内存，减少内存溢出的可能</li></ul><p><strong>组成</strong><br>ByteBuf由4个部分组成  </p><p><img data-src="/images/pasted-83.png" alt="upload successful"><br>读写指针一开始都在0位置  </p><p><img data-src="/images/pasted-84.png" alt="upload successful"><br>废弃部分  可读部分  可写部分  可扩容部分  </p><hr><p><strong>写入的相关方法</strong></p><p><img data-src="/images/pasted-85.png" alt="upload successful"><br>扩容规则：  </p><p><img data-src="/images/pasted-86.png" alt="upload successful">  </p><p><strong>ByteBuf的内存回收（retain \ release方法）</strong>  </p><ul><li>UnpooledHeapByteBuf 使用JVM内存，只需等待GC回收内存</li><li>UNnpooledDiredtByteBuf 使用的是直接内存，需要特殊的方法来回收内存</li><li>PooledByteBuf使用池化机制，需要使用更复杂的方式回收</li></ul><p>Netty引用计数法来控制内存回收，每个Bytebuf都实现了ReferenceCounted借口  </p><ul><li>每个ByteBuf对象初始值为1  </li><li>调用release方法减1，如果计数为0，ByteBuf内存回收</li><li>调用retain方法加1，表示调用者没用完之前，其他hanlder调用了release也不会造成回收</li><li>当计数为0时，底层内存会被回收，就算对象还存在也不能使用<br>哪个handler最后使用bytebuf应该释放，前面的handler不应该释放。<br>尾部tail对bytebuf的释放处理：TailContext -&gt; channelRead()-&gt;ReferenceCountUtil.release(msg);</li></ul><p><img data-src="/images/pasted-87.png" alt="upload successful"><br>所有的ByteBuf都继承自ReferenceCounted。<br>头部header对byteBuf的释放处理：HeadContext-&gt;write()</p><p><img data-src="/images/pasted-88.png" alt="upload successful">  </p><hr><p><strong>零拷贝 slice</strong>  </p><p><img data-src="/images/pasted-89.png" alt="upload successful"><br>对原来的bytebuf进行切片变成多个bytebuf,切片后bytebuf并没有发生内存复制，还是使用原来的内存，切片后维护独立的read,write指针。  </p><p>切片后的结果不允许使用新的内容。  </p><hr><p><strong>Compostie</strong><br>传统的组合方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSlice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buffer.writeBytes(buf1).writeBytes(buf2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是并不好，因为中途会发生数据的复制，对性能产生影响。</p><h1 id="三、netty进阶"><a href="#三、netty进阶" class="headerlink" title="三、netty进阶"></a>三、netty进阶</h1><h2 id="1-粘包半包"><a href="#1-粘包半包" class="headerlink" title="1.粘包半包"></a>1.粘包半包</h2><h3 id="1-1粘包-半包现象"><a href="#1-1粘包-半包现象" class="headerlink" title="1.1粘包,半包现象"></a>1.1粘包,半包现象</h3><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">客户端</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">                                buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buf);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-90.png" alt="upload successful"><br>产生粘包现象</p><h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><ul><li><p>TCP以一个段位单位，每发送一个段就需要进行一次确认ack应答处理，但这么做的缺点是，包的往返时间越长，性能就越差</p></li><li><p>为了解决此问题，引入了<strong>窗口</strong>的概念，决定了无需等待应答还可以继续发送的数据最大主</p></li><li><p>窗口的实际作用就是一个缓冲区，同时启动控制流量的作用  </p><ul><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul></li></ul><p><img data-src="/images/pasted-91.png" alt="upload successful"><br>粘包</p><ul><li>现象，发送 abc def，接收 abcdef</li><li>原因<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li><li>TCP层，滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul><p>半包</p><ul><li>现象，发送 abcdef，接收 abc def</li><li>原因<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>TCP层，滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><h3 id="1-3-解决1：短连接"><a href="#1-3-解决1：短连接" class="headerlink" title="1.3 解决1：短连接"></a>1.3 解决1：短连接</h3><p>造成半包粘包现象主要是因为tcp的消息无边界，采用短连接后，客户端发送完信息直接断开，服务器端根据nio可知，客户端断开后服务器读到的值为-1，那么服务器就认为读取到的信息是一条完整的信息。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">以解决粘包为例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-解决2：定长解码器"><a href="#1-4-解决2：定长解码器" class="headerlink" title="1.4 解决2：定长解码器"></a>1.4 解决2：定长解码器</h3><h3 id="1-5-解决3：使用分隔符处理消息边界"><a href="#1-5-解决3：使用分隔符处理消息边界" class="headerlink" title="1.5 解决3：使用分隔符处理消息边界"></a>1.5 解决3：使用分隔符处理消息边界</h3><p><img data-src="/images/pasted-92.png" alt="upload successful"><br>maxlength为最长文本长度，当长度过长后就认为长度过长了。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br><span class="line">```   </span><br><span class="line">### <span class="number">1.6</span> 解决<span class="number">3</span>：固定分隔符</span><br><span class="line">服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>客户端在每条消息之后，加入 \n 分隔符</p><h3 id="1-7-解决4：基于长度字段的解码器"><a href="#1-7-解决4：基于长度字段的解码器" class="headerlink" title="1.7 解决4：基于长度字段的解码器"></a>1.7 解决4：基于长度字段的解码器</h3><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-94.png" alt="upload successful"><br><img data-src="/images/pasted-93.png" alt="upload successful">  </p><p><img data-src="/images/pasted-95.png" alt="upload successful">  </p><p><img data-src="/images/pasted-96.png" alt="upload successful">  </p><p><img data-src="/images/pasted-97.png" alt="upload successful">  </p><p><img data-src="/images/pasted-98.png" alt="upload successful">  </p><h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2.协议设计与解析"></a>2.协议设计与解析</h2><h3 id="2-1-为什么需要协议？"><a href="#2-1-为什么需要协议？" class="headerlink" title="2.1 为什么需要协议？"></a>2.1 为什么需要协议？</h3><p>TCP&#x2F;IP 中消息传输基于流的形式，并没有边界。协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则。<br>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure><p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0f</span>下雨天留客<span class="number">06</span>天留<span class="number">09</span>我不留</span><br></pre></td></tr></table></figure><h3 id="2-2-自定义协议要素"><a href="#2-2-自定义协议要素" class="headerlink" title="2.2 自定义协议要素"></a>2.2 自定义协议要素</h3><ul><li>魔术，用来第一时间判定是否是无效数据包</li><li>版本号，用来支持协议的升级</li><li>序列化算法，消息正文到底采用那种序列化反序列化方式，一般用于消息正文。常见的序列化算法，json,protobuf,hessian,jdk</li><li>消息正文， username,password… json,xml,对象流</li><li>指令类型，是登陆，注册，单聊，群聊。。。跟业务有关</li><li>请求序列，为了双工通信，提高异步能力</li><li>正文长度<br>MessageCodec<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 4字节的魔数</span></span><br><span class="line">        byteBuf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">//2. 1字节的版本</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3. 序列化算法：0-jdk 1-json</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//4. 1字节的指令类型</span></span><br><span class="line">        byteBuf.writeByte(message.getMessageType());</span><br><span class="line">        <span class="comment">//5. 4个字节的指令的请求序号</span></span><br><span class="line">        byteBuf.writeInt(message.getSequenceId());</span><br><span class="line">        <span class="comment">//对其填充</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(message);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 长度</span></span><br><span class="line">        byteBuf.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">//8. 内容</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNumber</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,magicNumber,version,serializerType,messageType,sequenceId,length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,message);</span><br><span class="line">        list.add(message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>TestMessageCodec<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageCodec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">//encode</span></span><br><span class="line">        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decode</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>,message,buf);</span><br><span class="line">        channel.writeInbound(buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>new LengthFieldBasedFrameDecoder(1024,12,4,0,0)对处理粘包半包现象是否真的有用？！  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageCodec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">//encode</span></span><br><span class="line">        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decode</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>,message,buf);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">        buf1.retain();</span><br><span class="line">        channel.writeInbound(buf1); <span class="comment">//release 1</span></span><br><span class="line">        channel.writeInbound(buf2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><img data-src="/images/pasted-99.png" alt="upload successful">  </p><p><img data-src="/images/pasted-100.png" alt="upload successful">  </p><p><img data-src="/images/pasted-101.png" alt="upload successful"><br>成功decode出内容，说明是真的有用。<br>是否能将LengthFieldBasedFrameDecoder抽取？<br>显然不行，对于每个eventLoop来说，可能LengthFieldBasedFrameDecoder由于多个线程共同使用，会引起线程不安全问题。  </p><p><img data-src="/images/pasted-102.png" alt="upload successful"><br>有sharable注解的类说明是线程安全的。<br><strong>ByteToMessageCodec的子类不能标注shareable注解</strong></p><h2 id="3-聊天室"><a href="#3-聊天室" class="headerlink" title="3.聊天室"></a>3.聊天室</h2><h3 id="3-1-登录"><a href="#3-1-登录" class="headerlink" title="3.1 登录"></a>3.1 登录</h3><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                            ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    log.debug(<span class="string">&quot;msg:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">                                    <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                        <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                        <span class="keyword">if</span> (response.isSuccess())&#123;</span><br><span class="line">                                            LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="comment">//接受用户在控制台的输入，负责向服务器发送消息</span></span><br><span class="line">                                    <span class="comment">//为什么创建新的线程？不创建的话systemin会阻塞其他的io操作</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                                        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        <span class="comment">//构造消息对象</span></span><br><span class="line">                                        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(userName, password);</span><br><span class="line">                                        <span class="comment">//发送消息</span></span><br><span class="line">                                        ctx.writeAndFlush(message);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            WAIT_FOR_LOGIN.await();</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//如果登录失败</span></span><br><span class="line">                                        <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;send [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;gsend [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,<span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）连接建立后就会触发客户端的channelActive<br>（2）读取到用户名和密码封装到LoginRequestMessage后，ctx.writeAndFlush(message)发送给客户端。出站消息，通过encoder编码.<br>设置CountDownLatch systemin线程阻塞等待主线程应答。<br>（3）入站消息使用SimpleChannelInboundHandler<LoginRequestMessage>只针对泛型的类型进行处理，如果账号密码正确ctx.(LoginResponseMessage)<br>（4）channelRead读取解码后的消息，如果消息正确，set login &#x3D; true,并且systemin线程被唤醒继续运行。<br>（5）如果login不为true,cx.channel.close()方法会触发channel.closeFuture().sync()关闭通道。<br>（6）如果login为true,开启聊天室业务。<br>服务器端  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServerBootstrap</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bs.channel(NioServerSocketChannel.class);</span><br><span class="line">            bs.group(boss, worker);</span><br><span class="line">            bs.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(userName,password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span> (login)&#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;登录成功！!&quot;</span>);</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;账号密码错误&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bs.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2菜单"><a href="#3-2菜单" class="headerlink" title="3.2菜单"></a>3.2菜单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> itcast.client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> itcast.message.*;</span><br><span class="line"><span class="keyword">import</span> itcast.protocol.MessageCodecSharable;</span><br><span class="line"><span class="keyword">import</span> itcast.protocol.ProcotolFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2022/9/20.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KaiXuan Yang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                            ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    log.debug(<span class="string">&quot;msg:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">                                    <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                        <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                        <span class="keyword">if</span> (response.isSuccess())&#123;</span><br><span class="line">                                            LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="comment">//接受用户在控制台的输入，负责向服务器发送消息</span></span><br><span class="line">                                    <span class="comment">//为什么创建新的线程？不创建的话systemin会阻塞其他的io操作</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                                        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        <span class="comment">//构造消息对象</span></span><br><span class="line">                                        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(userName, password);</span><br><span class="line">                                        <span class="comment">//发送消息</span></span><br><span class="line">                                        ctx.writeAndFlush(message);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            WAIT_FOR_LOGIN.await();</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//如果登录失败</span></span><br><span class="line">                                        <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;send [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;gsend [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                            String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                            <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatRequestMessage</span>(userName,s[<span class="number">1</span>],s[<span class="number">2</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatRequestMessage</span>(userName,s[<span class="number">1</span>],s[<span class="number">2</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                                    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateRequestMessage</span>(s[<span class="number">1</span>],set));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersRequestMessage</span>(s[<span class="number">1</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinRequestMessage</span>(userName,s[<span class="number">1</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupQuitRequestMessage</span>(userName,s[<span class="number">1</span>]));</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                                    ctx.channel().close();</span><br><span class="line">                                                    <span class="keyword">return</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,<span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-创建群组"><a href="#3-3-创建群组" class="headerlink" title="3.3 创建群组"></a>3.3 创建群组</h3><p><img data-src="/images/pasted-103.png" alt="upload successful"><br>客户端发送GroupCreateRequestMessage<br>服务器端处理的handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="type">GroupSession</span> <span class="variable">groupSession</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//发送成功消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels)&#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span> , <span class="string">&quot;您已经被拉入群聊&quot;</span>+groupName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>,groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">false</span>,groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-发起群聊"><a href="#3-4-发起群聊" class="headerlink" title="3.4 发起群聊"></a>3.4 发起群聊</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels)&#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatResponseMessage</span>(msg.getFrom(),msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-退出处理"><a href="#3-5-退出处理" class="headerlink" title="3.5 退出处理"></a>3.5 退出处理</h3><p>当链接断开时触发，Inactive事件  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuitHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//当链接断开时 触发</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;已经断开&quot;</span>,ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户异常断开</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;已经异常断开，异常是&#123;&#125;&quot;</span>,ctx.channel(),cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-6-空闲检测（连接假死）"><a href="#3-6-空闲检测（连接假死）" class="headerlink" title="3.6 空闲检测（连接假死）"></a>3.6 空闲检测（连接假死）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bs.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">//用来判断是不是读空闲时间过长，或者是写空闲时间过长</span></span><br><span class="line">                    <span class="comment">//5s内如果没有收到channel读入的数据，会触发一个IdleState#READER_IDLE事件</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>()&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//用来触发特殊事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent)evt;</span><br><span class="line">                            <span class="comment">// 触发了读空闲时间</span></span><br><span class="line">                            <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE)&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;读空闲已经超过5s&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(LOGIN_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(CHAT_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(GROUP_CREATE_HANDLER);</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_JOIN_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_MEMBERS_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_QUIT_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_CHAT_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(QUIT_HANDLER);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-7-心跳"><a href="#3-7-心跳" class="headerlink" title="3.7 心跳"></a>3.7 心跳</h3><p><img data-src="/images/pasted-104.png" alt="upload successful"><br>如果直接这么操作会产生一个问题，用户登录时并没有退出，但是超过5s后，就被服务器强制回收了。<br>为了解决这个bug，通过心跳数据包的方法，客户端一定时间向服务器发送心跳数据。  </p><p><img data-src="/images/pasted-105.png" alt="upload successful">  </p><h1 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h1><h2 id="1-优化算法"><a href="#1-优化算法" class="headerlink" title="1.优化算法"></a>1.优化算法</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上  </p><ul><li>序列化时，需要将java对象变为要传输的数据（可以是byte[],json等，最后都要变成byte[]）  </li><li>反序列化时，需要将输入的正文数据还原成java对象，便于处理<br>jar序列化算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz , <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Algorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span>&#123;</span><br><span class="line">        Java &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">                oos.writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-参数"><a href="#2-参数" class="headerlink" title="2.参数"></a>2.参数</h2><p>（1）CONNECT_TIMEOUT_MILLES<br><img data-src="/images/pasted-106.png" alt="upload successful">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().option();<span class="comment">//是给ServerSocketChannel配置参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().childOption(); <span class="comment">//是给SocketChannel配置参数</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/pasted-107.png" alt="upload successful"><br>(2)SO_BACKLOG<br>三次握手：<br>已经完成三次握手的队列放入全连接队列，没完成的队列放入半连接队列。  </p><p><img data-src="/images/pasted-108.png" alt="upload successful">  </p><p><img data-src="/images/pasted-109.png" alt="upload successful">  </p><p><img data-src="/images/pasted-110.png" alt="upload successful"><br>当全连接队列满了之后，server发送一个拒绝连接的错误消息给client<br>在netty中，通过option(ChannelOption.SO_BACKLOG,value)来设置大小<br>(3)ulimit-n<br>属于操作系统参数，文件描述符的最大数量<br>(4)TCP_NODELAY<br>属于SocketChannel参数，false开启了nagle算法（true)<br>(6)SO_SNDBUF &amp; SO_RCVBUF<br>(7)ALLOCATOR  </p><ul><li>属于SocketChannel参数</li><li>用来分配ByteBuf,ctx.alloc()</li></ul><p>ctx.allc()的bytebug可以由系统环境 -Dio.netty.allocator.type&#x3D;unpooled<br>-Dio.netty.noPreferDirect&#x3D;true   </p><p>(8)RECBUF_ALLOCATOR</p><ul><li>属于SocketChannel参数</li><li>控制netty接受缓冲区大小</li><li>负责入站数据的分配，决定入站缓冲区的大小（可动态调整），统一采用direct直接内存，具体池化还是非池化由allocator决定</li></ul><p>IO操作接收数据的bytebuf，强制采用直接内存接收，效率非常高。  </p><p>AbstractNioByteChannel<br><img data-src="/images/pasted-111.png" alt="upload successful"><br>RecvByteBufAllocator的内部类，使用allocate方法，创建byteBuf<br>ByteBufAllocator只负责bytebuf是否是池化，真正决定bytebuf大小和direct模式由RecvByteBufAllocator决定。  </p><p><img data-src="/images/pasted-112.png" alt="upload successful"><br>ioBuffer强制使用直接内存  guess()会动态的数据量调整bytebuf的大小</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.&lt;br&gt;Netty是一个异步事件驱动的网络应用程序框架用于快速开发可维护的高性能协议服务器和客户端。&lt;/p&gt;</summary>
    
    
    
    <category term="后端学习" scheme="https://ykxzyp0517.cn/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="netty" scheme="https://ykxzyp0517.cn/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue的用法和底层实现原理</title>
    <link href="https://ykxzyp0517.cn/2020/11/16/PriorityQueue%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ykxzyp0517.cn/2020/11/16/PriorityQueue%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-16T14:51:00.000Z</published>
    <updated>2022-11-16T15:13:45.073Z</updated>
    
    <content type="html"><![CDATA[<p>队列是遵循先进先出（First-In-First-Out）模式的，但有时需要在队列中基于优先级处理对象。<br>举两个例子：  </p><ul><li>作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。<span id="more"></span></li><li>每日交易时段生成股票报告的应用程序中，需要处理大量数据并且花费很多处理时间。客户向这个应用程序发送请求时，实际上就进入了队列。我们需要首先处理优先客户再处理普通用户。在这种情况下，Java的PriorityQueue(优先队列)会很有帮助。</li></ul><p>PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。  </p><p><img data-src="/images/pasted-354.png" alt="upload successful">  </p><p>优先队列的作用是能保证每次取出的元素都是队列中<code>权值最小</code>的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，元素大小的评判。可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较（Comparator，类似于C++的仿函数）。</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><pre><code>public boolean add(E e); //在队尾插入元素，插入失败时抛出异常，并调整堆结构public boolean offer(E e); //在队尾插入元素，插入失败时抛出false，并调整堆结构public E remove(); //获取队头元素并删除，并返回，失败时前者抛出异常，再调整堆结构public E poll(); //获取队头元素并删除，并返回，失败时前者抛出null，再调整堆结构public E element(); //返回队头元素（不删除），失败时前者抛出异常public E peek()；//返回队头元素（不删除），失败时前者抛出nullpublic boolean isEmpty(); //判断队列是否为空public int size(); //获取队列中元素个数public void clear(); //清空队列public boolean contains(Object o); //判断队列中是否包含指定元素（从队头到队尾遍历）public Iterator&lt;E&gt; iterator(); //迭代器</code></pre><h1 id="堆结构调整"><a href="#堆结构调整" class="headerlink" title="堆结构调整"></a>堆结构调整</h1><p>每次插入或删除元素后，都对队列进行调整，使得队列始终构成最小堆（或最大堆）。</p><p>具体调整如下：</p><ul><li><p>插入元素后，从堆底到堆顶调整堆；</p></li><li><p>删除元素后，将队尾元素复制到队头，并从堆顶到堆底调整堆。</p></li></ul><h1 id="小根堆结构调整"><a href="#小根堆结构调整" class="headerlink" title="小根堆结构调整"></a>小根堆结构调整</h1><p>插入（ add()和offer()方法 ）元素后，向上调整堆：</p><pre><code>//siftUp()private void siftUp(int k, E x) &#123;    while (k &gt; 0) &#123;        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2        Object e = queue[parent];        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法            break;        queue[k] = e;        k = parent;    &#125;    queue[k] = x;&#125;</code></pre><p>删除（ remove()和poll()方法 ）元素后，向下调整堆： </p><pre><code>//siftDown()private void siftDown(int k, E x) &#123;    int half = size &gt;&gt;&gt; 1;    while (k &lt; half) &#123;        //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1        Object c = queue[child];        int right = child + 1;        if (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; 0)            c = queue[child = right];        if (comparator.compare(x, (E) c) &lt;= 0)            break;        queue[k] = c;//然后用c取代原来的值        k = child;    &#125;    queue[k] = x;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;队列是遵循先进先出（First-In-First-Out）模式的，但有时需要在队列中基于优先级处理对象。&lt;br&gt;举两个例子：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://ykxzyp0517.cn/2020/09/03/LeetCode/"/>
    <id>https://ykxzyp0517.cn/2020/09/03/LeetCode/</id>
    <published>2020-09-03T13:59:00.000Z</published>
    <updated>2022-12-05T15:17:57.471Z</updated>
    
    <content type="html"><![CDATA[<p>只是简简单单记录一下自己的刷题经历，希望一些理解能够对大家有所帮助，不足之处也许望大家指正哦O.o</p><span id="more"></span><h2 id="（1）数组"><a href="#（1）数组" class="headerlink" title="（1）数组"></a>（1）数组</h2><h3 id="num26-删除有序数组中的重复项（快慢指针问题）"><a href="#num26-删除有序数组中的重复项（快慢指针问题）" class="headerlink" title="num26 删除有序数组中的重复项（快慢指针问题）"></a>num26 删除有序数组中的重复项（快慢指针问题）</h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p] != nums[q])&#123;</span><br><span class="line">                <span class="keyword">if</span> ((q - p) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                p ++;</span><br><span class="line">            &#125;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>q-p &gt; 1需要考虑在内，不然一个完全不相同的数组会做length次的原地复制</strong></p><h3 id="num27-移除元素-快慢指针问题"><a href="#num27-移除元素-快慢指针问题" class="headerlink" title="num27 移除元素(快慢指针问题)"></a>num27 移除元素(快慢指针问题)</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveElement</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//指向不等于val值的区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向当前待比较的数字</span></span><br><span class="line">        <span class="keyword">while</span> (q &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[q] != val)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((q - p) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    nums[++ p] = nums[q ++];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    p ++ ;</span><br><span class="line">                    q ++ ;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                q ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="num35-搜索插入位置"><a href="#num35-搜索插入位置" class="headerlink" title="num35 搜索插入位置"></a>num35 搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4<br>使用O(logn)复杂度往往采用二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="nums66-加一"><a href="#nums66-加一" class="headerlink" title="nums66 加一"></a>nums66 加一</h3><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1：</p><p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p><p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p><p>输入：digits &#x3D; [0]<br>输出：[1]<br><strong>需要注意一点：考虑到位上9的情况，只需要在数组的基础上操作，直接置为0</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length -<span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            digits[i] ++;</span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((digits[i] % <span class="number">10</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="nums88-合并两个有序数组"><a href="#nums88-合并两个有序数组" class="headerlink" title="nums88 合并两个有序数组"></a>nums88 合并两个有序数组</h3><p> 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p> </p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p><strong>方法1.直接将nums2放入nums1的尾部，然后使用Arrays.sort()排序<br>时间复杂度O((m+n)log(m+n) 空间复杂度O(log(m+n))  问题是没有考虑到数组有序的的特点<br>方法2.采用双指针方法，先将nums1进行copy然后挨个比较，将两个数组考虑成队列，挨个比较<br>O(m+n) O(m+n)</strong><br><strong>方法3.采用逆向双指针，为了防止覆盖的同时，充分利用nums1的长度，使用从后面往前遍历,一次比较两者中较大的数，放在数组的最后</strong>   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> nums1.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; p3 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (nums1[p1] &lt;= nums2[p3])&#123;</span><br><span class="line">               nums1[p2 --] = nums2[p3 --];</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p3])&#123;</span><br><span class="line">               nums1[p2 -- ] = nums1[ p1 --];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p3 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           nums1[p2 --] = nums2[p3 --];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="nums108-将有序数组转换为二叉搜索树"><a href="#nums108-将有序数组转换为二叉搜索树" class="headerlink" title="nums108 将有序数组转换为二叉搜索树"></a>nums108 将有序数组转换为二叉搜索树</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p> </p><p>示例 1：</p><p><img data-src="/images/pasted-33.png" alt="upload successful"></p><p>输入：nums &#x3D; [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p><p>示例 2：</p><p>输入：nums &#x3D; [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toBst(nums,left,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">toBst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = toBst(nums, left , mid -<span class="number">1</span>);</span><br><span class="line">        root.right = toBst(nums , mid + <span class="number">1</span> , right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>给定数组的升序排列，也就是说给了二叉搜索树的中序遍历的结果<br>给定中序遍历是不能够获得确定的二叉搜索树的，因为所有的节点都能作为树的根节点<br>那么如何确保是一颗平衡二叉搜索树呢？ 那么就要选中中间节点root，保证左右树的节点数量差不多</strong></p><h3 id="nums121-买卖股票的最佳时机-动态规划的思想"><a href="#nums121-买卖股票的最佳时机-动态规划的思想" class="headerlink" title="nums121 买卖股票的最佳时机(动态规划的思想)"></a>nums121 买卖股票的最佳时机(动态规划的思想)</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p> </p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; prices.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minValue &gt; prices[i])&#123;</span><br><span class="line">                minValue = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxProfit &lt; prices[i] - minValue)&#123;</span><br><span class="line">                maxProfit = prices[i] - minValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nums169-多数元素"><a href="#nums169-多数元素" class="headerlink" title="nums169 多数元素"></a>nums169 多数元素</h3><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><strong>解法1.hashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorityNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//记录元素 ：次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; mapjorityEntry = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapjorityEntry == <span class="literal">null</span> || entry.getValue() &gt; mapjorityEntry.getValue()) &#123;</span><br><span class="line">                mapjorityEntry = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapjorityEntry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法2：分治</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MajorityNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getMajorityEmlemnt(nums , <span class="number">0</span> , nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMajorityEmlemnt</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getMajorityEmlemnt(nums , l , mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getMajorityEmlemnt(nums , mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> getElementCount(nums , left , l , r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> getElementCount(nums , right , l , r);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getElementCount</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> right, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l ; i &lt;= r; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == right)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>投票法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">candiate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                candiate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (candiate == num)? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candiate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums485-最大连续-1-的个数"><a href="#nums485-最大连续-1-的个数" class="headerlink" title="nums485 最大连续 1 的个数"></a>nums485 最大连续 1 的个数</h3><p>给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,0,1,1,1]<br>输出：3<br>解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.<br>示例 2:</p><p>输入：nums &#x3D; [1,0,1,1,0,1]<br>输出：2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount)&#123;</span><br><span class="line">                    maxCount = count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums495-提莫攻击"><a href="#nums495-提莫攻击" class="headerlink" title="nums495 提莫攻击"></a>nums495 提莫攻击</h3><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p>当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。</p><p>正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。</p><p>给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。</p><p>返回艾希处于中毒状态的 总 秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPoisonedDuration</span><span class="params">(<span class="type">int</span>[] timeSeries, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expired</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; timeSeries.length ;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timeSeries[i] &gt; expired)&#123;</span><br><span class="line">                ans += duration;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += timeSeries[i] + duration - expired;</span><br><span class="line">            &#125;</span><br><span class="line">            expired = timeSeries[i] + duration;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过expired判断右边界，判断timeSeries[i] + duration 是否在边界内</strong></p><h3 id="nums697-数组的度"><a href="#nums697-数组的度" class="headerlink" title="nums697 数组的度"></a>nums697 数组的度</h3><p>给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。<br><strong>考虑到一个数组的子数组的最大度一定是最左边和最右边都是这个最大度的数，通过hashmap记录最大度的同时，记录下每个数在数组中的位置，通过位置获取相应的子数组的长度</strong><br><em><strong>key：可以通过hashmap的value数组的形式记录想要知道的信息</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindShortestSubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findShortestSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, <span class="type">int</span>[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span> , i , i&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.get(nums[i])[<span class="number">0</span>] ++;</span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span> , minLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer , <span class="type">int</span>[]&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span>[] ins = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (maxLen &lt; ins[<span class="number">0</span>])&#123;</span><br><span class="line">                maxLen = ins[<span class="number">0</span>];</span><br><span class="line">                minLen = ins[<span class="number">2</span>] - ins[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxLen == ins[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (minLen &gt; ins[<span class="number">2</span>] - ins[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = ins[<span class="number">2</span>] - ins[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nums448-找到所有数组中消失的数字"><a href="#nums448-找到所有数组中消失的数字" class="headerlink" title="nums448 找到所有数组中消失的数字"></a>nums448 找到所有数组中消失的数字</h3><p>方法一：使用hashmap,空间复杂度为o(n)不是很理想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; disNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num , map.getOrDefault(num , <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(i , <span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                disNums.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：因为数组本身的长度也为n，所以可以将数组本身作为一张hash表。如果一个数x存在，那么nums[x - 1]加上n。建立索引和数的关系。随后对数组进行遍历，如果nums[x]的值小于等于数组的长度，那么说明不存在x + 1这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindDisappearedNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; disNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            map.put(num , map.getOrDefault(num , <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(i , <span class="number">0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                disNums.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> disNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums442-数组中重复的数据"><a href="#nums442-数组中重复的数据" class="headerlink" title="nums442 数组中重复的数据"></a>nums442 数组中重复的数据</h3><p>给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。</p><p><strong>使用偏移量或者取反的方式进行区分，类似于hashmap的原理</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[Math.abs(num) - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(Math.abs(num));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[Math.abs(num) - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nums41-缺失的第一个正数"><a href="#nums41-缺失的第一个正数" class="headerlink" title="nums41 缺失的第一个正数"></a>nums41 缺失的第一个正数</h3><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ; i ++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums , nums[i] - <span class="number">1</span> , i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len ;i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> a , <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目要求使用常数级别的额外空间，那么hash表自然不会考虑。那么可以考虑使用数据的元素与数组索引的联系。nums[i] 与 nums[nums[i] - 1]的hash映射。<br>我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；<br>那么，我们可以采取这样的思路：  </p><ul><li>就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。  </li><li>然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</li><li>这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。</li></ul><h3 id="nums453-最小操作次数使数组元素相等"><a href="#nums453-最小操作次数使数组元素相等" class="headerlink" title="nums453 最小操作次数使数组元素相等"></a>nums453 最小操作次数使数组元素相等</h3><p>主要的问题就是思考数组「原始最小值」与「最小操作次数」关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>] , sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            min = Math.min(min , num);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(sum - min * len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums665-非递减数列-贪心策略"><a href="#nums665-非递减数列-贪心策略" class="headerlink" title="nums665 非递减数列(贪心策略)"></a>nums665 非递减数列(贪心策略)</h3><p>给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;&#x3D; i &lt;&#x3D; n-2)，总满足 nums[i] &lt;&#x3D; nums[i + 1]。<br>贪心算法</p><p>本题是要维持一个非递减的数列，所以遇到递减的情况时（nums[i] &gt; nums[i + 1]），要么将前面的元素缩小，要么将后面的元素放大。</p><p>但是本题唯一的易错点就在这，</p><p>如果将nums[i]缩小，可能会导致其无法融入前面已经遍历过的非递减子数列；<br>如果将nums[i + 1]放大，可能会导致其后续的继续出现递减；<br>所以要采取贪心的策略，在遍历时，每次需要看连续的三个元素，也就是瞻前顾后，遵循以下两个原则：</p><p>需要尽可能不放大nums[i + 1]，这样会让后续非递减更困难；<br>如果缩小nums[i]，但不破坏前面的子序列的非递减性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPossibility</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> nums[<span class="number">0</span>] &lt;= nums[<span class="number">1</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span> ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i + <span class="number">1</span>] &gt;= nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">                        </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums283-移动零"><a href="#nums283-移动零" class="headerlink" title="nums283 移动零"></a>nums283 移动零</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                p2 ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[p1];</span><br><span class="line">                nums[p1] = nums[p2];</span><br><span class="line">                nums[p2] = tmp;</span><br><span class="line">                p1 ++;</span><br><span class="line">                p2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums304-二维区域和检索-矩阵不可变（二维数组前缀和）"><a href="#nums304-二维区域和检索-矩阵不可变（二维数组前缀和）" class="headerlink" title="nums304 二维区域和检索 - 矩阵不可变（二维数组前缀和）"></a>nums304 二维区域和检索 - 矩阵不可变（二维数组前缀和）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] preSumMartix;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        preSumMartix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m ; j++)&#123;</span><br><span class="line">                preSumMartix[i][j] = preSumMartix[i - <span class="number">1</span>][j] + preSumMartix[i][j - <span class="number">1</span>] - preSumMartix[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        row1 ++;</span><br><span class="line">        row2 ++;</span><br><span class="line">        col1 ++;</span><br><span class="line">        col2 ++;</span><br><span class="line">        <span class="keyword">return</span> preSumMartix[row2][col2] - preSumMartix[row1 - <span class="number">1</span>][col2] - preSumMartix[row2][col1 - <span class="number">1</span>] + preSumMartix[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="nums419-甲板上的战舰"><a href="#nums419-甲板上的战舰" class="headerlink" title="nums419 甲板上的战舰"></a>nums419 甲板上的战舰</h3><p>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。</p><p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBattleships</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; board.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; board[<span class="number">0</span>].length ;j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i &gt; <span class="number">0</span> )&amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>((j &gt; <span class="number">0</span>) &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改数组的情况下，可以将遍历过的元素调整为’.’;</p><h3 id="nums189-轮转数组"><a href="#nums189-轮转数组" class="headerlink" title="nums189 轮转数组"></a>nums189 轮转数组</h3><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= len;</span><br><span class="line">        reverse(nums , <span class="number">0</span> , len - <span class="number">1</span>);</span><br><span class="line">        reverse(nums , <span class="number">0</span> , k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums , k , len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> start , <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = tmp;</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums396-旋转数组"><a href="#nums396-旋转数组" class="headerlink" title="nums396 旋转数组"></a>nums396 旋转数组</h3><p>给定一个长度为 n 的整数数组 nums 。</p><p>假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：</p><p>F(k) &#x3D; 0 * arrk[0] + 1 * arrk[1] + … + (n - 1) * arrk[n - 1]<br>返回 F(0), F(1), …, F(n-1)中的最大值 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxRotateFunction</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumNums</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n  ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            f += i * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = f;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n - <span class="number">1</span> ; k &gt; <span class="number">0</span>  ; k--)&#123;</span><br><span class="line">            f += sumNums - n * nums[k];</span><br><span class="line">            res = Math.max(f, res);</span><br><span class="line">            </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p> </p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums59-螺旋矩阵2"><a href="#nums59-螺旋矩阵2" class="headerlink" title="nums59 螺旋矩阵2"></a>nums59 螺旋矩阵2</h3><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123; <span class="number">0</span> , <span class="number">1</span> &#125; , &#123; <span class="number">1</span> , <span class="number">0</span> &#125; , &#123;<span class="number">0</span> , -<span class="number">1</span>&#125; , &#123; -<span class="number">1</span> , <span class="number">0</span> &#125;&#125;;</span><br><span class="line">        <span class="type">boolean</span>[][] vistied = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">directionIndex</span> <span class="operator">=</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> ; m &lt;= n * n ; m ++)&#123;</span><br><span class="line">            res[i][j] = m;</span><br><span class="line">            vistied[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextI</span> <span class="operator">=</span> i + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextJ</span> <span class="operator">=</span> j + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextI &lt; <span class="number">0</span> || nextI &gt;= res.length || nextJ &lt; <span class="number">0</span> || nextJ &gt;= res[<span class="number">0</span>].length || vistied[nextI][nextJ])&#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            j = j + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums566-重塑矩阵"><a href="#nums566-重塑矩阵" class="headerlink" title="nums566 重塑矩阵"></a>nums566 重塑矩阵</h3><p>在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。</p><p>给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。</p><p>如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] matrixReshape(<span class="type">int</span>[][] mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m * n != r * c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m * n ; i ++)&#123;</span><br><span class="line">            res[i / c][i % c] = mat[i / n][i % n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums48-旋转图像"><a href="#nums48-旋转图像" class="headerlink" title="nums48 旋转图像"></a>nums48 旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p><img data-src="/images/pasted-154.png" alt="upload successful"><br>可以根据计算得出每一个点的下一位置，然后找到完整的传递关系模拟旋转的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n / <span class="number">2</span> ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; (n + <span class="number">1</span>)/<span class="number">2</span>; j ++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span>- i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span>- i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums73-矩阵置0"><a href="#nums73-矩阵置0" class="headerlink" title="nums73 矩阵置0"></a>nums73 矩阵置0</h3><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p><p><img data-src="/images/pasted-155.png" alt="upload successful"><br>采用标记位的方法进行标记，可以直接使用两个boolean数据进行标记，但是空间复杂度为O(m+n)，那么就可以考虑使用数组的第一列和第一行作为标记位，因为只要在这个行列上出现了0，那么这个位置本来也会被置0，并不会影响数据的同时，还能起到标记的作用。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rowFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">colFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                colFlag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                rowFlag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; m ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[<span class="number">0</span>][j] == <span class="number">0</span> || matrix[i][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rowFlag)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(colFlag)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i ++)&#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums303-区域和检索-数组不可变"><a href="#nums303-区域和检索-数组不可变" class="headerlink" title="nums303 区域和检索 - 数组不可变"></a>nums303 区域和检索 - 数组不可变</h3><p>给定一个整数数组  nums，处理以下类型的多个查询:</p><p>计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：</p><p>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] )</p><p>考虑到假如每次进行sumRange都进行一次循环数组的话，那么当调用次数多了以后，时间复杂度会非常的巨大，因此我要考虑的是在sumRange调用之前，函数构造的时候就是用前缀和的方式计算好每个index的前缀和。sumRange的结果为： sums[right] - sums[left - 1];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sums;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> sums[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sums[right] - sums[left - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums304-二维区域和检索-矩阵不可变"><a href="#nums304-二维区域和检索-矩阵不可变" class="headerlink" title="nums304 二维区域和检索 - 矩阵不可变"></a>nums304 二维区域和检索 - 矩阵不可变</h3><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p><p>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 NumMatrix 类：</p><p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] mat;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        mat = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= matrix.length ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= matrix[<span class="number">0</span>].length ; j ++)&#123;</span><br><span class="line">                mat[i][j] = mat[i - <span class="number">1</span>][j] + mat[i][j - <span class="number">1</span>] - mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        row1 ++ ;</span><br><span class="line">        col1 ++;</span><br><span class="line">        row2 ++;</span><br><span class="line">        col2 ++;</span><br><span class="line">        <span class="keyword">return</span> mat[row2][col2] - mat[row2][col1 - <span class="number">1</span>] - mat[row1 - <span class="number">1</span>][col2] + mat[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nums238-除自身以外数组的乘积"><a href="#nums238-除自身以外数组的乘积" class="headerlink" title="nums238 除自身以外数组的乘积"></a>nums238 除自身以外数组的乘积</h3><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; nums.length ; i ++)&#123;</span><br><span class="line">            res[i] = nums[i - <span class="number">1</span>] * res[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        res[nums.length - <span class="number">1</span>] *= R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">            R = nums[i + <span class="number">1</span>] * R;</span><br><span class="line">            res[i] *= R; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的思路：求一个的值，就是求他的前缀和后缀的乘积，那么可以先用两个等长的数组，记录每个位置的前缀和后缀的乘积值，然后每个位置对应相乘就能得到结果。<br>为了得到O(1）的空间复杂度，那么可以将res数组作为L，动态的规划R变量作为每一次的后缀乘积，直接乘在res对应的位置，就可以完成。</p><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="(2)字符串"></a>(2)字符串</h2><h3 id="nums520-检测大写字母"><a href="#nums520-检测大写字母" class="headerlink" title="nums520 检测大写字母"></a>nums520 检测大写字母</h3><p>我们定义，在以下情况时，单词的大写用法是正确的：</p><p>全部字母都是大写，比如 “USA” 。<br>单词中所有字母都不是大写，比如 “leetcode” 。<br>如果单词不只含有一个字母，只有首字母大写， 比如 “Google” 。<br>给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">detectCapitalUse</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(word.length() &gt;=<span class="number">2</span> &amp;&amp; Character.isLowerCase(word.charAt(<span class="number">0</span>)) &amp;&amp; Character.isUpperCase(word.charAt(<span class="number">1</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; word.length() ; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLowerCase(word.charAt(i)) ^ Character.isLowerCase(word.charAt(<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种情况 ：  </p><ul><li>1.假如第一个字母为小写，第二个字母不能为大写</li><li>2.不论第一个字母是大小写，第三个字母开始的所有字母都要和第二个字母的大小写相同</li></ul><h3 id="nums125-验证回文串"><a href="#nums125-验证回文串" class="headerlink" title="nums125 验证回文串"></a>nums125 验证回文串</h3><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left)))&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right)))&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left ++;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了降低空间复杂度不使用StringBuffer的额外空间，使用双指针的方法进行判断。<br>加强对Character类的理解。  </p><h3 id="nums14-最长公共前缀"><a href="#nums14-最长公共前缀" class="headerlink" title="nums14 最长公共前缀"></a>nums14 最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。  </p><pre><code class="java">class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs == null)&#123;            return &quot;&quot;;        &#125;        String res = strs[0];        for(int i = 1 ; i &lt; strs.length ; i ++)&#123;            int j = 0 ;            for( ; j &lt; res.length() &amp;&amp; j &lt; strs[i].length() ; j ++)&#123;                if(res.charAt(j) != strs[i].charAt(j))&#123;                    break;                &#125;            &#125;            res = res.substring(0 , j);            if(res == &quot;&quot;)&#123;                return res;            &#125;        &#125;        return res;            &#125;        &#125;</code></pre><h3 id="nums434-字符串中的单词数"><a href="#nums434-字符串中的单词数" class="headerlink" title="nums434 字符串中的单词数"></a>nums434 字符串中的单词数</h3><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><pre><code class="java">class Solution &#123;    public int countSegments(String s) &#123;        boolean isEmpty = true;        int resCount = 0;        for(int i = 0 ; i &lt; s.length() ; i ++ )&#123;            if(isEmpty &amp;&amp; s.charAt(i) != &#39; &#39;)&#123;                resCount ++;                isEmpty = false;            &#125;            if(s.charAt(i) == &#39; &#39;)&#123;                isEmpty = true;            &#125;        &#125;        return resCount;    &#125;&#125;</code></pre><h3 id="剑指Offer05-替换空格"><a href="#剑指Offer05-替换空格" class="headerlink" title="剑指Offer05 替换空格"></a>剑指Offer05 替换空格</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        StringBuilder sb = new StringBuilder();        for(int i = 0 ; i &lt; s.length() ; i ++)&#123;            if(s.charAt(i) == &#39; &#39;)&#123;                sb.append(&quot;%20&quot;);                continue;            &#125;            sb.append(s.charAt(i));        &#125;            return sb.toString();            &#125;&#125;</code></pre><p>需要记住的是String是不可变的 不能直接在上面操作，而是需要重新开辟一个字符串  </p><h3 id="nums58-最后一个单词的长度"><a href="#nums58-最后一个单词的长度" class="headerlink" title="nums58 最后一个单词的长度"></a>nums58 最后一个单词的长度</h3><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 </p><pre><code>class Solution &#123;    public int lengthOfLastWord(String s) &#123;        int end = s.length() - 1;        while(end &gt;= 0 &amp;&amp; s.charAt(end) == &#39; &#39;)&#123;            end -- ;        &#125;        if(end &lt; 0)&#123;            return 0;        &#125;        int start = end;        while(start &gt;= 0 &amp;&amp; s.charAt(start) != &#39; &#39;)&#123;            start --;        &#125;        return end - start;    &#125;&#125;</code></pre><p>我用的方法还是循规蹈矩的从前往后找最后一个单词的位置，然后再统计长度。但是往往可以采用的是逆向思维，我从后往前找，那么找到的第一个单词必然就是最后一个单词了。然后就能更快的得到结果。  </p><h3 id="nums344-反转字符串"><a href="#nums344-反转字符串" class="headerlink" title="nums344 反转字符串"></a>nums344 反转字符串</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>so easy  </p><pre><code>class Solution &#123;    public void reverseString(char[] s) &#123;        int left = 0 , right = s.length - 1;        while(left &lt; right)&#123;            char tem = s[left];            s[left] = s[right];            s[right] = tem;            left ++;            right --;        &#125;    &#125;&#125;</code></pre><h3 id="剑指Offer06-从尾到头输出链表"><a href="#剑指Offer06-从尾到头输出链表" class="headerlink" title="剑指Offer06 从尾到头输出链表"></a>剑指Offer06 从尾到头输出链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。  </p><blockquote><p>方法1：采用递归的方式，依次放入值  </p></blockquote><pre><code>class Solution &#123;    ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();    public int[] reversePrint(ListNode head) &#123;        recur(head);        int[] res = new int[tmp.size()];        for(int i = 0 ; i &lt; res.length ; i ++)&#123;            res[i] = tmp.get(i);        &#125;        return res;    &#125;    void recur(ListNode head)&#123;        if(head == null)&#123;            return;        &#125;        int var = head.val;        recur(head.next);        tmp.add(var);    &#125;&#125;  </code></pre><blockquote><p>方法2：使用栈空间  </p></blockquote><pre><code>class Solution &#123;    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();    public int[] reversePrint(ListNode head) &#123;        while(head != null)&#123;            stack.addLast(head.val);            head = head.next;        &#125;        int[] res = new int[stack.size()];        for(int i = 0 ; i &lt; res.length ; i ++)&#123;            res[i] = stack.removeLast();        &#125;        return res;    &#125;&#125;</code></pre><h3 id="nums541-反转字符串-II"><a href="#nums541-反转字符串-II" class="headerlink" title="nums541 反转字符串 II"></a>nums541 反转字符串 II</h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><pre><code>class Solution &#123;    public String reverseStr(String s, int k) &#123;        int len = s.length();        char[] word = s.toCharArray();        for(int l = 0 ; l &lt; len ; l = l + 2 * k)&#123;            int r = l + k -1;            reverse(word , l , Math.min(r , len - 1));        &#125;        return String.valueOf(word);    &#125;    void reverse(char[] res ,int  l , int r)&#123;            while(l &lt; r)&#123;                char tmp = res[l];                res[l] = res[r];                res[r] = tmp;                l ++ ;                 r -- ;            &#125;    &#125;&#125;</code></pre><h3 id="nums387-字符串中的第一个唯一字符"><a href="#nums387-字符串中的第一个唯一字符" class="headerlink" title="nums387 字符串中的第一个唯一字符"></a>nums387 字符串中的第一个唯一字符</h3><p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。</p><pre><code>class Solution &#123;    public int firstUniqChar(String s) &#123;        Map&lt;Character , Integer&gt; map = new HashMap&lt;&gt;();        char[] ch = s.toCharArray();        for(int i = 0 ; i &lt; s.length() ; i ++)&#123;            map.put(ch[i], map.getOrDefault(ch[i] , 0)+ 1);        &#125;        for(int i = 0 ; i &lt; s.length() ; i ++)&#123;            if(map.get(ch[i]) == 1)&#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><h3 id="nums389-找不同"><a href="#nums389-找不同" class="headerlink" title="nums389 找不同"></a>nums389 找不同</h3><p>给定两个字符串 s 和 t ，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><pre><code>class Solution &#123;    public char findTheDifference(String s, String t) &#123;        int[] cnt = new int[26];        for(int i = 0 ; i &lt; s.length() ; i ++)&#123;            cnt[s.charAt(i) - &#39;a&#39;] ++;        &#125;        for(int i = 0 ; i &lt; t.length() ; i ++)&#123;            cnt[t.charAt(i) - &#39;a&#39;] --;            if(cnt[t.charAt(i) - &#39;a&#39;]  &lt;  0)&#123;                return t.charAt(i);            &#125;        &#125;        return &#39; &#39;;    &#125;&#125;</code></pre><h3 id="nums383-赎金信"><a href="#nums383-赎金信" class="headerlink" title="nums383 赎金信"></a>nums383 赎金信</h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><pre><code>class Solution &#123;    public boolean canConstruct(String ransomNote, String magazine) &#123;        int[] ans = new int[26];        boolean res = true;        for(int i = 0 ; i &lt; magazine.length(); i ++)&#123;            ans[magazine.charAt(i) - &#39;a&#39;] ++;        &#125;        for(int i = 0 ; i &lt; ransomNote.length() ; i ++)&#123;            char cur = ransomNote.charAt(i);            ans[cur - &#39;a&#39;] --;            if(ans[cur - &#39;a&#39;] &lt; 0)&#123;                return false;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h3 id="nums242-有效的字母异位词"><a href="#nums242-有效的字母异位词" class="headerlink" title="nums242 有效的字母异位词"></a>nums242 有效的字母异位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><pre><code>class Solution &#123;    public boolean isAnagram(String s, String t) &#123;        if(s.length() != t.length())&#123;            return false;        &#125;        int[] ans = new int[26];        for(int i = 0 ; i &lt; s.length() ; i ++)&#123;            ans[s.charAt(i) - &#39;a&#39;] ++;        &#125;        for(int i = 0 ; i &lt; t.length() ; i ++)&#123;            ans[t.charAt(i) - &#39;a&#39;] --;            if(ans[t.charAt(i) - &#39;a&#39;] &lt; 0)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre><h3 id="nums49-字母异位词分组"><a href="#nums49-字母异位词分组" class="headerlink" title="nums49 字母异位词分组"></a>nums49 字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><pre><code>class Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        return  new ArrayList(Arrays.stream(strs)                                .collect(Collectors.groupingBy(str -&gt; &#123;                                    char[] array = str.toCharArray();                                    Arrays.sort(array);                                    return new String(array);                                &#125;)).values());    &#125;&#125;</code></pre><h3 id="nums451-根据字符出现频率排序"><a href="#nums451-根据字符出现频率排序" class="headerlink" title="nums451 根据字符出现频率排序"></a>nums451 根据字符出现频率排序</h3><p>给定一个字符串 s ，根据字符出现的 频率 对其进行 降序排序 。一个字符出现的 频率 是它出现在字符串中的次数。</p><p>返回 已排序的字符串 。如果有多个答案，返回其中任何一个。</p><pre><code>class Solution &#123;    public String frequencySort(String s) &#123;        HashMap&lt;Character , Integer&gt;  headmap = new HashMap&lt;&gt;();        char[] array = s.toCharArray();        for(char d : array)&#123;            headmap.put(d , headmap.getOrDefault(d , 0) + 1);        &#125;         PriorityQueue&lt;Character&gt; headQueue = new PriorityQueue&lt;&gt;((a , b) -&gt; &#123;            if(headmap.get(a) != headmap.get(b))&#123;                return headmap.get(b) - headmap.get(a);            &#125;else &#123;                return a - b;            &#125;        &#125;);        for(char c : headmap.keySet())&#123;            headQueue.offer(c);        &#125;        StringBuilder sb = new StringBuilder();        while(!headQueue.isEmpty())&#123;            char c = headQueue.poll();            int k = headmap.get(c);            while(k &gt; 0)&#123;                sb.append(c);                k -- ;            &#125;        &#125;        return sb.toString();    &#125;&#125;</code></pre><h2 id="nums657-机器人能否返回原点"><a href="#nums657-机器人能否返回原点" class="headerlink" title="nums657 机器人能否返回原点"></a>nums657 机器人能否返回原点</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</p><p>移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。</p><p>如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p><p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p><pre><code>  class Solution &#123;      public boolean judgeCircle(String moves) &#123;          int[][] dir = new int[][]&#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; // 上下左右          int originX = 0;          int originY = 0;          for(char c : moves.toCharArray())&#123;              if(c == &#39;U&#39;)&#123;                  originX += dir[0][0];                  originY += dir[0][1];              &#125;              if(c == &#39;D&#39;)&#123;                  originX += dir[1][0];                  originY += dir[1][1];              &#125;              if(c == &#39;L&#39;)&#123;                  originX += dir[2][0];                  originY += dir[2][1];              &#125;              if(c == &#39;R&#39;)&#123;                  originX += dir[3][0];                  originY += dir[3][1];              &#125;          &#125;          if(originX == 0 &amp;&amp; originY == 0)&#123;              return true;          &#125;          return false;      &#125;  &#125;  </code></pre><h2 id="nums551-学生出勤记录-I"><a href="#nums551-学生出勤记录-I" class="headerlink" title="nums551 学生出勤记录 I"></a>nums551 学生出勤记录 I</h2><p>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p><p>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p><p>按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p><pre><code>  class Solution &#123;      public boolean checkRecord(String s) &#123;          int absentCount = 0;          int lateAlways = 0;          char[] word = s.toCharArray();          for(int i = 0 ; i &lt; word.length ; i ++)&#123;              if(word[i] == &#39;A&#39;)&#123;                  absentCount ++;                  if(absentCount &gt;= 2)&#123;                      return false;                  &#125;              &#125;              if(word[i] == &#39;L&#39;)&#123;                  lateAlways ++;                  if(lateAlways &gt;= 3)&#123;                      return false;                  &#125;                  continue;              &#125;              lateAlways = 0;          &#125;          return true;      &#125;  &#125;</code></pre><h2 id="nums696-计数二进制子串"><a href="#nums696-计数二进制子串" class="headerlink" title="nums696 计数二进制子串"></a>nums696 计数二进制子串</h2><p>给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。</p><p>重复出现（不同位置）的子串也要统计它们出现的次数。  </p><pre><code>  class Solution &#123;      public int countBinarySubstrings(String s) &#123;          int p = 0 ,len = s.length();          int last = 0;          int ans = 0,count = 0;          while(p &lt; len)&#123;              char c = s.charAt(p);              while(p &lt; len &amp;&amp; s.charAt(p) == c)&#123;                  p ++;                  count ++;              &#125;              ans += Math.min(last ,count);              last = count;              count = 0;          &#125;          return ans;      &#125;  &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;只是简简单单记录一下自己的刷题经历，希望一些理解能够对大家有所帮助，不足之处也许望大家指正哦O.o&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://ykxzyp0517.cn/categories/leetcode/"/>
    
    
    <category term=" Data structure and algorithm" scheme="https://ykxzyp0517.cn/tags/Data-structure-and-algorithm/"/>
    
  </entry>
  
</feed>
