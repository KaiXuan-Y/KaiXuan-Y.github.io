<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ykxzyp0517.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.Netty是一个异步事件驱动的网络应用程序框架用于快速开发可维护的高性能协议服务器和客户端。">
<meta property="og:type" content="article">
<meta property="og:title" content="netty网络编程">
<meta property="og:url" content="https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Young&#39;s Land">
<meta property="og:description" content="Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.Netty是一个异步事件驱动的网络应用程序框架用于快速开发可维护的高性能协议服务器和客户端。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-0.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-1.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-3.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-4.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-5.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-6.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-7.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-8.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-21.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-22.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-23.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-24.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-25.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-26.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-27.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-28.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-29.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-31.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-34.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-35.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-36.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-37.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-38.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-40.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-39.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-41.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-43.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-52.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-55.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-54.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-56.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-57.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-58.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-59.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-60.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-61.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-62.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-63.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-64.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-68.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-69.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-72.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-73.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-74.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-75.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-76.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-77.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-78.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-79.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-81.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-82.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-83.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-84.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-85.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-86.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-87.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-88.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-89.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-90.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-91.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-92.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-94.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-93.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-95.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-96.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-97.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-98.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-99.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-100.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-101.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-102.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-103.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-104.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-105.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-106.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-107.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-108.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-109.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-110.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-111.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-112.png">
<meta property="article:published_time" content="2021-09-02T05:11:00.000Z">
<meta property="article:modified_time" content="2022-10-26T14:20:20.448Z">
<meta property="article:author" content="KaiXuan Young">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ykxzyp0517.cn/images/pasted-0.png">


<link rel="canonical" href="https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","path":"2021/09/02/netty网络编程/","title":"netty网络编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>netty网络编程 | Young's Land</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Young's Land" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Young's Land</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习和日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">3</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-NIO%E5%9F%BA%E7%A1%80"><span class="nav-text">一.NIO基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%89%E5%A4%A7-%E7%BB%84%E4%BB%B6"><span class="nav-text">1.三大 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Channel-amp-amp-Buffer"><span class="nav-text">1.1 Channel &amp;&amp; Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Selector-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-text">1.2 Selector 选择器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ByteBuffer"><span class="nav-text">2.ByteBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1ByteBuffer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="nav-text">2.1ByteBuffer的使用姿势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2ByteBuffer%E7%BB%93%E6%9E%84"><span class="nav-text">2.2ByteBuffer结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E6%BC%94%E7%A4%BA"><span class="nav-text">方法调用与演示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3ByteBuffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-text">2.3ByteBuffer常见方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cbytebuffer%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="nav-text">字符串和bytebuffer的相互转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4Scattering-Reads"><span class="nav-text">2.4Scattering Reads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0-%E9%BB%8F%E5%8C%85%E3%80%81%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1%EF%BC%89"><span class="nav-text">练习(黏包、半包现象）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="nav-text">3.文件编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E4%B8%A4%E4%B8%AAChannel%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="nav-text">3.1两个Channel传输数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2Path"><span class="nav-text">3.2Path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3Files"><span class="nav-text">3.3Files</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">4.网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E4%BD%BF%E7%94%A8NIO%E7%90%86%E8%A7%A3%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.1使用NIO理解阻塞模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E4%BD%BF%E7%94%A8NIO%E7%90%86%E8%A7%A3%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.2使用NIO理解非阻塞模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E4%BD%BF%E7%94%A8selector%E5%A4%84%E7%90%86%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.3使用selector处理非阻塞模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98"><span class="nav-text">4.4消息边界问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6"><span class="nav-text">4.5可写事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="nav-text">4.6利用多线程优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-NIO-vs-BIO"><span class="nav-text">4.7 NIO vs BIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-text">4.8 零拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-Netty%E5%85%A5%E9%97%A8"><span class="nav-text">二.Netty入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-hello-world"><span class="nav-text">2.hello world</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BB%84%E4%BB%B6"><span class="nav-text">3.组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1EventLoop"><span class="nav-text">3.1EventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-text">3.2线程切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Channel"><span class="nav-text">3.3 Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-channelFuture%E5%A4%84%E7%90%86%E5%85%B3%E9%97%AD"><span class="nav-text">3.4 channelFuture处理关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="nav-text">3.5 为什么要使用异步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Future-amp-Promise"><span class="nav-text">3.6 Future &amp; Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Handler-amp-Pipeline"><span class="nav-text">3.7 Handler &amp; Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-embeddedChannel"><span class="nav-text">3.8 embeddedChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-ByteBuf"><span class="nav-text">3.9 ByteBuf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81netty%E8%BF%9B%E9%98%B6"><span class="nav-text">三、netty进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85"><span class="nav-text">1.粘包半包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E7%B2%98%E5%8C%85-%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-text">1.1粘包,半包现象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">1.2 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%A7%A3%E5%86%B31%EF%BC%9A%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-text">1.3 解决1：短连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%A7%A3%E5%86%B32%EF%BC%9A%E5%AE%9A%E9%95%BF%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">1.4 解决2：定长解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E8%A7%A3%E5%86%B33%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%86%E9%9A%94%E7%AC%A6%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C"><span class="nav-text">1.5 解决3：使用分隔符处理消息边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E8%A7%A3%E5%86%B34%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">1.7 解决4：基于长度字段的解码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="nav-text">2.协议设计与解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-text">2.1 为什么需要协议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%B4%A0"><span class="nav-text">2.2 自定义协议要素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="nav-text">3.聊天室</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%99%BB%E5%BD%95"><span class="nav-text">3.1 登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E8%8F%9C%E5%8D%95"><span class="nav-text">3.2菜单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E7%BE%A4%E7%BB%84"><span class="nav-text">3.3 创建群组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%8F%91%E8%B5%B7%E7%BE%A4%E8%81%8A"><span class="nav-text">3.4 发起群聊</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E9%80%80%E5%87%BA%E5%A4%84%E7%90%86"><span class="nav-text">3.5 退出处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%81%87%E6%AD%BB%EF%BC%89"><span class="nav-text">3.6 空闲检测（连接假死）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%BF%83%E8%B7%B3"><span class="nav-text">3.7 心跳</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BC%98%E5%8C%96"><span class="nav-text">四、优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-text">1.优化算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%89%A9%E5%B1%95%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-text">1.1 扩展序列化算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0"><span class="nav-text">2.参数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KaiXuan Young"
      src="/images/headimage.jpg">
  <p class="site-author-name" itemprop="name">KaiXuan Young</p>
  <div class="site-description" itemprop="description">NO PAIN , NO GAIN</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/KaiXuan-Y" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KaiXuan-Y" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1730052751@qq.com" title="E-Mail → mailto:1730052751@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/KaiXuan-Y" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headimage.jpg">
      <meta itemprop="name" content="KaiXuan Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Young's Land">
      <meta itemprop="description" content="NO PAIN , NO GAIN">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="netty网络编程 | Young's Land">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          netty网络编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-02 13:11:00" itemprop="dateCreated datePublished" datetime="2021-09-02T13:11:00+08:00">2021-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-26 22:20:20" itemprop="dateModified" datetime="2022-10-26T22:20:20+08:00">2022-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">后端学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.<br>Netty是一个异步事件驱动的网络应用程序框架用于快速开发可维护的高性能协议服务器和客户端。</p>
<span id="more"></span>
<h1 id="一-NIO基础"><a href="#一-NIO基础" class="headerlink" title="一.NIO基础"></a>一.NIO基础</h1><h2 id="1-三大-组件"><a href="#1-三大-组件" class="headerlink" title="1.三大 组件"></a>1.三大 组件</h2><p>non-blocking io 非阻塞IO</p>
<h3 id="1-1-Channel-amp-amp-Buffer"><a href="#1-1-Channel-amp-amp-Buffer" class="headerlink" title="1.1 Channel &amp;&amp; Buffer"></a>1.1 Channel &amp;&amp; Buffer</h3><p>Channel:数据的传输通道，读写的双向同道.<br>可以从channel将数据读入buffer，也可以将buffer的数据写入channel。</p>
<h3 id="1-2-Selector-选择器"><a href="#1-2-Selector-选择器" class="headerlink" title="1.2 Selector 选择器"></a>1.2 Selector 选择器</h3><p><img data-src="/images/pasted-0.png" alt="upload successful"></p>
<p>传统多线程办的设计，一个socket对应一个thread处理</p>
<p><strong>缺点</strong></p>
<ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的情况<br>一个客户端用一个线程处理，线程的本身就会占用内存。客户端的连接数越多，内存溢出<br>线程数多，cpu得跟得上性能。</li>
</ul>
<p><img data-src="/images/pasted-1.png" alt="upload successful"><br>改进成线程池的设计缺点：</p>
<ul>
<li>阻塞模式下，线程只能能处理一个socket操作，线程的利用率不高</li>
<li>适合短连接场景</li>
</ul>
<p><img data-src="/images/pasted-3.png" alt="upload successful"><br>一个selector配合一个线程管理多个channel<br>工作在非阻塞模式下，第一个channel没有事件后会转到第二个channel进行处理</p>
<h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2.ByteBuffer"></a>2.ByteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileChannel</span></span><br><span class="line">        <span class="comment">//1.输入输出流， 2.RandomAccessFile</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="comment">//准备缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.flip(); <span class="comment">// 切换至读模式</span></span><br><span class="line">                <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">                    System.out.println((<span class="type">char</span>) b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换成写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1ByteBuffer的使用姿势"><a href="#2-1ByteBuffer的使用姿势" class="headerlink" title="2.1ByteBuffer的使用姿势"></a>2.1ByteBuffer的使用姿势</h3><ol>
<li>向buffer写入数据，channel.read(buffer)</li>
<li>buffer切换至读模式,buffer.flip()</li>
<li>从buffer中读数据，buffer.get()</li>
<li>调用clear()或compact()切换至写模式</li>
<li>重复1 - 4</li>
</ol>
<h3 id="2-2ByteBuffer结构"><a href="#2-2ByteBuffer结构" class="headerlink" title="2.2ByteBuffer结构"></a>2.2ByteBuffer结构</h3><p>ByteBuffer的重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<hr>
<p><strong>ByteBuffer的初始状态</strong><br>一开始</p>
<p><img data-src="/images/pasted-4.png" alt="upload successful"></p>
<hr>
<p>写模式下，position是当前写入的位置，limit相当于容量</p>
<p><img data-src="/images/pasted-5.png" alt="upload successful"></p>
<hr>
<p>读模式下，flip动作发生以后，position切换到读取的位置，limit切换成读取限制</p>
<p><img data-src="/images/pasted-6.png" alt="upload successful"></p>
<hr>
<p><img data-src="/images/pasted-7.png" alt="upload successful"></p>
<hr>
<p>compact方法，是把未读完的部分向前压缩。<br><img data-src="/images/pasted-8.png" alt="upload successful"></p>
<h3 id="方法调用与演示"><a href="#方法调用与演示" class="headerlink" title="方法调用与演示"></a>方法调用与演示</h3><p>导入netty的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBufferReadWrite</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        buffer.put((<span class="type">byte</span>) <span class="number">0x61</span>); <span class="comment">//&#x27;a&#x27;</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x62</span>,<span class="number">0x63</span>,<span class="number">0x64</span>&#125;); <span class="comment">// b , c , d</span></span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        </span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">position: [<span class="number">1</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |a.........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">4</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |abcd......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h3 id="2-3ByteBuffer常见方法"><a href="#2-3ByteBuffer常见方法" class="headerlink" title="2.3ByteBuffer常见方法"></a>2.3ByteBuffer常见方法</h3><p><strong>分配空间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass());</span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * class java.nio.HeapByteBuffer -java 堆内存，读写效率较低 ， 收到GC垃圾回收的影响</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * class java.nio.DirectByteBuffer - 直接内存 ，读写效率高（少一次拷贝） ， 不会收到GC的影响</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 垃圾回收GC的往往会让数据变得更加紧凑，因此需要进行一次拷贝<br> 直接内存不会受到GC的影响，就不需要搬动<br> 但是DirectByteBuffer分配内存的效率低，还容易造成内存泄漏</p>
<hr>
<p><strong>写入</strong></p>
<ul>
<li><p>调用channel自己的read（） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用buffer自己的put()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">123</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>从buffer读取数据</strong></p>
<ul>
<li>调用channel自身的write()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf)</span><br></pre></td></tr></table></figure></li>
<li>调用buffer自己的get()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure>
get()会让position指针往后走，如果想重复读取数据</li>
<li>调用rewind()将postion指针置0</li>
<li>调用get(int i)方法获取索引i的内容，并且不会移动指针<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">rewind</span><span class="params">()</span> &#123;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>mark &amp; reset<br>mark做一个标记，记录position位置<br>reset是将position重置到mark的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mark &amp; reset</span></span><br><span class="line">        <span class="comment">//mark做一个标记，记录position位置；reset是将position重置到mark的位置</span></span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        buffer.mark();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        buffer.reset();</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line">        System.out.println((<span class="type">char</span>)buffer.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串和bytebuffer的相互转换"><a href="#字符串和bytebuffer的相互转换" class="headerlink" title="字符串和bytebuffer的相互转换"></a>字符串和bytebuffer的相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.字符串转为ByteBuffer</span></span><br><span class="line">        <span class="comment">//再次转换需要buffer.flip()</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer);</span><br><span class="line">        <span class="comment">//2.Charset</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        debugAll(buffer2);</span><br><span class="line">        <span class="comment">//3.wrap</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(buffer3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.ByteBuffer字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4Scattering-Reads"><a href="#2-4Scattering-Reads" class="headerlink" title="2.4Scattering Reads"></a>2.4Scattering Reads</h3><p><strong>通过集中写，分散读的方法，减少数据在ByteBuffer中拷贝的次数</strong><br>分散读取，有一个文本文件3parts.txt<br>onetwothree<br>长度已知的时候，用三个ByteBuffer进行分散读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScatteringReads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buf1,buf2,buf3&#125;);</span><br><span class="line">            buf1.flip();</span><br><span class="line">            buf2.flip();</span><br><span class="line">            buf3.flip();</span><br><span class="line">            debugAll(buf1);</span><br><span class="line">            debugAll(buf2);</span><br><span class="line">            debugAll(buf3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集中写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScatteringReads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buf1,buf2,buf3&#125;);</span><br><span class="line">            buf1.flip();</span><br><span class="line">            buf2.flip();</span><br><span class="line">            buf3.flip();</span><br><span class="line">            debugAll(buf1);</span><br><span class="line">            debugAll(buf2);</span><br><span class="line">            debugAll(buf3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习-黏包、半包现象）"><a href="#练习-黏包、半包现象）" class="headerlink" title="练习(黏包、半包现象）"></a>练习(黏包、半包现象）</h3><p>网络上有多条数据发送给服务器，数据之间使用\n进行分割但由于某种原因这些数据在接受时，倍进行了重新组合，例如原始数据如下：</p>
<hr>
<p>hello,world\n<br>I’m zhangsan\n<br>How are you?\n</p>
<hr>
<p>变成了下面的两个buffer  （黏包、半包现象）  </p>
<hr>
<p>hello,world\nI’m zhangsan\nHow<br>w are you?\n  </p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; source.limit() ; i++)&#123;</span><br><span class="line">            <span class="comment">//找到一条完整的消息</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//将这条完整消息存入新的ByteBuffer</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(lenth);</span><br><span class="line">                <span class="comment">//从source中读,向target中写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; lenth ; j ++)&#123;</span><br><span class="line">                    target.put(source.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3.文件编程"></a>3.文件编程</h2><p><strong>FileChannel只能工作在阻塞模式下</strong><br><strong>获取</strong><br>不能直接打开FileChannel,必须 通过FileInputStream,FileOutputStream或者RandomAccessFile来获取FileChannel，他们都有getChannel()方法。</p>
<ul>
<li>通过FileInputChannel获取的Channel只能读</li>
<li>通过FileOutputChannel获取的channel只能写</li>
<li>通过RandomAccessFile读写功能根据RandomAccessFile的读写模式决定</li>
</ul>
<h3 id="3-1两个Channel传输数据"><a href="#3-1两个Channel传输数据" class="headerlink" title="3.1两个Channel传输数据"></a>3.1两个Channel传输数据</h3><p><strong>transferTo()</strong><br>-底层利用操作系统的零拷贝进行优化，效率高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">            from.transferTo(<span class="number">0</span>,from.size(),to);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一次最多上传2G数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size ; left &gt; <span class="number">0</span>; )&#123;</span><br><span class="line">                left -= from.transferTo(size - left , left ,to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2Path"><a href="#3-2Path" class="headerlink" title="3.2Path"></a>3.2Path</h3><p>jdk引入了path和Paths类</p>
<ul>
<li>Path用来表示文件路径</li>
<li>Paths是工具类，用来获取Path实例</li>
</ul>
<p><img data-src="/images/pasted-21.png" alt="upload successful"></p>
<h3 id="3-3Files"><a href="#3-3Files" class="headerlink" title="3.3Files"></a>3.3Files</h3><p><img data-src="/images/pasted-22.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-23.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-24.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-25.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-26.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-27.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-28.png" alt="upload successful"></p>
<hr>
<p><strong>walkFileTree()</strong><br>查询指定路径下以’.jpg’结尾文件的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilesWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/yangkaixuan/Desktop/Paper&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                @Override</span></span><br><span class="line"><span class="comment">//                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(dir);</span></span><br><span class="line"><span class="comment">//                    dirCount.incrementAndGet();</span></span><br><span class="line"><span class="comment">//                    return super.preVisitDirectory(dir, attrs);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    <span class="keyword">if</span>(file.toString().endsWith(<span class="string">&quot;.pdf&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(file);</span><br><span class="line">                        fileCount.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    System.out.println(file);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>层级删除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilesWalkFileTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/yangkaixuan/Desktop/资料&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    Files.delete(file);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                    Files.delete(dir);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行前确保不是重要内容<br><strong>拷贝多级目录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;/Users/yangkaixuan/Desktop/资料&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">traget</span> <span class="operator">=</span> <span class="string">&quot;/Users/yangkaixuan/Desktop/资料2&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Files.walk(Paths.get(source)).forEach(path -&gt;&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source,traget);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path))&#123;</span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Files.isRegularFile(path))&#123;</span><br><span class="line">                    Files.copy(path,Paths.get(targetName));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4.网络编程"></a>4.网络编程</h2><h3 id="4-1使用NIO理解阻塞模式"><a href="#4-1使用NIO理解阻塞模式" class="headerlink" title="4.1使用NIO理解阻塞模式"></a>4.1使用NIO理解阻塞模式</h3><p><strong>Server端</strong><br>Channel是数据读写的通道，通过channel实现数据通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用NIO理解阻塞模式，单线程</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//1.创建服务器</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.绑定监听端口</span></span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//3.连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//4.accept 建立与客户端之间的连接，SocketChannel用来与客服端之间的通信</span></span><br><span class="line">            log.debug(<span class="string">&quot;connecting ...&quot;</span>);      </span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">            channels.add(sc);</span><br><span class="line">            log.debug(<span class="string">&quot;connected ...&#123;&#125;&quot;</span>,sc);</span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channels)&#123;</span><br><span class="line">                <span class="comment">//5.接收客户端发送的数据</span></span><br><span class="line">                log.debug(<span class="string">&quot;before read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">                channel.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                debugRead(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                log.debug(<span class="string">&quot;after read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端启动，客户端没有启动</p>
<hr>
<p>17:56:58.686 [main] DEBUG cn.itcast.netty.c4.Server - connecting …  </p>
<hr>
<p>其中accept()是阻塞方法，线程阻塞<br>客户端运行，但没有发送数据时，客户端read()阻塞（read()是阻塞方法）</p>
<hr>
<p>18:02:42.583 [main] DEBUG cn.itcast.netty.c4.Server - connecting …<br>18:02:48.181 [main] DEBUG cn.itcast.netty.c4.Server - connected …java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60801]<br>18:02:48.183 [main] DEBUG cn.itcast.netty.c4.Server - before read …java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60801]</p>
<hr>
<p>客户端运行，发送数据给服务器端后：</p>
<p><img data-src="/images/pasted-29.png" alt="upload successful"></p>
<p><strong>总结：accept（），read（）都是阻塞方法，得到数据开始运行，否则线程停止运行。阻塞模式和单线程结合后有很大的弊端：阻塞模式下，某个方法的执行会影响另一个方法的执行</strong></p>
<h3 id="4-2使用NIO理解非阻塞模式"><a href="#4-2使用NIO理解非阻塞模式" class="headerlink" title="4.2使用NIO理解非阻塞模式"></a>4.2使用NIO理解非阻塞模式</h3><p>非阻塞模式下，对服务器端的修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">//非阻塞模式下,没有接收到链接的时候会返回null值，线程还会继续运行</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (sc != <span class="literal">null</span>)&#123;</span><br><span class="line">   log.debug(<span class="string">&quot;connected ...&#123;&#125;&quot;</span>,sc);</span><br><span class="line">   sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">   channels.add(sc);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">//非阻塞，线程任然会继续运行，如果没有读到数据,read返回0</span></span><br><span class="line"><span class="keyword">if</span> (read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    debugRead(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">    log.debug(<span class="string">&quot;after read ...&#123;&#125;&quot;</span>,channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单的非阻塞模式虽然能够处理问题，但是没有连接请求，没有数据可读的时候也在不断循环，严重的造成了cpu的浪费<br>因此考虑到使用selector，很好的管理线程，当有任务的时候安排线程工作，没工作安排线程休息</strong>  </p>
<h3 id="4-3使用selector处理非阻塞模式"><a href="#4-3使用selector处理非阻塞模式" class="headerlink" title="4.3使用selector处理非阻塞模式"></a>4.3使用selector处理非阻塞模式</h3><ul>
<li>accept-会在有连接请求时触发(ServerSocketChannel)</li>
<li>connect-客户端，连接建立后触发（SocketChannel）</li>
<li>read-可读事件（SocketChannel）</li>
<li>write-可写事件</li>
</ul>
<hr>
<p>对ServerSocketChannel进行注册到Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意selector.select();select()在事件未处理的时候不会阻塞<br>如果对事件不需要进行处理，调用key.cancel()</strong><br><strong>总结：事件发生后，要吗处理、要吗取消，不能够置之不理</strong></p>
<hr>
<p>接下来，对ServerSocketChannel处理的同时处理SokectChannel  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugRead(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果发现，出现了空指针的报错</strong><br>Exception in thread “main” java.lang.NullPointerException<br>    at cn.itcast.netty.c4.Server.main(Server.java:52)</p>
<hr>
<p><img data-src="/images/pasted-31.png" alt="upload successful"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br></pre></td></tr></table></figure>

<p><strong>对客户端的额外处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Keyy ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        debugRead(buffer);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端断开连接就会发送一次read事件，然而由于IoException后没有对事件进行处理，所以跳出到下一次循环后会一直重复循环，所以需要反注册cancel()事件<br>无论客户端是正常断开还是异常断开，都会发送read事件，读取完后都需要删除<br><strong>正常断开</strong><br>判断channel.read()的返回值，为-1时代表客户端正常断开，cancel（）这个key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer2);<span class="comment">//如果是正常断开，read返回值为-1</span></span><br><span class="line">                        <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugRead(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4消息边界问题"><a href="#4-4消息边界问题" class="headerlink" title="4.4消息边界问题"></a>4.4消息边界问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/pasted-34.png" alt="upload successful"><br>存在消息边界问题，系统默认使用字符集utf-8，一个中文字符占3个字节，需要第二次read()才能读完，导致乱码现象<br><img data-src="/images/pasted-35.png" alt="upload successful"><br>可以看出，要是message过长，那么bytebuffer扩容<br>如果message过短，可能造成半包或者粘包的现象。<br><strong>第一种方式：客户端和服务器约定相同的bytebuffer大小</strong>  </p>
<p><img data-src="/images/pasted-36.png" alt="upload successful"><br>问题：虽然简单，但是会造成空间的浪费，网络的带宽也会受到影响<br><strong>第二种方式：客户端发送消息时，采用分隔符对消息分割，服务器端根据分隔符长度，创建新的bytebuffer</strong></p>
<p><img data-src="/images/pasted-37.png" alt="upload successful"><br>问题：效率太低，需要一个字节一个字节的对比<br><strong>第三种方式：使用固定大小的空间，存储后续内容的大小，根据实际内容，先将内容长度发送给服务器，服务器根据数据的长度，根据长度分配bytebuffer</strong></p>
<p><img data-src="/images/pasted-38.png" alt="upload successful"><br>http 2.0是LTV<br>当bytebuffer的长度不能够一次读取完客户端发送的数据的时候。客户端就会再次发送read()事件，因为将Bytebuffer目前设置为局部变量，所以服务器会将第二次发送的数据当成完整数据接受。</p>
<p><img data-src="/images/pasted-40.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-39.png" alt="upload successful"><br>产生的问题，bytebuffer需要扩容，把剩余部分接收到，接受完整的消息。<br>bytebuffer不能设置为局部变量。<br><strong>ByteBuffer能不能放在最外层？<br>不能！这样的话channel可能会复用一个bytebuffer，导致消息混乱</strong>  </p>
<hr>
<p><strong>采用附件的概念</strong><br>channel注册在selector的时候，附件关联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; source.limit() ; i++)&#123;</span><br><span class="line">            <span class="comment">//找到一条完整的消息</span></span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//将这条完整消息存入新的ByteBuffer</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(lenth);</span><br><span class="line">                <span class="comment">//从source中读,向target中写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; lenth ; j ++)&#123;</span><br><span class="line">                    target.put(source.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建selector对象，管理多个channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.建立selector 和 channel 之间的联系（将channel注册在selector上）</span></span><br><span class="line">        <span class="comment">//SelectionKey就是事件发生后，通过它得到事件和哪个channel发生的事件</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        log.info(<span class="string">&quot;register Key ... &#123;&#125;&quot;</span>,sscKey);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.select方法.select没有事件发生就阻塞，有了事件发生线程恢复运行</span></span><br><span class="line">            <span class="comment">//select()在事件未处理的时候不会阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4.处理事件,selectedKeys()内部包含了所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();<span class="comment">//accept , read</span></span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove(); <span class="comment">//处理key的时候，要从selectedKeys集合中删除，否则下一次就会有问题</span></span><br><span class="line">                log.info(<span class="string">&quot;key ...&#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="comment">//区分事件类型</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>); <span class="comment">//非阻塞模式</span></span><br><span class="line">                    <span class="comment">//将bytebuffer作为附件关联在selectionKey上</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer2);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.info(<span class="string">&quot;channel... &#123;&#125;&quot;</span>,sc);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//读取附件</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">//如果是正常断开，read返回值为-1</span></span><br><span class="line">                        <span class="keyword">if</span> (read == -<span class="number">1</span>)&#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            split(buffer);</span><br><span class="line">                            <span class="keyword">if</span> (buffer.position() == buffer.limit())&#123;</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                newBuffer.put(buffer);</span><br><span class="line">                                key.attach(newBuffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel(); <span class="comment">//因为客户端断开，需要将key取消</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ByteBuffer的大小分配，每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，每个channel都需要维护一个独立的ByteBuffer<br>ByteBuffer不能太大，要设计大小可变的ByteBuffer</strong></p>
<h3 id="4-5可写事件"><a href="#4-5可写事件" class="headerlink" title="4.5可写事件"></a>4.5可写事件</h3><p>WriteServer  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">//1.向客户端发送大量数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">30000000</span>;i++)&#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">//2.返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WriteClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8081</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//3.接受数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器没有办法一次性将所有数据发送给客户端，写满后就为0<br><img data-src="/images/pasted-41.png" alt="upload successful"><br>不符合非阻塞的思想，没有发完的信息无限循环，直到发完才为止<br>不要让尝试反复地在写事件，关注可写事件后，写缓冲区满了，就进行读事件</p>
<p><strong>处理可写事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="comment">//1.向客户端发送大量数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">30000000</span>;i++)&#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="comment">//2.返回值代表实际写入的字节数</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//缓冲区满了，但是数据仍然有剩余没有写</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">//4.关注可写事件</span></span><br><span class="line">                        scKey.interestOps(SelectionKey.OP_WRITE + scKey.interestOps());</span><br><span class="line">                        <span class="comment">//5.将未写完的数据挂到sckey上</span></span><br><span class="line">                        scKey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="comment">//6.清理操作</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining())&#123;</span><br><span class="line">                        key.attach(<span class="literal">null</span>); <span class="comment">//新关联，会把上次关联释放</span></span><br><span class="line">                        <span class="comment">//都写完后就不要关注write()</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多路复用</strong><br>单线程可以配合selector完成对多个Channel可读写事件的监控，这称之为多路复用。<br><strong>select()何时不阻塞</strong></p>
<ul>
<li>事件发生时<ul>
<li>客户端发起链接请求，触发accept事件</li>
<li>客户端发送数据，客户端正常、异常关闭，都会触发read()，如果数据大于buffer缓冲区，会触发多次read()</li>
<li>channel可写，write()</li>
<li>在linux下nio bug发生</li>
</ul>
</li>
</ul>
<h3 id="4-6利用多线程优化"><a href="#4-6利用多线程优化" class="headerlink" title="4.6利用多线程优化"></a>4.6利用多线程优化</h3><p>Boss selector只负责建立连接，不负责数据读写<br>worker selector负责数据的读写  </p>
<p><img data-src="/images/pasted-43.png" alt="upload successful"><br>MultiThreadServer  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//1.创建固定数量的worker,并初始化</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-0&quot;</span>);</span><br><span class="line">        worker.register();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    sc.register(worker.selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                    log.info(<span class="string">&quot; after connected , connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 还未初始化</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            log.info(<span class="string">&quot;read ..&#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程和selector</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start)&#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span> , name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现问题</p>
<p><img data-src="/images/pasted-52.png" alt="upload successful"><br>work的select（）执行，影响了register（）的执行<br>selector.select()是work方法的的select()  sc.register()也是用的work的select()  </p>
<p><strong>修改:将这两个方法挨着执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.register();</span><br><span class="line">sc.register(worker.selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这样子的操作，有很大的概率先执行sc.register()再执行worker.register()<br>同时也存在问题，当有一个新的线程进来后，就无法保证先后问题了，那么放在一个线程中执行就成了一个解决问题的办法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        bossKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">//1.创建固定数量的worker,并初始化</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line">                    worker.register(sc);</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot; after connected , connected ..&#123;&#125;&quot;</span>,sc.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 还未初始化</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task !=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            log.info(<span class="string">&quot;read ..&#123;&#125;&quot;</span>,channel.getRemoteAddress());</span><br><span class="line">                            channel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化线程和selector</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start)&#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span> , name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向队列添加了任务但没有执行</span></span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector , SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用队列ConcurrentLinkedQueue对要做的事务进行处理，主线程向队列中添加了register任务。为了避免select() 和 register相互阻塞，想到的办法是将其放在一个线程中进行处理。<br>第一次循环：thread.start()后，进入循环的同时，select()方法阻塞。主线程通过wakeup()方法唤醒selector()。<br>第二次循环：从队列中去除Runnable的子类task，执行run()方法 （）-&gt;{ .. register()..}在同一线程内注册sc.register（）<br>第三次循环：检测到可读实现，实现可读功能。<br><strong>总结：也就是说使用队列的方式，将两个事件放在同一个线程中处理先后顺序</strong></p>
<h3 id="4-7-NIO-vs-BIO"><a href="#4-7-NIO-vs-BIO" class="headerlink" title="4.7 NIO vs BIO"></a>4.7 NIO vs BIO</h3><p><strong>stream vs channel</strong></p>
<ul>
<li><p>stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区、接受缓冲区</p>
</li>
<li><p>steam只支持阻塞API，channel同时支持阻塞、非阻塞API，网络channel可配合selector实现多路复用</p>
</li>
<li><p>二者都为全双工，读写可以同时进行<br><strong>IO模型</strong><br>同步阻塞、同步非阻塞、多路复用、异步阻塞（没有这种情况）、异步非阻塞</p>
</li>
<li><p>阻塞IO</p>
</li>
</ul>
<p><img data-src="/images/pasted-55.png" alt="upload successful"><br>等待数据时阻塞，一直到接受到数据后，返回给用户线程,等待的过程用户线程被阻塞</p>
<ul>
<li>非阻塞IO</li>
</ul>
<p><img data-src="/images/pasted-54.png" alt="upload successful"><br>通过while(true)没有接受到数据后立刻返回，再重新发起read()，此时线程不会被阻塞。但是当接收到数据后，用户线程也是会被阻塞的，以等待返回的数据。<br>只是等待数据阶段不是阻塞过程，并且多次与系统和用户之间进行切换，影响系统的性能。  </p>
<ul>
<li>多路复用</li>
</ul>
<p><img data-src="/images/pasted-56.png" alt="upload successful"><br>两个阶段阻塞用户线程，select阶段阻塞，read阶段阻塞。<br><strong>Q：阻塞模式下只进行一次系统调用，而多路复用涉及到两次系统调用，那么多路复用的优势在哪呢？</strong>  </p>
<p><img data-src="/images/pasted-57.png" alt="upload successful"><br>阻塞IO的问题：在accpet等待连接的时候就没有办法处理channel的read,处理一件事的时候没有办法处理别的事情。  </p>
<p><img data-src="/images/pasted-58.png" alt="upload successful"><br>多路复用，select阻塞过程中能获得多个channel，再一次处理过程中能处理多个事件。  </p>
<ul>
<li>同步：线程自己去获得结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是有其他线程送结果（至少两个线程）<br><strong>异步</strong><br>异步情况下，线程一定是非阻塞的。</li>
</ul>
<p><img data-src="/images/pasted-59.png" alt="upload successful"></p>
<h3 id="4-8-零拷贝"><a href="#4-8-零拷贝" class="headerlink" title="4.8 零拷贝"></a>4.8 零拷贝</h3><p><img data-src="/images/pasted-60.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-61.png" alt="upload successful"><br>1.java本身不具备IO读写能力，因此read方法调用后，要从用户态转换成内核态，去调用操作系统的读写能力，将数据写入内核缓冲区。这期间用户线程阻塞。<br>2.从内核态切换成用户态，将数据从内核缓冲区读入用户缓冲区。<br>3.调用write方法，这时将数据从用户缓冲区写入socket缓冲区<br>4.接下来向网卡写数据，java不具备读写能力，因此从用户态切换到内核态，将socket缓冲区中的数据写入网卡<br><strong>NIO优化</strong><br>通过DirectByteBuf</p>
<ul>
<li>ByteBuffer.allocate(10) HeapByteBuffer 使用的还是java内存</li>
<li>ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img data-src="/images/pasted-62.png" alt="upload successful"><br>进一步优化，（底层代用了linux2.1后提供的sendFile方法）,java中对应着两个channel调用transferTo&#x2F;transferFrom拷贝数据</p>
<p><img data-src="/images/pasted-63.png" alt="upload successful"><br>1.java调用transferTo方法后，要从java的用户态切换成内核态，将数据写入内核缓冲区<br>2.数据从内核缓冲区传输到socket缓冲区<br>3.将socket缓冲区数据写入网卡<br>进一步优化，（linu2.4）  </p>
<p><img data-src="/images/pasted-64.png" alt="upload successful"><br>1.java调用transferTo方法后，要从java的用户态切换成内核态，将数据写入内核缓冲区<br>2.只会将一些offset和length信息拷贝进socket缓冲区，几乎没有消耗<br>3.从内核缓冲区直接写入网卡<br><strong>最后两种优化有可以是 零拷贝 ，也就是说数据只在操作系统中拷贝，而不会拷贝在jvm内存中</strong><br>优点：  </p>
<ul>
<li>更少的内核态和用户态的转换</li>
<li>使用专门的DMA硬件进行拷贝，不利用cpu计算</li>
<li>零拷贝适合小文件的传输</li>
</ul>
<h1 id="二-Netty入门"><a href="#二-Netty入门" class="headerlink" title="二.Netty入门"></a>二.Netty入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>netty vs NIO 工作量大，bug多<ul>
<li>需要自己构建协议</li>
<li>解决TCP的传输问题，粘包，半包</li>
<li>epoll空轮询，导致cpu100%</li>
<li>对API进行增强，更容易使用</li>
</ul>
</li>
</ul>
<h2 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2.hello world"></a>2.hello world</h2><p><img data-src="/images/pasted-68.png" alt="upload successful"><br>1.创建启动器类<br>2.添加组件，一开始关心accept事件，<br>3.channel<br>4.添加处理器，处理器initChannel（）不会立刻执行,只有在连接建立后才执行<br>5.channel<br>6.bind绑定端口<br>7.启动类<br>8.EventLoop添加<br>9.选择channel<br>10.添加处理器<br>11.connect()；链接服务器，服务器监听到后，会调用accpet相应的处理器进行处理，不需要写出来，但它会调用initChannel（）<br>12.服务器端，链接建立后，执行initChannel()<br>12.客户端一样，连接建立后，调用客户端的initChannel（）<br>14.发送数据，凡是收发数据，必须执行handler<br>15.调用StringEncoder()，将hello转为ByteBuf格式<br>16.又EventLoopGroup中某个EventLoop处理read事件<br>17.调用服务器的hanlder进行处理，首先调用StringDecoder()，将ByteBuf还原成字符串<br>18.执行channelread（）打印由（17）还原的字符串<br><strong>一开始需要注意的思想</strong></p>
<p><img data-src="/images/pasted-69.png" alt="upload successful"><br>其中handler表示每一道工序，左右工序整合成为pipeline。Inbound和Outbound两类分别处理入站、出站。<br>eventLoop中包含线程，真正的能够处理数据。<br>工人和channel的绑定，工人可以管理多个channel，保证线程的安全。  </p>
<h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3.组件"></a>3.组件</h2><h3 id="3-1EventLoop"><a href="#3-1EventLoop" class="headerlink" title="3.1EventLoop"></a>3.1EventLoop</h3><p>事件循环对象EventLoop本质是一个单线程执行器（同时维护一个selector），里面的run方法处理源源不断的channel上的IO事件  </p>
<ul>
<li>继承自j.u.c.ScheduledExecutorService 因此包含线程池中的所有方法</li>
<li>另一条线是继承自netty自己的OrderedEventExecutor<ul>
<li>isEventLoop(Thread thread)判断是否是一个EventLoop</li>
<li>parent()判断来自那个EventLoopGroup</li>
</ul>
</li>
</ul>
<p>事件循环组EventLoopGroup,Channel一般会调用EventLoopGroup的Register方法来绑定一个EventLoop,后续这个channel的io时间都由此EventLoop负责。（保证io处理事线程安全)<br>EventLoop的普通任务，定时任务  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventLoop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建事件循环组</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io , 普通任务 ， 定时任务</span></span><br><span class="line"><span class="comment">//        DefaultEventLoopGroup group = new DefaultEventLoopGroup();  普通任务 ， 定时任务</span></span><br><span class="line">        <span class="comment">//2.获取下一个时间循环对象</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行普通任务</span></span><br><span class="line">        group.next().submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIOEventLoopGroup中的EventLoop一旦与channel绑定关系，都不可更改，后续的所有请求都由同一个eventLoop进行处理。  </p>
<p><img data-src="/images/pasted-72.png" alt="upload successful"><br>对NioEventLoopGroup的两次细分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//细分2：创建一个独立的EventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();<span class="comment">//只能处理普通任务，定时任务，不能处理io事件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// boss 和 worker</span></span><br><span class="line">                <span class="comment">//细分1：boss 只负责serverSocketChannel上的accept事件  worker只负责socketChannel上的读写</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span>                                           <span class="comment">//ByteBuf</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));<span class="comment">//开发时需要强制指定字符集，不然会乱码</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group , <span class="string">&quot;handler2&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                System.out.println(buf);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细分一：为什么不只设置一个NioEventLoop的boss呢？<br>因为其中NioServerChannel只会有一个，而也只会有一个EventLoop进行绑定，不需要设置。<br>如果有一个handler执行时间过长该怎么解决？<br>为了不影响到worker线程的nio操作影响服务器的读写性能，创建一个新的NioEventLoopGroup,用它来处理耗时的工作。  </p>
<p><img data-src="/images/pasted-73.png" alt="upload successful">  </p>
<h3 id="3-2线程切换"><a href="#3-2线程切换" class="headerlink" title="3.2线程切换"></a>3.2线程切换</h3><p>那么其中的不同线程是如何切换的？<br>我们将NioEventLoopGroup中的线程成为nio线程，DefaultEventLoopGroup中的线程称为普通线程</p>
<p><img data-src="/images/pasted-74.png" alt="upload successful"><br>如果两个handler绑定的是同一个线程，那么直接调用<br>如果两个handler不是同一个线程，那么要把调用的代码封装在一个Runnable对象中，作为任务对象由下一个handler的线程调用。</p>
<h3 id="3-3-Channel"><a href="#3-3-Channel" class="headerlink" title="3.3 Channel"></a>3.3 Channel</h3><p>sync()和connect（）方法的理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.启动器</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 2.添加EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 3.选择客户端Channel的实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4.添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//连接建立后调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//1.连接到服务器</span></span><br><span class="line"><span class="comment">//                异步非阻塞：main线程发起了调用，但是不是主线程去做链接服务器的工作，真正执行的是nio线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)); <span class="comment">// 假如1s后完成链接</span></span><br><span class="line"><span class="comment">//        channelFuture.sync();</span></span><br><span class="line">        <span class="comment">//因为主线程connect是非阻塞的，瞬间就会来到下一行代码，但是此时还没有建立好链接，拿不到目标channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello , world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中connect()方法是异步非阻塞的，主线程不需要知道调用后的结果如何，链接工作交给了nio线程去完成，假如需要在1s后完成连接，而此时主线程的connect()方法异步非阻塞，那么一个瞬间就会来到channelFutrue.channel()方法，那么就拿不到目标的channel.<br><strong>带有Futrue、Promise的类型往往和异步方法搭配使用，用来处理结果</strong><br>方法1：<br>使用sync()方法来同步处理结果，将当前线程阻塞住，知道nio线程完成连接，sync()方法向下运行。其中，主线程等待nio线程完成连接。<br>方法2：<br>使用addListener()方法异步处理结果，等待连接建立，链接建立成功都由其他线程处理。在nio线程建立连接后，nio线程调用operationComplete()方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> future.channel();</span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-4-channelFuture处理关闭"><a href="#3-4-channelFuture处理关闭" class="headerlink" title="3.4 channelFuture处理关闭"></a>3.4 channelFuture处理关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line))&#123;</span><br><span class="line">                    channel.close(); <span class="comment">//异步操作</span></span><br><span class="line">                    log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;input&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p> channel.close()是异步方法，由NioEventLoop进行控制，而log.debug()是由input线程控制，不能控制谁前谁后发生。有可能先做了善后的工作，才关闭channel。<br> <strong>通过获取ClosedFuture对象： 1)同步处理关闭  2)异步处理关闭</strong><br> 同步处理关闭，善后操作由主线程完成<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">System.out.println(<span class="string">&quot;waiting close&quot;</span>);</span><br><span class="line">closeFuture.sync();</span><br><span class="line">log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p> 异步处理关闭，善后操作由关闭chanenl的nio线程完成<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">       closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><br> 优雅的关闭客户端。 group.shutdownGracefully();<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line))&#123;</span><br><span class="line">                    channel.close(); <span class="comment">//异步操作</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;);</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;input&quot;</span>).start();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;waiting close&quot;);</span></span><br><span class="line"><span class="comment">//        closeFuture.sync();</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;处理关闭之后的操作&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-为什么要使用异步？"><a href="#3-5-为什么要使用异步？" class="headerlink" title="3.5 为什么要使用异步？"></a>3.5 为什么要使用异步？</h3><p>netty使用异步的操作，究竟提升了哪些性能？<br>要点：  </p>
<ul>
<li>单线程无法异步提高效率，必须配合多线程，多核cpu才能够发挥异步的优势</li>
<li>异步没有缩短响应时间，反而有所增加</li>
<li>合理进行任务拆分，也是利用异步的关键</li>
</ul>
<h3 id="3-6-Future-amp-Promise"><a href="#3-6-Future-amp-Promise" class="headerlink" title="3.6 Future &amp; Promise"></a>3.6 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口<br>首先要说明netty中Future与jdk中的Future同名，netty的Futrue继承自jdk的Future,而Promise又对netty Future进行了扩展。  </p>
<p><img data-src="/images/pasted-75.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-76.png" alt="upload successful"><br>java Future</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJdkFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2.提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.主线程通过Future获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,future.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/pasted-77.png" alt="upload successful">  </p>
<p>netty Future使用异步方式获取结果  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line"><span class="comment">//        log.debug(&quot;结果是&#123;&#125;&quot;,future.getNow());</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/pasted-78.png" alt="upload successful"><br>我们需要的结果都是通过线程池，或者eventLoop返回的Future对象，我们没有办法自己进行创建，是无法控制的。那么就考虑使用Promise，主动的创建<strong>结果容器</strong>，而不是被动的获取结果。<br><strong>构建Promise需要新建一个eventLoop传入构造器中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyPromise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建EventLoop对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">        <span class="comment">//2.主动创建promise，结果容器</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始计算&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果。。。&quot;</span>);</span><br><span class="line">        promise.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,promise.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-7-Handler-amp-Pipeline"><a href="#3-7-Handler-amp-Pipeline" class="headerlink" title="3.7 Handler &amp; Pipeline"></a>3.7 Handler &amp; Pipeline</h3><p><img data-src="/images/pasted-79.png" alt="upload successful">  </p>
<p>ChannelInboundHandlerAdapter 入站处理器<br>ChannelOutboundHandlerAdapter 出站处理器  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPipeLine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//1.通过channel拿到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                        <span class="comment">//2.添加handler : head -&gt; h1 -&gt; h2 -&gt; h3 -&gt;tail  （双向链表）</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h1&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h2&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h3&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h4&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h5&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;h6&quot;</span> , <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-embeddedChannel"><a href="#3-8-embeddedChannel" class="headerlink" title="3.8 embeddedChannel"></a>3.8 embeddedChannel</h3><h3 id="3-9-ByteBuf"><a href="#3-9-ByteBuf" class="headerlink" title="3.9 ByteBuf"></a>3.9 ByteBuf</h3><p><img data-src="/images/pasted-81.png" alt="upload successful"><br>只有触发writeAndFlush方法才会触发出战处理器，入站顺序执行，出站逆序执行。<br>super.channelRead(ctx, msg);<br>将数据传递给下一个handler，如果不调用的话，传递链就会断开。</p>
<hr>
<p>ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(“server”.getBytes()));<br>                              ch.writeAndFlush(ctx.alloc().buffer().writeBytes(“server”.getBytes()));</p>
<hr>
<p>ctx从当前处理器往回找出站处理器，ch则是从整个pipline的tail往回找出站处理器。  </p>
<p><img data-src="/images/pasted-82.png" alt="upload successful"></p>
<p><strong>Bytebuf的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBuf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        System.out.println(buf);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">300</span> ; i ++)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.writeBytes(sb.toString().getBytes());</span><br><span class="line">        System.out.println(buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接内存 vs 堆内存</strong><br>netty一般默认情况下选择<em>直接内存</em><br>创建池化基于堆的ByteBUf<br>ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(10);<br>创建池化基于直接内存的ByteBuf<br>ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(10);  </p>
<ul>
<li>直接内存的创建和销毁的代价昂贵，但是读写性能很高，适合配合池化功能一起使用 </li>
<li>直接内存收到的GC压力小，因为这部分内存不收JVM垃圾回收的管理，但是要注意及时释放</li>
</ul>
<p><strong>池化 vs 非池化</strong><br>池化的意义在于可以重用BuyeBuf：  </p>
<ul>
<li>没有池化，则每次都要创建新的ButeBuf实力，这个操作对直接内存代价昂贵。就算是堆内存，都会有GC的压力</li>
<li>有了池化可以重用池中的ByteBuf,并且采用了jemalloc类似的内存分配算法提升分配效率</li>
<li>高并发时，池化可以节省内存，减少内存溢出的可能</li>
</ul>
<p><strong>组成</strong><br>ByteBuf由4个部分组成  </p>
<p><img data-src="/images/pasted-83.png" alt="upload successful"><br>读写指针一开始都在0位置  </p>
<p><img data-src="/images/pasted-84.png" alt="upload successful"><br>废弃部分  	可读部分  可写部分  可扩容部分  </p>
<hr>
<p><strong>写入的相关方法</strong></p>
<p><img data-src="/images/pasted-85.png" alt="upload successful"><br>扩容规则：  </p>
<p><img data-src="/images/pasted-86.png" alt="upload successful">  </p>
<p><strong>ByteBuf的内存回收（retain \ release方法）</strong>  </p>
<ul>
<li>UnpooledHeapByteBuf 使用JVM内存，只需等待GC回收内存</li>
<li>UNnpooledDiredtByteBuf 使用的是直接内存，需要特殊的方法来回收内存</li>
<li>PooledByteBuf使用池化机制，需要使用更复杂的方式回收</li>
</ul>
<p>Netty引用计数法来控制内存回收，每个Bytebuf都实现了ReferenceCounted借口  </p>
<ul>
<li>每个ByteBuf对象初始值为1  </li>
<li>调用release方法减1，如果计数为0，ByteBuf内存回收</li>
<li>调用retain方法加1，表示调用者没用完之前，其他hanlder调用了release也不会造成回收</li>
<li>当计数为0时，底层内存会被回收，就算对象还存在也不能使用<br>哪个handler最后使用bytebuf应该释放，前面的handler不应该释放。<br>尾部tail对bytebuf的释放处理：TailContext -&gt; channelRead()-&gt;ReferenceCountUtil.release(msg);</li>
</ul>
<p><img data-src="/images/pasted-87.png" alt="upload successful"><br>所有的ByteBuf都继承自ReferenceCounted。<br>头部header对byteBuf的释放处理：HeadContext-&gt;write()</p>
<p><img data-src="/images/pasted-88.png" alt="upload successful">  </p>
<hr>
<p><strong>零拷贝 slice</strong>  </p>
<p><img data-src="/images/pasted-89.png" alt="upload successful"><br>对原来的bytebuf进行切片变成多个bytebuf,切片后bytebuf并没有发生内存复制，还是使用原来的内存，切片后维护独立的read,write指针。  </p>
<p>切片后的结果不允许使用新的内容。  </p>
<hr>
<p><strong>Compostie</strong><br>传统的组合方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSlice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buffer.writeBytes(buf1).writeBytes(buf2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是并不好，因为中途会发生数据的复制，对性能产生影响。</p>
<h1 id="三、netty进阶"><a href="#三、netty进阶" class="headerlink" title="三、netty进阶"></a>三、netty进阶</h1><h2 id="1-粘包半包"><a href="#1-粘包半包" class="headerlink" title="1.粘包半包"></a>1.粘包半包</h2><h3 id="1-1粘包-半包现象"><a href="#1-1粘包-半包现象" class="headerlink" title="1.1粘包,半包现象"></a>1.1粘包,半包现象</h3><p>服务器端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">客户端</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">                                buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buf);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/pasted-90.png" alt="upload successful"><br>产生粘包现象</p>
<h3 id="1-2-滑动窗口"><a href="#1-2-滑动窗口" class="headerlink" title="1.2 滑动窗口"></a>1.2 滑动窗口</h3><ul>
<li><p>TCP以一个段位单位，每发送一个段就需要进行一次确认ack应答处理，但这么做的缺点是，包的往返时间越长，性能就越差</p>
</li>
<li><p>为了解决此问题，引入了<strong>窗口</strong>的概念，决定了无需等待应答还可以继续发送的数据最大主</p>
</li>
<li><p>窗口的实际作用就是一个缓冲区，同时启动控制流量的作用  </p>
<ul>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</li>
</ul>
<p><img data-src="/images/pasted-91.png" alt="upload successful"><br>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>TCP层，滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>TCP层，滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<h3 id="1-3-解决1：短连接"><a href="#1-3-解决1：短连接" class="headerlink" title="1.3 解决1：短连接"></a>1.3 解决1：短连接</h3><p>造成半包粘包现象主要是因为tcp的消息无边界，采用短连接后，客户端发送完信息直接断开，服务器端根据nio可知，客户端断开后服务器读到的值为-1，那么服务器就认为读取到的信息是一条完整的信息。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">以解决粘包为例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-解决2：定长解码器"><a href="#1-4-解决2：定长解码器" class="headerlink" title="1.4 解决2：定长解码器"></a>1.4 解决2：定长解码器</h3><h3 id="1-5-解决3：使用分隔符处理消息边界"><a href="#1-5-解决3：使用分隔符处理消息边界" class="headerlink" title="1.5 解决3：使用分隔符处理消息边界"></a>1.5 解决3：使用分隔符处理消息边界</h3><p><img data-src="/images/pasted-92.png" alt="upload successful"><br>maxlength为最长文本长度，当长度过长后就认为长度过长了。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br><span class="line">```   </span><br><span class="line">### <span class="number">1.6</span> 解决<span class="number">3</span>：固定分隔符</span><br><span class="line">服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>

<p>客户端在每条消息之后，加入 \n 分隔符</p>
<h3 id="1-7-解决4：基于长度字段的解码器"><a href="#1-7-解决4：基于长度字段的解码器" class="headerlink" title="1.7 解决4：基于长度字段的解码器"></a>1.7 解决4：基于长度字段的解码器</h3><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/pasted-94.png" alt="upload successful"><br><img data-src="/images/pasted-93.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-95.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-96.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-97.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-98.png" alt="upload successful">  </p>
<h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2.协议设计与解析"></a>2.协议设计与解析</h2><h3 id="2-1-为什么需要协议？"><a href="#2-1-为什么需要协议？" class="headerlink" title="2.1 为什么需要协议？"></a>2.1 为什么需要协议？</h3><p>TCP&#x2F;IP 中消息传输基于流的形式，并没有边界。协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则。<br>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>

<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0f</span>下雨天留客<span class="number">06</span>天留<span class="number">09</span>我不留</span><br></pre></td></tr></table></figure>
<h3 id="2-2-自定义协议要素"><a href="#2-2-自定义协议要素" class="headerlink" title="2.2 自定义协议要素"></a>2.2 自定义协议要素</h3><ul>
<li>魔术，用来第一时间判定是否是无效数据包</li>
<li>版本号，用来支持协议的升级</li>
<li>序列化算法，消息正文到底采用那种序列化反序列化方式，一般用于消息正文。常见的序列化算法，json,protobuf,hessian,jdk</li>
<li>消息正文， username,password… json,xml,对象流</li>
<li>指令类型，是登陆，注册，单聊，群聊。。。跟业务有关</li>
<li>请求序列，为了双工通信，提高异步能力</li>
<li>正文长度<br>MessageCodec<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 4字节的魔数</span></span><br><span class="line">        byteBuf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">//2. 1字节的版本</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3. 序列化算法：0-jdk 1-json</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//4. 1字节的指令类型</span></span><br><span class="line">        byteBuf.writeByte(message.getMessageType());</span><br><span class="line">        <span class="comment">//5. 4个字节的指令的请求序号</span></span><br><span class="line">        byteBuf.writeInt(message.getSequenceId());</span><br><span class="line">        <span class="comment">//对其填充</span></span><br><span class="line">        byteBuf.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(message);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 长度</span></span><br><span class="line">        byteBuf.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">//8. 内容</span></span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNumber</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,magicNumber,version,serializerType,messageType,sequenceId,length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,message);</span><br><span class="line">        list.add(message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
TestMessageCodec<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageCodec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">//encode</span></span><br><span class="line">        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decode</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>,message,buf);</span><br><span class="line">        channel.writeInbound(buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
new LengthFieldBasedFrameDecoder(1024,12,4,0,0)对处理粘包半包现象是否真的有用？！  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageCodec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">//encode</span></span><br><span class="line">        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decode</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>,message,buf);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">        buf1.retain();</span><br><span class="line">        channel.writeInbound(buf1); <span class="comment">//release 1</span></span><br><span class="line">        channel.writeInbound(buf2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img data-src="/images/pasted-99.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-100.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-101.png" alt="upload successful"><br>成功decode出内容，说明是真的有用。<br>是否能将LengthFieldBasedFrameDecoder抽取？<br>显然不行，对于每个eventLoop来说，可能LengthFieldBasedFrameDecoder由于多个线程共同使用，会引起线程不安全问题。  </p>
<p><img data-src="/images/pasted-102.png" alt="upload successful"><br>有sharable注解的类说明是线程安全的。<br><strong>ByteToMessageCodec的子类不能标注shareable注解</strong></p>
<h2 id="3-聊天室"><a href="#3-聊天室" class="headerlink" title="3.聊天室"></a>3.聊天室</h2><h3 id="3-1-登录"><a href="#3-1-登录" class="headerlink" title="3.1 登录"></a>3.1 登录</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                            ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    log.debug(<span class="string">&quot;msg:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">                                    <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                        <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                        <span class="keyword">if</span> (response.isSuccess())&#123;</span><br><span class="line">                                            LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="comment">//接受用户在控制台的输入，负责向服务器发送消息</span></span><br><span class="line">                                    <span class="comment">//为什么创建新的线程？不创建的话systemin会阻塞其他的io操作</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                                        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        <span class="comment">//构造消息对象</span></span><br><span class="line">                                        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(userName, password);</span><br><span class="line">                                        <span class="comment">//发送消息</span></span><br><span class="line">                                        ctx.writeAndFlush(message);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            WAIT_FOR_LOGIN.await();</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//如果登录失败</span></span><br><span class="line">                                        <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;send [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;gsend [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,<span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）连接建立后就会触发客户端的channelActive<br>（2）读取到用户名和密码封装到LoginRequestMessage后，ctx.writeAndFlush(message)发送给客户端。出站消息，通过encoder编码.<br>设置CountDownLatch systemin线程阻塞等待主线程应答。<br>（3）入站消息使用SimpleChannelInboundHandler<LoginRequestMessage>只针对泛型的类型进行处理，如果账号密码正确ctx.(LoginResponseMessage)<br>（4）channelRead读取解码后的消息，如果消息正确，set login &#x3D; true,并且systemin线程被唤醒继续运行。<br>（5）如果login不为true,cx.channel.close()方法会触发channel.closeFuture().sync()关闭通道。<br>（6）如果login为true,开启聊天室业务。<br>服务器端  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServerBootstrap</span> <span class="variable">bs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bs.channel(NioServerSocketChannel.class);</span><br><span class="line">            bs.group(boss, worker);</span><br><span class="line">            bs.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(userName,password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span> (login)&#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;登录成功！!&quot;</span>);</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;账号密码错误&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bs.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2菜单"><a href="#3-2菜单" class="headerlink" title="3.2菜单"></a>3.2菜单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> itcast.client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> itcast.message.*;</span><br><span class="line"><span class="keyword">import</span> itcast.protocol.MessageCodecSharable;</span><br><span class="line"><span class="keyword">import</span> itcast.protocol.ProcotolFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2022/9/20.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KaiXuan Yang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                            ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    log.debug(<span class="string">&quot;msg:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">                                    <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                        <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                        <span class="keyword">if</span> (response.isSuccess())&#123;</span><br><span class="line">                                            LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="comment">//接受用户在控制台的输入，负责向服务器发送消息</span></span><br><span class="line">                                    <span class="comment">//为什么创建新的线程？不创建的话systemin会阻塞其他的io操作</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                                        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                        <span class="comment">//构造消息对象</span></span><br><span class="line">                                        <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(userName, password);</span><br><span class="line">                                        <span class="comment">//发送消息</span></span><br><span class="line">                                        ctx.writeAndFlush(message);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            WAIT_FOR_LOGIN.await();</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//如果登录失败</span></span><br><span class="line">                                        <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;send [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;gsend [] []&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;________________&quot;</span>);</span><br><span class="line">                                            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                            String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                            <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatRequestMessage</span>(userName,s[<span class="number">1</span>],s[<span class="number">2</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatRequestMessage</span>(userName,s[<span class="number">1</span>],s[<span class="number">2</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                                    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateRequestMessage</span>(s[<span class="number">1</span>],set));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersRequestMessage</span>(s[<span class="number">1</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinRequestMessage</span>(userName,s[<span class="number">1</span>]));</span><br><span class="line">                                                    <span class="keyword">break</span>;</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupQuitRequestMessage</span>(userName,s[<span class="number">1</span>]));</span><br><span class="line">                                                <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                                    ctx.channel().close();</span><br><span class="line">                                                    <span class="keyword">return</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,<span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-创建群组"><a href="#3-3-创建群组" class="headerlink" title="3.3 创建群组"></a>3.3 创建群组</h3><p><img data-src="/images/pasted-103.png" alt="upload successful"><br>客户端发送GroupCreateRequestMessage<br>服务器端处理的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="type">GroupSession</span> <span class="variable">groupSession</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//发送成功消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels)&#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span> , <span class="string">&quot;您已经被拉入群聊&quot;</span>+groupName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>,groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">false</span>,groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-发起群聊"><a href="#3-4-发起群聊" class="headerlink" title="3.4 发起群聊"></a>3.4 发起群聊</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels)&#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatResponseMessage</span>(msg.getFrom(),msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-5-退出处理"><a href="#3-5-退出处理" class="headerlink" title="3.5 退出处理"></a>3.5 退出处理</h3><p>当链接断开时触发，Inactive事件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuitHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//当链接断开时 触发</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;已经断开&quot;</span>,ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户异常断开</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;已经异常断开，异常是&#123;&#125;&quot;</span>,ctx.channel(),cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-6-空闲检测（连接假死）"><a href="#3-6-空闲检测（连接假死）" class="headerlink" title="3.6 空闲检测（连接假死）"></a>3.6 空闲检测（连接假死）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bs.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">//用来判断是不是读空闲时间过长，或者是写空闲时间过长</span></span><br><span class="line">                    <span class="comment">//5s内如果没有收到channel读入的数据，会触发一个IdleState#READER_IDLE事件</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>()&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//用来触发特殊事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent)evt;</span><br><span class="line">                            <span class="comment">// 触发了读空闲时间</span></span><br><span class="line">                            <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE)&#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;读空闲已经超过5s&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(LOGIN_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(CHAT_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(GROUP_CREATE_HANDLER);</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_JOIN_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_MEMBERS_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_QUIT_HANDLER);</span></span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(GROUP_CHAT_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(QUIT_HANDLER);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-7-心跳"><a href="#3-7-心跳" class="headerlink" title="3.7 心跳"></a>3.7 心跳</h3><p><img data-src="/images/pasted-104.png" alt="upload successful"><br>如果直接这么操作会产生一个问题，用户登录时并没有退出，但是超过5s后，就被服务器强制回收了。<br>为了解决这个bug，通过心跳数据包的方法，客户端一定时间向服务器发送心跳数据。  </p>
<p><img data-src="/images/pasted-105.png" alt="upload successful">  </p>
<h1 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h1><h2 id="1-优化算法"><a href="#1-优化算法" class="headerlink" title="1.优化算法"></a>1.优化算法</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上  </p>
<ul>
<li>序列化时，需要将java对象变为要传输的数据（可以是byte[],json等，最后都要变成byte[]）  </li>
<li>反序列化时，需要将输入的正文数据还原成java对象，便于处理<br>jar序列化算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz , <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Algorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span>&#123;</span><br><span class="line">        Java &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">                oos.writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-参数"><a href="#2-参数" class="headerlink" title="2.参数"></a>2.参数</h2><p>（1）CONNECT_TIMEOUT_MILLES<br><img data-src="/images/pasted-106.png" alt="upload successful">  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().option();<span class="comment">//是给ServerSocketChannel配置参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().childOption(); <span class="comment">//是给SocketChannel配置参数</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/pasted-107.png" alt="upload successful"><br>(2)SO_BACKLOG<br>三次握手：<br>已经完成三次握手的队列放入全连接队列，没完成的队列放入半连接队列。  </p>
<p><img data-src="/images/pasted-108.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-109.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-110.png" alt="upload successful"><br>当全连接队列满了之后，server发送一个拒绝连接的错误消息给client<br>在netty中，通过option(ChannelOption.SO_BACKLOG,value)来设置大小<br>(3)ulimit-n<br>属于操作系统参数，文件描述符的最大数量<br>(4)TCP_NODELAY<br>属于SocketChannel参数，false开启了nagle算法（true)<br>(6)SO_SNDBUF &amp; SO_RCVBUF<br>(7)ALLOCATOR  </p>
<ul>
<li>属于SocketChannel参数</li>
<li>用来分配ByteBuf,ctx.alloc()</li>
</ul>
<p>ctx.allc()的bytebug可以由系统环境 -Dio.netty.allocator.type&#x3D;unpooled<br>-Dio.netty.noPreferDirect&#x3D;true   </p>
<p>(8)RECBUF_ALLOCATOR</p>
<ul>
<li>属于SocketChannel参数</li>
<li>控制netty接受缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（可动态调整），统一采用direct直接内存，具体池化还是非池化由allocator决定</li>
</ul>
<p>IO操作接收数据的bytebuf，强制采用直接内存接收，效率非常高。  </p>
<p>AbstractNioByteChannel<br><img data-src="/images/pasted-111.png" alt="upload successful"><br>RecvByteBufAllocator的内部类，使用allocate方法，创建byteBuf<br>ByteBufAllocator只负责bytebuf是否是池化，真正决定bytebuf大小和direct模式由RecvByteBufAllocator决定。  </p>
<p><img data-src="/images/pasted-112.png" alt="upload successful"><br>ioBuffer强制使用直接内存  guess()会动态的数据量调整bytebuf的大小</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>拿来吧你🍗</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.JPG" alt="KaiXuan Young 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alibabapay.PNG" alt="KaiXuan Young 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>KaiXuan Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ykxzyp0517.cn/2021/09/02/netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="netty网络编程">https://ykxzyp0517.cn/2021/09/02/netty网络编程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/netty/" rel="tag"><i class="fa fa-tag"></i> netty</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/16/PriorityQueue%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="PriorityQueue的用法和底层实现原理">
                  <i class="fa fa-chevron-left"></i> PriorityQueue的用法和底层实现原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/22/Redis-Review/" rel="next" title="Redis(Review)对Redis的重新理解">
                  Redis(Review)对Redis的重新理解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KaiXuan Young</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-2" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.3/mermaid.min.js","integrity":"sha256-TIYL00Rhw/8WaoUhYTLX9SKIEFdXxg+yMWSLVUbhiLg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"KaiXuan-Y# GitHub repo owner","repo":"comments# Repository name to store issues","client_id":"54e5333f9ff5623b13af# GitHub Application Client ID","client_secret":"ff6f684d7a27df62d564197b2f2907b7aef4cae1# GitHub Application Client Secret","admin_user":"KaiXuan-Y# GitHub repo owner and collaborators, only these guys can initialize gitHub issues","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"99befd43082e631523ccdedfb9782dd3"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
