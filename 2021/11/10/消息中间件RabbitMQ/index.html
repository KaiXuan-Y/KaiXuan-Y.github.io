<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ykxzyp0517.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。">
<meta property="og:type" content="article">
<meta property="og:title" content="消息中间件RabbitMQ">
<meta property="og:url" content="https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/index.html">
<meta property="og:site_name" content="Young&#39;s Land">
<meta property="og:description" content="MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-282.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-283.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-284.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-285.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-286.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-287.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-288.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-289.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-290.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-292.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-293.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-294.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-295.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-296.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-299.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-297.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-298.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-300.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-301.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-302.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-303.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-304.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-306.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-305.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-307.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-308.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-309.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-310.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-311.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-312.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-313.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-314.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-315.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-316.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-317.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-318.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-319.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-320.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-321.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-322.png">
<meta property="og:image" content="https://ykxzyp0517.cn/images/pasted-323.png">
<meta property="article:published_time" content="2021-11-10T06:57:00.000Z">
<meta property="article:modified_time" content="2022-11-10T12:32:13.225Z">
<meta property="article:author" content="KaiXuan Young">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ykxzyp0517.cn/images/pasted-282.png">


<link rel="canonical" href="https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/","path":"2021/11/10/消息中间件RabbitMQ/","title":"消息中间件RabbitMQ"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>消息中间件RabbitMQ | Young's Land</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Young's Land" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Young's Land</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习和日常</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">16</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">3</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MQ"><span class="nav-text">1.为什么使用MQ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-RabbitMQ"><span class="nav-text">2.RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83"><span class="nav-text">2.2 四大核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">2.3 工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">2.4 常用命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-HelloWorld"><span class="nav-text">3.HelloWorld</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">3.1 生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">3.2 消费者</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Work-Queues"><span class="nav-text">4.Work Queues</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E6%90%AD%E5%BB%BA"><span class="nav-text">4.1搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88C1-C2%EF%BC%89"><span class="nav-text">4.11 消费者（C1\C2）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">4.12 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-13-%E6%B5%8B%E8%AF%95"><span class="nav-text">4.13 测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="nav-text">4.2 消息应答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">4.2.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="nav-text">4.2.2 自动应答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="nav-text">4.2.3 手动应答</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-Multiple"><span class="nav-text">4.2.4 Multiple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="nav-text">4.2.5 消息自动重新入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-%E6%B6%88%E6%81%AF%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81"><span class="nav-text">4.2.6 消息手动应答代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">生产者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88C1%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E6%96%AD%EF%BC%89"><span class="nav-text">消费者（C1等待时间断）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88C2%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF%EF%BC%89"><span class="nav-text">消费者（C2等待时间长）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">4.3 消息持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">4.3.1 队列实现持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">4.3.2 消息实现持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="nav-text">4.3.3 不公平分发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-%E9%A2%84%E5%8F%96%E5%80%BC"><span class="nav-text">4.3.4 预取值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="nav-text">5.发布确认</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="nav-text">5.1 效率对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4"><span class="nav-text">5.1.1 单个确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4"><span class="nav-text">5.1.2 批量确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E5%BC%82%E6%AD%A5%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4"><span class="nav-text">5.1.3 异步批量确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%9C%AA%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF"><span class="nav-text">5.1.4 如何处理异步未确认消息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">6.交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.2 交换机类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%97%A0%E5%90%8D-exchange"><span class="nav-text">6.3 无名 exchange</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E7%BB%91%E5%AE%9A"><span class="nav-text">6.4 绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">6.5 Fanout交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">6.5.1 消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">6.5.2 生产者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">6.6 Direct交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">6.6.1 生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">6.6.2 消费者</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">6.7 Topic交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-Topic-%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">6.7.1 Topic 的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">6.7.2 消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">6.7.3 生产者</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-text">7.死信队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%9D%A5%E6%BA%90"><span class="nav-text">7.1 来源</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KaiXuan Young"
      src="/images/headimage.jpg">
  <p class="site-author-name" itemprop="name">KaiXuan Young</p>
  <div class="site-description" itemprop="description">NO PAIN , NO GAIN</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/KaiXuan-Y" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KaiXuan-Y" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1730052751@qq.com" title="E-Mail → mailto:1730052751@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/KaiXuan-Y" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/headimage.jpg">
      <meta itemprop="name" content="KaiXuan Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Young's Land">
      <meta itemprop="description" content="NO PAIN , NO GAIN">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="消息中间件RabbitMQ | Young's Land">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          消息中间件RabbitMQ
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-10 14:57:00" itemprop="dateCreated datePublished" datetime="2021-11-10T14:57:00+08:00">2021-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-10 20:32:13" itemprop="dateModified" datetime="2022-11-10T20:32:13+08:00">2022-11-10</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。<span id="more"></span></p>
<h1 id="1-为什么使用MQ"><a href="#1-为什么使用MQ" class="headerlink" title="1.为什么使用MQ"></a>1.为什么使用MQ</h1><ul>
<li>流量消峰</li>
</ul>
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p>
<p><img data-src="/images/pasted-282.png" alt="upload successful">  </p>
<ul>
<li>应用解耦</li>
</ul>
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p>
<p><img data-src="/images/pasted-283.png" alt="upload successful">  </p>
<ul>
<li>异步处理</li>
</ul>
<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消 息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<p><img data-src="/images/pasted-284.png" alt="upload successful">  </p>
<h1 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>RabbitMQ 是一个消息中间件:它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它<code>不处理</code>快件而是<code>接收</code>， <code>存储</code>和<code>转发</code>消息数据。</p>
<p><img data-src="/images/pasted-285.png" alt="upload successful">  </p>
<h2 id="2-2-四大核心"><a href="#2-2-四大核心" class="headerlink" title="2.2 四大核心"></a>2.2 四大核心</h2><ul>
<li><p>生产者</p>
<p>  产生数据发送消息的程序是生产者</p>
</li>
<li><p>交换机</p>
<p>  交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自<code>生产者</code>的消息，另一方面它将消息 推送到<code>队列</code>中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到<code>特定队列</code>还是推 送到<code>多个队列</code>，亦或者是把消息丢弃，这个得有交换机类型决定</p>
</li>
<li><p>队列</p>
<p>  队列是 RabbitMQ 内部使用的一种数据结构，尽管<code>消息</code>流经 RabbitMQ 和应用程序，但它们<code>只能存 储在队列</code>中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p>
</li>
<li><p>消费者  </p>
<p>  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
</li>
</ul>
<p><img data-src="/images/pasted-286.png" alt="upload successful">  </p>
<h2 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h2><p><img data-src="/images/pasted-287.png" alt="upload successful"><br>Broker:接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>
<p>Virtual host:出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange&#x2F;queue 等  </p>
<p>Connection:publisher&#x2F;consumer 和 broker 之间的 TCP 连接<br>Channel:如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销  </p>
<p>Exchange:message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有:direct (point-to-point), topic (publish-subscribe) and fanout<br>(multicast)  </p>
<p>Queue:消息最终被送到这里等待 consumer 取走  </p>
<p>Binding:exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p>
<h2 id="2-4-常用命令"><a href="#2-4-常用命令" class="headerlink" title="2.4 常用命令"></a>2.4 常用命令</h2><p>添加开机启动 RabbitMQ 服务：<br>chkconfig rabbitmq-server on  </p>
<p>启动服务：<br>&#x2F;sbin&#x2F;service rabbitmq-server start  </p>
<p>查看服务状态：<br>&#x2F;sbin&#x2F;service rabbitmq-server status  </p>
<p><img data-src="/images/pasted-288.png" alt="upload successful"><br>停止服务(选择执行)：<br>&#x2F;sbin&#x2F;service rabbitmq-server stop  </p>
<p>开启 web 管理插件（启用前需要关闭RabbitMQ服务）：<br>rabbitmq-plugins enable rabbitmq_management</p>
<p>打开相应的后台管理界面<br><img data-src="/images/pasted-289.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-290.png" alt="upload successful"><br>此时还不能够登录  </p>
<blockquote>
<p>添加一个新的用户  </p>
</blockquote>
<p>创建账号<br>rabbitmqctl add_user admin 123<br>设置用户角色<br>rabbitmqctl set_user_tags admin administrator<br>设置用户权限<br>rabbitmqctl set_permissions -p “&#x2F;“ admin “.<em>“ “.</em>“ “.*”<br>用户 user_admin 具有&#x2F;vhost1 这个 virtual host 中所有资源的配置、写、读权限<br>当前用户和角色<br>rabbitmqctl list_users</p>
<h1 id="3-HelloWorld"><a href="#3-HelloWorld" class="headerlink" title="3.HelloWorld"></a>3.HelloWorld</h1><p><img data-src="/images/pasted-292.png" alt="upload successful">  </p>
<p>pom</p>
<pre><code>&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.8.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;8&lt;/source&gt;
                    &lt;target&gt;8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>整体架构  </p>
<p><img data-src="/images/pasted-293.png" alt="upload successful">  </p>
<h2 id="3-1-生产者"><a href="#3-1-生产者" class="headerlink" title="3.1 生产者"></a>3.1 生产者</h2><pre><code>public class Producer &#123;

    //队列名称
    public static final  String QUEUE_NAME = &quot;hello&quot;;

    //发消息
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建一个链接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //工厂ip， 连接rabbitmq队列
        factory.setHost(&quot;192.168.200.160&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;123&quot;);

        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        //创建一个队列
        /**
         * @param1:String queue:队列名称
         * @param2:boolean durable:队列里的消息是否持久化在磁盘，默认情况存储在内存
         * @param3：boolean exclusive：该队列是否只能让一个消费者消费，是否进行消息共享，true表示可以多个消费者消费，false表示不可以
         * @param4:boolean autoDelete: 是都自动删除，最后一个消费者断开连接后，该队列是否自动删除
         *
         * @param5:Map&lt;String, Object&gt; arguments  :null
         */
        channel.queueDeclare(QUEUE_NAME , false , false , false , null);

        //发消息
        String message = &quot;hello world&quot;;

        /**
         * @param1:表示发送到哪个交换机
         * @param2:路由的Key值是哪个，本次是队列的名称
         * @param3:其他参数信息
         * @param4:发送其他消息的消息体
         */
        channel.basicPublish(&quot;&quot; ,QUEUE_NAME , null , message.getBytes() );
        System.out.println(&quot;消息发送完毕&quot;);


    &#125;
&#125;
</code></pre>
<p><img data-src="/images/pasted-294.png" alt="upload successful">  </p>
<h2 id="3-2-消费者"><a href="#3-2-消费者" class="headerlink" title="3.2 消费者"></a>3.2 消费者</h2><pre><code>public class Consumer &#123;
    //队列的名称
    public static final String QUEUE_NAME = &quot;hello&quot;;

    //接受消息
    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;192.168.200.160&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;123&quot;);
        Connection connection = factory.newConnection();

        DeliverCallback deliverCallback = (String consumerTag, Delivery message) -&gt; &#123;
            System.out.println(new String(message.getBody()));
        &#125;;
        CancelCallback cancelCallback = consumerTag -&gt; &#123;
            System.out.println(&quot;消费消息被中断&quot;);
        &#125;;

        Channel channel = connection.createChannel();
        /**
         * 消费者消费消息
         * @param1:消费那个队列
         * @param2:消费成功后是否要自动应答，true表示自动应答，false表示手动应答
         * @param3:消费者成功消费的回调
         * @param4:消费者取消消费的回调
         */
        channel.basicConsume(QUEUE_NAME ,true, deliverCallback , cancelCallback);
    &#125;
&#125;
</code></pre>
<p><img data-src="/images/pasted-295.png" alt="upload successful">  </p>
<h1 id="4-Work-Queues"><a href="#4-Work-Queues" class="headerlink" title="4.Work Queues"></a>4.Work Queues</h1><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。  </p>
<p><img data-src="/images/pasted-296.png" alt="upload successful"><br>因此RabbitMQ采用<code>轮询</code>的方式分发消息，防止任务处理多次  </p>
<h2 id="4-1搭建"><a href="#4-1搭建" class="headerlink" title="4.1搭建"></a>4.1搭建</h2><p><img data-src="/images/pasted-299.png" alt="upload successful">  </p>
<p>工具类</p>
<pre><code>public class RabbitMQUtils &#123;
    public static Channel getChannel() throws Exception&#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;192.168.200.160&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;123&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h3 id="4-11-消费者（C1-C2）"><a href="#4-11-消费者（C1-C2）" class="headerlink" title="4.11 消费者（C1\C2）"></a>4.11 消费者（C1\C2）</h3><pre><code>public class Work01 &#123;
    public static final  String QUEUE_NAME = &quot;hello&quot;;


    //接受消息
    public static void main(String[] args) throws Exception &#123;
        DeliverCallback deliverCallback = (consumerTag , message) -&gt; &#123;
            System.out.println(&quot;接受到的消息&quot; + new String(message.getBody()));
        &#125;;

        //消息接收被取消时执行下面的内容
        CancelCallback cancelCallback = (consumerTag)  -&gt; &#123;
            System.out.println(consumerTag +&quot;消息者取消消费接口回调&quot;);
        &#125;;
        Channel channel = RabbitMQUtils.getChannel();
        System.out.println(&quot;C2_等待接受消息....&quot;);
        //消息的接收
        channel.basicConsume(QUEUE_NAME,false,deliverCallback , cancelCallback);
    &#125;
&#125;
</code></pre>
<h3 id="4-12-生产者"><a href="#4-12-生产者" class="headerlink" title="4.12 生产者"></a>4.12 生产者</h3><pre><code>public class Task01 &#123;
    public static final String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        channel.queueDeclare(QUEUE_NAME,false,false , false ,null);
        //从控制台接受信息
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null , message.getBytes());
            System.out.println(&quot;发送消息完成&quot; + message);
        &#125;

    &#125;
</code></pre>
<h3 id="4-13-测试"><a href="#4-13-测试" class="headerlink" title="4.13 测试"></a>4.13 测试</h3><p><img data-src="/images/pasted-297.png" alt="upload successful"></p>
<p><img data-src="/images/pasted-298.png" alt="upload successful"><br>成功完成多个线程工作消息只能处理一次，不能处理多次  </p>
<h2 id="4-2-消息应答"><a href="#4-2-消息应答" class="headerlink" title="4.2 消息应答"></a>4.2 消息应答</h2><h3 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1 概念"></a>4.2.1 概念</h3><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。</p>
<blockquote>
<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。  </p>
</blockquote>
<h3 id="4-2-2-自动应答"><a href="#4-2-2-自动应答" class="headerlink" title="4.2.2 自动应答"></a>4.2.2 自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<code>高吞吐量和数据传输安全性方面</code>做权 衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制， 当 然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</p>
<h3 id="4-2-3-手动应答"><a href="#4-2-3-手动应答" class="headerlink" title="4.2.3 手动应答"></a>4.2.3 手动应答</h3><p>A.Channel.basicAck(用于肯定确认)<br>RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了<br>B.Channel.basicNack(用于否定确认)<br>C.Channel.basicReject(用于否定确认)<br>与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了</p>
<h3 id="4-2-4-Multiple"><a href="#4-2-4-Multiple" class="headerlink" title="4.2.4 Multiple"></a>4.2.4 Multiple</h3><p>手动应答的好处是可以批量应答并且减少网络拥堵  </p>
<p><img data-src="/images/pasted-300.png" alt="upload successful">  </p>
<blockquote>
<p>multiple 的 true 和 false 代表不同意思  </p>
</blockquote>
<p>true 代表批量应答 channel 上未应答的消息<br>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时  5-8 的这些还未应答的消息都会被确认收到消息应答<br>false 同上面相比  只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答    </p>
<p><img data-src="/images/pasted-301.png" alt="upload successful">  </p>
<h3 id="4-2-5-消息自动重新入队"><a href="#4-2-5-消息自动重新入队" class="headerlink" title="4.2.5 消息自动重新入队"></a>4.2.5 消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。  </p>
<p><img data-src="/images/pasted-302.png" alt="upload successful">  </p>
<h3 id="4-2-6-消息手动应答代码"><a href="#4-2-6-消息手动应答代码" class="headerlink" title="4.2.6 消息手动应答代码"></a>4.2.6 消息手动应答代码</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code>/**
 * Created on 2022/11/9.
 *  消息在手动应答时是不会消失的，放回队列中重新消费
 * @author KaiXuan Yang
 */
public class Task2 &#123;
    public static final String task_queue_name = &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        channel.queueDeclare(task_queue_name,false,false,false,null);

        //从控制台输入信息
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(&quot;&quot;,task_queue_name , null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息&quot;+message);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="消费者（C1等待时间断）"><a href="#消费者（C1等待时间断）" class="headerlink" title="消费者（C1等待时间断）"></a>消费者（C1等待时间断）</h4><pre><code>/**
 * Created on 2021/11/9.
 *  消息在手动应答时不会丢失，放回队列重新消费
 * @author KaiXuan Yang
 */
public class Worker03 &#123;
    public static final String task_queue_name = &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        System.out.println(&quot;C1等待接收消息处理，事件较短&quot;);
        DeliverCallback deliverCallback = ( consumerTag,  message) -&gt; &#123;
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;


            System.out.println(&quot;接收到的消息：&quot;+ new String(message.getBody() , &quot;UTF-8&quot;));
            /**
             * @param1:消息的标记
             * @param2:是否批量应答 false:不批量应答信道中的消息 true
             */
            channel.basicAck(message.getEnvelope().getDeliveryTag() , false);


        &#125;;

        boolean autoAck = false;
        channel.basicConsume(task_queue_name , autoAck ,deliverCallback,(consumerTag -&gt; &#123;
            System.out.println(&quot;消费者取消消费&quot;);
        &#125;));
    &#125;
&#125;
</code></pre>
<h4 id="消费者（C2等待时间长）"><a href="#消费者（C2等待时间长）" class="headerlink" title="消费者（C2等待时间长）"></a>消费者（C2等待时间长）</h4><pre><code>/**
 * Created on 2021/11/9.
 *  消息在手动应答时不会丢失，放回队列重新消费
 * @author KaiXuan Yang
 */
public class Worker04 &#123;
    public static final String task_queue_name = &quot;ack_queue&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        System.out.println(&quot;C2等待接收消息处理，事件较短&quot;);
        DeliverCallback deliverCallback = ( consumerTag,  message) -&gt; &#123;
            try &#123;
                TimeUnit.SECONDS.sleep(30);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;


            System.out.println(&quot;接收到的消息：&quot;+ new String(message.getBody() , &quot;UTF-8&quot;));
            /**
             * @param1:消息的标记
             * @param2:是否批量应答 false:不批量应答信道中的消息 true
             */
            channel.basicAck(message.getEnvelope().getDeliveryTag() , false);


        &#125;;

        boolean autoAck = false;
        channel.basicConsume(task_queue_name , autoAck ,deliverCallback,(consumerTag -&gt; &#123;
            System.out.println(&quot;消费者取消消费&quot;);
        &#125;));
    &#125;
&#125;
</code></pre>
<p><img data-src="/images/pasted-303.png" alt="upload successful"><br>挂掉C2后，消息因为是手动应答并不会丢失，而是由C1消费消息。</p>
<p><img data-src="/images/pasted-304.png" alt="upload successful">  </p>
<h2 id="4-3-消息持久化"><a href="#4-3-消息持久化" class="headerlink" title="4.3 消息持久化"></a>4.3 消息持久化</h2><p>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消 息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列 和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事:我们需要将队列和消息都标 记为持久化。  </p>
<h3 id="4-3-1-队列实现持久化"><a href="#4-3-1-队列实现持久化" class="headerlink" title="4.3.1 队列实现持久化"></a>4.3.1 队列实现持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启，该队列就会被删除掉，如果 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p>
<p><img data-src="/images/pasted-306.png" alt="upload successful">  </p>
<blockquote>
<p>但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新<br>创建一个持久化的队列，不然就会出现错误  </p>
</blockquote>
<p><img data-src="/images/pasted-305.png" alt="upload successful">  </p>
<h3 id="4-3-2-消息实现持久化"><a href="#4-3-2-消息实现持久化" class="headerlink" title="4.3.2 消息实现持久化"></a>4.3.2 消息实现持久化</h3><p>要想让消息实现持久化需要在消息生产者修改代码，<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code> 添 加这个属性。<br>设置生产者发送消息为持久化消息，保存在磁盘上，不然保存在内存中<br><img data-src="/images/pasted-307.png" alt="upload successful"><br>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。  </p>
<h3 id="4-3-3-不公平分发"><a href="#4-3-3-不公平分发" class="headerlink" title="4.3.3 不公平分发"></a>4.3.3 不公平分发</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
<blockquote>
<p>为了避免这种情况，我们可以设置参数 channel.basicQos(1);  </p>
</blockquote>
<pre><code>    channel.basicQos(1);
    
    
</code></pre>
<p><img data-src="/images/pasted-308.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-309.png" alt="upload successful"><br>此时处理快的C1处理更多的消费，充分利用能力  </p>
<h3 id="4-3-4-预取值"><a href="#4-3-4-预取值" class="headerlink" title="4.3.4 预取值"></a>4.3.4 预取值</h3><pre><code>        //设置不公平分发
        int prefetchCount = 1;
        //预取值
//        int prefetchCount = 5;
        channel.basicQos(prefetchCount);
</code></pre>
<p><img data-src="/images/pasted-310.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-311.png" alt="upload successful"><br>设置预取值是为了<code>限制此 缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</code><br><code>该值定义通道上允许的未确认消息的最大数量</code>一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。</p>
<h1 id="5-发布确认"><a href="#5-发布确认" class="headerlink" title="5.发布确认"></a>5.发布确认</h1><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。<br>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。<br><img data-src="/images/pasted-312.png" alt="upload successful"><br>只进行1 ， 2两个步骤是不能保证消息进行持久化的，比如说步骤1持久化队列，步骤2进行消息的持久化的，在系统的时间间隔内，MQ就挂了，就不能保证消息能够持久化成功了<br>因此必须要进行<code>发布确认</code>才行  </p>
<pre><code>public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        //开启发布确认
        channel.confirmSelect();
        channel.queueDeclare(task_queue_name,false,false,false,null);

        //从控制台输入信息
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(&quot;&quot;,task_queue_name , MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产者发出消息&quot;+message);
        &#125;
    &#125;
</code></pre>
<h2 id="5-1-效率对比"><a href="#5-1-效率对比" class="headerlink" title="5.1 效率对比"></a>5.1 效率对比</h2><h3 id="5-1-1-单个确认"><a href="#5-1-1-单个确认" class="headerlink" title="5.1.1 单个确认"></a>5.1.1 单个确认</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它 被确认发布，后续的消息才能继续发布,<code>waitForConfirmsOrDie(long)</code>这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。<br>这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。</p>
<pre><code>public class ConfirmMessage &#123;

    //批量发送消息的个数
    public static final int MESSAGE_COUNT = 1000;
    public static void main(String[] args) throws Exception &#123;
        ConfirmMessage.publishMessageIndividually();

    &#125;
    //单个确认
    public static void publishMessageIndividually() throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        //队列的队名
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName ,false , false , false , null);
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();

        for (int i = 0 ; i &lt; MESSAGE_COUNT ; i ++)&#123;
            String message = i + &quot;&quot;;
            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes() );
            //单个消息马上进行发布确认
            boolean flag = channel.waitForConfirms();
            if (flag)&#123;
                System.out.println(&quot;消息发送成功&quot;);
            &#125;
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;消费时间：&quot; + (end - begin));
    &#125;

&#125;
</code></pre>
<p><img data-src="/images/pasted-313.png" alt="upload successful">  </p>
<h3 id="5-1-2-批量确认"><a href="#5-1-2-批量确认" class="headerlink" title="5.1.2 批量确认"></a>5.1.2 批量确认</h3><p>上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地 提高吞吐量，当然这种方式的缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现 问题了，我们必须将整个<code>批处理</code>保存在内存中，以记录重要的信息而后重新发布消息。当然这种 方案仍然是<code>同步</code>的，也一样阻塞消息的发布。</p>
<pre><code>public static void publicMessageBatch() throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        //队列的队名
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName ,false , false , false , null);
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();

        //批量确认消息大小
        int batchSize = 100;
        for (int i = 0 ; i &lt; MESSAGE_COUNT ; i ++)&#123;
            String message = i + &quot;&quot;;
            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes() );
            //判断达到了100条消息的时候批量确认一次
            if(i % 100 == 0)&#123;
                channel.waitForConfirms();
            &#125;

        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;消费时间：&quot; + (end - begin));
    &#125;
</code></pre>
<p>   <img data-src="/images/pasted-314.png" alt="upload successful">    </p>
<h3 id="5-1-3-异步批量确认"><a href="#5-1-3-异步批量确认" class="headerlink" title="5.1.3 异步批量确认"></a>5.1.3 异步批量确认</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。  </p>
<p><img data-src="/images/pasted-315.png" alt="upload successful">  </p>
<pre><code>//异步发布确认
    public static void publishMessageAsync() throws Exception&#123;
        Channel channel = RabbitMQUtils.getChannel();
        //队列的队名
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName ,false , false , false , null);
        channel.confirmSelect();
        //开始时间
        long begin = System.currentTimeMillis();

        ConfirmCallback ackCallback = ( deliveryTag,  multiple) -&gt; &#123;
            System.out.println(&quot;确认的消息：&quot; + deliveryTag);
        &#125;;
        /**
         * @param1 : 消息的标记
         * @param2 : 是否为批量确认
         */
        ConfirmCallback nackCallback = ( deliveryTag,  multiple) -&gt; &#123;
            System.out.println(&quot;未确认的消息：&quot; + deliveryTag);
        &#125;;
        /**
         *@param1 监听哪些消息成功
         *@param2 哪些消息失败
         */
        //准备消息的监听器  监听哪些消息成功，哪些消息失败
        channel.addConfirmListener(ackCallback , nackCallback); //异步通知


        //批量发送信息
        for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
            String message = &quot;消息&quot; + i;
            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes());

        &#125;
        //结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;消费时间：&quot; + (end - begin));
    &#125;
</code></pre>
<p>可以得知 ，异步确认消息的效率是最快的</p>
<h3 id="5-1-4-如何处理异步未确认消息"><a href="#5-1-4-如何处理异步未确认消息" class="headerlink" title="5.1.4 如何处理异步未确认消息"></a>5.1.4 如何处理异步未确认消息</h3><p><img data-src="/images/pasted-316.png" alt="upload successful"><br>我们发现的问题是，以及发送完消息显示发送时间后，监听器任然监听到消息人发送完成的回调信息，如果此时消息发送失败我们该如何处理呢？<br>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传 递。  </p>
<pre><code>//异步发布确认
    public static void publishMessageAsync() throws Exception&#123;
        Channel channel = RabbitMQUtils.getChannel();
        //队列的队名
        String queueName = UUID.randomUUID().toString();
        channel.queueDeclare(queueName ,false , false , false , null);
        channel.confirmSelect();

        /**
         * 线程安全有序的一个哈希表，适用于高并发的情况下关联发布线程和回调线程
         * 1.轻松的将序号与消息进行关联
         * 2.轻松的批量删除已经确认的消息
         * 3.支持高并发
         */
        ConcurrentSkipListMap&lt;Long , String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;&gt;();


        ConfirmCallback ackCallback = ( deliveryTag,  multiple) -&gt; &#123;
            if (multiple)&#123;
                ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(deliveryTag);
                confirmed.clear();
            &#125;else &#123;
                outstandingConfirms.remove(deliveryTag);
            &#125;
            System.out.println(&quot;确认的消息：&quot; + deliveryTag);
        &#125;;

        ConfirmCallback nackCallback = ( deliveryTag,  multiple) -&gt; &#123;
            System.out.println(&quot;未确认的消息：&quot; + deliveryTag);
        &#125;;
        channel.addConfirmListener(ackCallback , nackCallback); //异步通知


        long begin = System.currentTimeMillis();
        for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
            String message = &quot;消息&quot; + i;
            channel.basicPublish(&quot;&quot; , queueName , null , message.getBytes());
            //1.此处记录下所有要发送的消息  消息的总和
            outstandingConfirms.put(channel.getNextPublishSeqNo() , message);
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;消费时间：&quot; + (end - begin));
    &#125;
</code></pre>
<h1 id="6-交换机"><a href="#6-交换机" class="headerlink" title="6.交换机"></a>6.交换机</h1><p><img data-src="/images/pasted-317.png" alt="upload successful"><br>先前的问题是，一个队列中的消息只能被消费一次，如果想要多次订阅呢？那就得用交换机，创造多个队列。  </p>
<h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h2><p>RabbitMQ 消息传递模型的核心思想是: <code>生产者生产的消息从不会直接发送到队列</code>。实际上，通常生产 者甚至都不知道这些消息传递传递到了哪些队列中。<br>相反，生产者<code>只能将消息发送到交换机(exchange)</code>，交换机工作的内容非常简单，一方面它<code>接收</code>来 自生产者的消息，另一方面将<code>它们推入队列</code>。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到<code>特定队列</code>还是说把他们到<code>许多队列</code>中还是说应该<code>丢弃</code>它们。这就的由交换机的<code>类型来决定</code>。</p>
<h2 id="6-2-交换机类型"><a href="#6-2-交换机类型" class="headerlink" title="6.2 交换机类型"></a>6.2 交换机类型</h2><p>直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)</p>
<h2 id="6-3-无名-exchange"><a href="#6-3-无名-exchange" class="headerlink" title="6.3 无名 exchange"></a>6.3 无名 exchange</h2><p><img data-src="/images/pasted-318.png" alt="upload successful"><br>第一个参数是交换机的名称。空字符串表示默认或无名称交换机:消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话  </p>
<h2 id="6-4-绑定"><a href="#6-4-绑定" class="headerlink" title="6.4 绑定"></a>6.4 绑定</h2><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p>
<p><img data-src="/images/pasted-319.png" alt="upload successful">  </p>
<h2 id="6-5-Fanout交换机"><a href="#6-5-Fanout交换机" class="headerlink" title="6.5 Fanout交换机"></a>6.5 Fanout交换机</h2><p>Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息<code>广播</code>到它知道的 <code>所有队列</code>中。系统中默认有些 exchange 类型。Fanout模式不会管routingKey，无论routingKey多少，直接把消息放松给所有绑定的队列  </p>
<p><img data-src="/images/pasted-320.png" alt="upload successful">  </p>
<p><img data-src="/images/pasted-321.png" alt="upload successful">  </p>
<h3 id="6-5-1-消费者"><a href="#6-5-1-消费者" class="headerlink" title="6.5.1 消费者"></a>6.5.1 消费者</h3><pre><code>public class ReceiveLogs02 &#123;
    public static final String EXCHANGE_NAME = &quot;logs&quot;;
    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME , &quot;fanout&quot;);
        //声明一个队列 临时队列 队列名称是随机的
        //当消费者断开连接后，队列删除
        String queueName = channel.queueDeclare().getQueue();
        /**
         * 绑定交换机与队列
         */
        channel.queueBind(queueName , EXCHANGE_NAME , &quot;&quot;);
        System.out.println(&quot;等待接受消息。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag,  message) -&gt; &#123;
            System.out.println(&quot;控制台消息：&quot; + new String(message.getBody() , &quot;UTF-8&quot;));
        &#125;;
        channel.basicConsume(queueName , true ,deliverCallback ,consumerTag -&gt; &#123;&#125; );
    &#125;
&#125;
</code></pre>
<h3 id="6-5-2-生产者"><a href="#6-5-2-生产者" class="headerlink" title="6.5.2 生产者"></a>6.5.2 生产者</h3><pre><code>public class EmitLog &#123;
    //交换机的名称
    public static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME ,&quot;fanout&quot;);

        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME , &quot;&quot; , null , message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产在发出消息：&quot; + message);
        &#125;

    &#125;
&#125;
</code></pre>
<h2 id="6-6-Direct交换机"><a href="#6-6-Direct交换机" class="headerlink" title="6.6 Direct交换机"></a>6.6 Direct交换机</h2><p>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。</p>
<p><img data-src="/images/pasted-322.png" alt="upload successful"><br>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.<br>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。<br>绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h3 id="6-6-1-生产者"><a href="#6-6-1-生产者" class="headerlink" title="6.6.1 生产者"></a>6.6.1 生产者</h3><pre><code>public class DirectLogs &#123;
    //交换机的名称
    public static final String EXCHANGE_NAME = &quot;direct_logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME , &quot;error&quot; , null , message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;生产在发出消息：&quot; + message);
        &#125;

    &#125;
&#125;
</code></pre>
<h3 id="6-6-2-消费者"><a href="#6-6-2-消费者" class="headerlink" title="6.6.2 消费者"></a>6.6.2 消费者</h3><pre><code>public class ReceiveLogsDirect01 &#123;
    public static final String EXCHANGE_NAME = &quot;direct_logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME , BuiltinExchangeType.DIRECT);
        //声明一个队列
        channel.queueDeclare(&quot;console&quot; , false , false , false , null);
        //绑定队列和交换机
        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME , &quot;info&quot;);
        channel.queueBind(&quot;console&quot;,EXCHANGE_NAME , &quot;warning&quot;);

        //接受消息
        DeliverCallback deliverCallback = (consumerTag,  message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogsDirect01：&quot; + new String(message.getBody() , &quot;UTF-8&quot;));
        &#125;;
        channel.basicConsume(&quot;console&quot; , true , deliverCallback , consumerTag -&gt; &#123;&#125;);

    &#125;
&#125;
</code></pre>
<h2 id="6-7-Topic交换机"><a href="#6-7-Topic交换机" class="headerlink" title="6.7 Topic交换机"></a>6.7 Topic交换机</h2><p>尽管使用direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候 就只能使用 topic 类型</p>
<h3 id="6-7-1-Topic-的要求"><a href="#6-7-1-Topic-的要求" class="headerlink" title="6.7.1 Topic 的要求"></a>6.7.1 Topic 的要求</h3><p>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单 词列表，以点号分隔开。这些单词可以是任意单词，比如说:”stock.usd.nyse”,   “nyse.vmw”, “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p>
<blockquote>
<p>*(星号)可以代替一个单词<br>#(井号)可以替代零个或多个单词  </p>
</blockquote>
<p><img data-src="/images/pasted-323.png" alt="upload successful">  </p>
<h3 id="6-7-2-消费者"><a href="#6-7-2-消费者" class="headerlink" title="6.7.2 消费者"></a>6.7.2 消费者</h3><pre><code>public class ReceiveLogsTopic02 &#123;
    //交换机名称
    public static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME , BuiltinExchangeType.TOPIC);
        channel.queueDeclare(&quot;Q2&quot; , false , false , false ,null);
        channel.queueBind(&quot;Q2&quot; , EXCHANGE_NAME , &quot;lazy.#&quot;);
        channel.queueBind(&quot;Q2&quot; , EXCHANGE_NAME , &quot;*.*.rabbit&quot;);


        System.out.println(&quot;等待接受消息。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag , message) -&gt; &#123;
            System.out.println(&quot;接收到的消息：&quot; + new String(message.getBody() , &quot;UTF_*&quot;));
            System.out.println(&quot;接受队列：&quot; + &quot;Q2&quot; + &quot;绑定键：&quot; + message.getEnvelope().getRoutingKey());

        &#125;;
        channel.basicConsume(&quot;Q2&quot; , true ,deliverCallback ,consumerTag -&gt; &#123;&#125; );

    &#125;
    
&#125;
</code></pre>
<h3 id="6-7-3-生产者"><a href="#6-7-3-生产者" class="headerlink" title="6.7.3 生产者"></a>6.7.3 生产者</h3><pre><code>public class TopicExchangeOmit &#123;
    public static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] args) throws Exception &#123;
        Channel channel = RabbitMQUtils.getChannel();
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext())&#123;
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME ,&quot;lazy.1&quot; ,null ,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;消息已经发送&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="7-死信队列"><a href="#7-死信队列" class="headerlink" title="7.死信队列"></a>7.死信队列</h1><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。<br>应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息 消费发生异常时，将消息投入死信队列中.还有比如说: 用户在商城下单成功并点击去支付后在指定时 间未支付时自动失效  </p>
<h2 id="7-1-来源"><a href="#7-1-来源" class="headerlink" title="7.1 来源"></a>7.1 来源</h2><p>消息 TTL 过期<br>队列达到最大长度(队列满了，无法再添加数据到 mq 中)<br>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false  </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>拿来吧你🍗</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.JPG" alt="KaiXuan Young 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alibabapay.PNG" alt="KaiXuan Young 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>KaiXuan Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ykxzyp0517.cn/2021/11/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ/" title="消息中间件RabbitMQ">https://ykxzyp0517.cn/2021/11/10/消息中间件RabbitMQ/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/04/LambdaQueryWrapper%E7%9A%84%E7%90%86%E8%A7%A3/" rel="prev" title="LambdaQueryWrapper的理解">
                  <i class="fa fa-chevron-left"></i> LambdaQueryWrapper的理解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/23/%E4%B8%80%E4%BB%BD%E8%AF%A6%E7%BB%86%E7%9A%84Docker%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/" rel="next" title="一份详细的Docker学习教程">
                  一份详细的Docker学习教程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KaiXuan Young</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-2" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.3/mermaid.min.js","integrity":"sha256-TIYL00Rhw/8WaoUhYTLX9SKIEFdXxg+yMWSLVUbhiLg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"KaiXuan-Y# GitHub repo owner","repo":"comments# Repository name to store issues","client_id":"54e5333f9ff5623b13af# GitHub Application Client ID","client_secret":"ff6f684d7a27df62d564197b2f2907b7aef4cae1# GitHub Application Client Secret","admin_user":"KaiXuan-Y# GitHub repo owner and collaborators, only these guys can initialize gitHub issues","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"c8b4becda9da9542ad472c15a46a3195"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
